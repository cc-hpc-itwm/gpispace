/*
 * Copyright 2009 Fraunhofer Gesellschaft, Munich, Germany,
 * for its Fraunhofer Institute for Computer Architecture and Software
 * Technology (FIRST), Berlin, Germany 
 * All rights reserved. 
 */
//gwes
#include <gwes/TransitionOccurrence.h>
#include <gwes/XPathEvaluator.h>

using namespace std;
using namespace gwdl;

namespace gwes {

/**
 * Constructor.
 */
TransitionOccurrence::TransitionOccurrence(Transition* transition) : _logger(fhg::log::Logger::get("gwes")) {
	transitionP = transition;
	activityP = NULL;
	hasXPathEdgeExpressions=false;
	simulation=false;
	vector<Edge*> edges;

	// identifier
	ostringstream id;
    id << transitionP->getID();

    // read tokens
	edges = transitionP->getReadEdges();
	for (size_t i=0; i<edges.size(); i++) {
		Token* tokenP = edges[i]->getPlace()->getNextUnlockedToken();
		if (tokenP == NULL) {
			LOG_WARN(_logger, "ERROR: There is no unlocked Token on place '" << edges[i]->getPlace()->getID() << "' available!");
		} else {
			LOG_DEBUG(_logger, transitionP->getID() << ": building parameter from read token " << tokenP->getID());
			parameter_t* tpP = new TokenParameter(tokenP, edges[i], TokenParameter::SCOPE_READ); 
			tokens.push_back(*tpP); 
			id << "_r" << tokenP->getID(); 
		}
	}

	// input tokens
	edges = transitionP->getInEdges();
	for (size_t i=0; i<edges.size(); i++) {
		Token* tokenP = edges[i]->getPlace()->getNextUnlockedToken();
		if (tokenP == NULL) {
			LOG_WARN(_logger, "ERROR: There is no unlocked Token on place '" << edges[i]->getPlace()->getID() << "' available!");
		} else {
			LOG_DEBUG(_logger, transitionP->getID() << ": building parameter from input token " << tokenP->getID());
			parameter_t* tpP = new TokenParameter(tokenP, edges[i], TokenParameter::SCOPE_INPUT); 
			tokens.push_back(*tpP); 
			id << "_i" << tokenP->getID(); 
		}
	}

	// write tokens 
	edges = transitionP->getWriteEdges();
	for (size_t i=0; i<edges.size(); i++) {
		Token* tokenP = edges[i]->getPlace()->getNextUnlockedToken();
		if (tokenP == NULL) {
			LOG_WARN(_logger, "ERROR: There is no unlocked Token on place '" << edges[i]->getPlace()->getID() << "' available!");
		} else {
			if (!hasXPathEdgeExpressions) {
				string edgeExpression = edges[i]->getExpression();
				if (edgeExpression.find("$")!=edgeExpression.npos) hasXPathEdgeExpressions=true; 
			}
			LOG_DEBUG(_logger, transitionP->getID() << ": building parameter from write token " << tokenP->getID());
			parameter_t* tpP = new TokenParameter(tokenP, edges[i], TokenParameter::SCOPE_WRITE); 
			tokens.push_back(*tpP);
			id << "_w" << tokenP->getID(); 
		}
	}

	// dummy output tokens (real output tokens will be generated by activities or XPath edge expressions) 
	edges = transitionP->getOutEdges();
	for (size_t i=0; i<edges.size(); i++) {
		if (!hasXPathEdgeExpressions) {
			string edgeExpression = edges[i]->getExpression();
			if (edgeExpression.find("$")!=edgeExpression.npos) hasXPathEdgeExpressions=true; 
		}
		LOG_DEBUG(_logger, transitionP->getID() << ": building parameter from dummy output token");
		parameter_t* tpP = new TokenParameter(NULL, edges[i], TokenParameter::SCOPE_OUTPUT); 
		tokens.push_back(*tpP); 
	}
	
	// identifier
	_id = id.str();
}

/**
 * Destructor.
 */
TransitionOccurrence::~TransitionOccurrence() { 
	///ToDo: is it enough just to clear the list?
//	for (parameter_list_t::iterator it=tokens.begin(); it!=tokens.end(); ++it) {
//		delete &it;
//	}
	tokens.clear();
}

void TransitionOccurrence::lockTokens() {
	LOG_DEBUG(_logger, "lockTokens[" << getID() << "] ...");
	for (parameter_list_t::iterator it=tokens.begin(); it!=tokens.end(); ++it) {
		switch (it->scope) {
		case (TokenParameter::SCOPE_READ):
			continue;
		case (TokenParameter::SCOPE_INPUT):
			it->edgeP->getPlace()->lockToken(it->tokenP,transitionP);
			break;
		case (TokenParameter::SCOPE_WRITE):	
		case (TokenParameter::SCOPE_OUTPUT):	
			return;
		}
	}
}

void TransitionOccurrence::unlockTokens() {
	LOG_DEBUG(_logger, "unlockTokens[" << getID() << "] ...");
	for (parameter_list_t::iterator it=tokens.begin(); it!=tokens.end(); ++it) {
		switch (it->scope) {
		case (TokenParameter::SCOPE_READ):
			continue;
		case (TokenParameter::SCOPE_INPUT):
			it->edgeP->getPlace()->unlockToken(it->tokenP);
			break;
		case (TokenParameter::SCOPE_WRITE):	
		case (TokenParameter::SCOPE_OUTPUT):	
			return;
		}
	}
}

bool TransitionOccurrence::checkConditions(int step) const {
	if (transitionP->getConditions().empty()) return true;

	LOG_DEBUG(logger_t(getLogger("gwes")), "checkConditions[" << getID() << "] ...");
	const vector<string> conditions = transitionP->getConditions();
	XPathEvaluator* xpathP = new XPathEvaluator(this,step);
	bool cond = true;
	for (size_t i=0; i<conditions.size(); i++) {
		string condition = conditions[i];
		if ( !xpathP->evalCondition(condition) ) {
			cond = false;
			break;
		}
	}
	delete xpathP;
	return cond;
}

void TransitionOccurrence::removeInputTokens() {
	for (parameter_list_t::iterator it=tokens.begin(); it!=tokens.end(); ++it) {
		switch (it->scope) {
		case (TokenParameter::SCOPE_READ):
			continue;
		case (TokenParameter::SCOPE_INPUT):
			LOG_DEBUG(_logger, "removeInputTokens[" << getID() << "] removing token 'i" << it->tokenP->getID() << "' from place '" << it->edgeP->getPlace()->getID() << "'");
			it->edgeP->getPlace()->removeToken(it->tokenP);
			it->tokenP = NULL;
			break;
		case (TokenParameter::SCOPE_WRITE):	
		case (TokenParameter::SCOPE_OUTPUT):	
			return;
		}
	}
}

void TransitionOccurrence::putOutputTokens() throw (CapacityException) {
	for (parameter_list_t::iterator it=tokens.begin(); it!=tokens.end(); ++it) {
		switch (it->scope) {
		case (TokenParameter::SCOPE_READ):
			continue;
		case (TokenParameter::SCOPE_INPUT):
			continue;
		case (TokenParameter::SCOPE_WRITE):	
			continue;
		case (TokenParameter::SCOPE_OUTPUT):
			// generate missing tokens. 
			if (it->tokenP == NULL) {
				if (it->edgeP->getExpression().empty()) {             // missing output token without edge expression
					if (activityP != NULL) {
						it->tokenP = new Token(activityP->getStatus()==Activity::STATUS_COMPLETED);
					} else {
						it->tokenP = new Token(true);
					}
				} else {                                                  // missing output token with edge expression
					///put SOAP Fault if there is no data for edge expression
					ostringstream fault;
					fault << "<data><soapenv:Fault xmlns:soapenv=\"http://www.w3.org/2003/05/soap-envelope\">";
					fault << "<soapenv:Code><soapenv:Value>env:Receive</soapenv:Value></soapenv:Code>";
					fault << "<soapenv:Reason><soapenv:Text xml:lang=\"en\">";
					if (activityP != NULL) {
						fault << "Activity '"  << activityP->getID() << "': "; 
					}
					fault << "Not Output Available</soapenv:Text></soapenv:Reason>";
					fault << "<soapenv:Detail>The transition occurrence '" << getID();
					fault << "' has no output parameter related to the edge expression '" << it->edgeP->getExpression();
					fault << "'</soapenv:Detail>";
					fault << "</soapenv:Fault></data>";
					it->tokenP = new Token(new Data(fault.str()));
				}
			}
			// put token to output place
			LOG_DEBUG(_logger, "putOutputTokens[" << getID() << "] putting token 'o" << it->tokenP->getID() << "' to place '" << it->edgeP->getPlace()->getID() << "'");
			it->edgeP->getPlace()->addToken(it->tokenP);
			break;
		}
	}
}

void TransitionOccurrence::writeWriteTokens() throw (CapacityException) {
	Place* placeP;
	Token* oldTokenP;
	for (parameter_list_t::iterator it=tokens.begin(); it!=tokens.end(); ++it) {
		switch (it->scope) {
		case (TokenParameter::SCOPE_READ):
		case (TokenParameter::SCOPE_INPUT):
			continue;
		case (TokenParameter::SCOPE_WRITE):	
			// replace token if necessary
			placeP = it->edgeP->getPlace();
			oldTokenP = placeP->getNextUnlockedToken();
			if (it->tokenP != oldTokenP) {
				LOG_DEBUG(_logger, "writeWriteTokens[" << getID() << "] replacing token 'w" 
				<< oldTokenP->getID() << "' with token 'w" << it->tokenP->getID() << "' on place '" 
				<< it->edgeP->getPlace()->getID() << "'");
				placeP->removeToken(oldTokenP);
				placeP->addToken(it->tokenP);
			}
			break;
		case (TokenParameter::SCOPE_OUTPUT):
			return;
		}
	}
}

string TransitionOccurrence::getID() const {
	return _id;
}

void TransitionOccurrence::evaluateXPathEdgeExpressions(int step) {
	if (!hasXPathEdgeExpressions) return;
	LOG_DEBUG(_logger, "gwes::TransitionOccurrence::evaluateXPathEdgeExpressions[" << getID() << "] ...");
	XPathEvaluator* xpathEvaluatorP = new XPathEvaluator(this, step);

	for (parameter_list_t::iterator it=tokens.begin(); it!=tokens.end(); ++it) {
		switch (it->scope) {
		case (TokenParameter::SCOPE_READ):
			continue;
		case (TokenParameter::SCOPE_INPUT):
			continue;
		case (TokenParameter::SCOPE_WRITE):
		case (TokenParameter::SCOPE_OUTPUT):
			// generate output tokens or replace write tokens
			string edgeExpression = it->edgeP->getExpression(); 
			if (edgeExpression.find("$")!=edgeExpression.npos) {  // XPath expression
				string str = xpathEvaluatorP->evalExpression2Xml(edgeExpression);
				it->tokenP = new Token( new Data(str) );
			}
			break;
		}
	}
	
	delete xpathEvaluatorP;
}


} // end namespace gwes

ostream& operator<<(ostream &out, gwes::TransitionOccurrence &transitionOccurrence) 
{	
	out << "gwes::TransitionOccurrence[" << transitionOccurrence.transitionP->getID();
	for (gwes::parameter_list_t::iterator it=transitionOccurrence.tokens.begin(); it!=transitionOccurrence.tokens.end(); ++it) {
		switch (it->scope) {
		case (gwes::parameter_t::SCOPE_READ):
			out << ", read:";
			break;
		case (gwes::parameter_t::SCOPE_INPUT):
			out << ", input:";
			break;
		case (gwes::parameter_t::SCOPE_WRITE):	
			out << ", write:";
			break;
		case (gwes::parameter_t::SCOPE_OUTPUT):
			out << ", output:";
			break;
		}
		out << it->edgeP->getExpression();
		if (it->tokenP != NULL) out << "(" << it->tokenP->getID() << ")"; 
	}
	out << "]";
	
	return out;
}
