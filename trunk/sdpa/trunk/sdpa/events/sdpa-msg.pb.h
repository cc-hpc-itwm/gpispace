// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_sdpa_2dmsg_2eproto__INCLUDED
#define PROTOBUF_sdpa_2dmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace sdpa {
namespace events {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_sdpa_2dmsg_2eproto();
void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class SDPAMessage;
class Error;
class Task;
class FunctionCall;
class Activity;
class Token;
class Properties;
class Properties_Property;
class SubmitJob;
class SubmitJobAck;
class CancelJob;
class CancelJobAck;
class QueryStatus;
class StatusReply;
class RetrieveResults;
class Results;
class DeleteJob;
class DeleteJobAck;
class Poll;
class PollReply;
class JobFinished;
class JobFinishedAck;
class JobFailed;
class JobFailedAck;
class LifeSignal;
class ConfigRequest;
class ConfigReply;
class Config;

enum ErrorCode {
  OK = 0,
  NO_ACTIVITY = 500
};
const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = OK;
const ErrorCode ErrorCode_MAX = NO_ACTIVITY;

enum JobState {
  UNKNOWN = 0,
  PENDING = 1,
  RUNNING = 2,
  FINISHED = 3,
  FAILED = 4,
  CANCELLED = 5,
  CANCELLING = 6
};
const ::google::protobuf::EnumDescriptor* JobState_descriptor();
bool JobState_IsValid(int value);
const JobState JobState_MIN = UNKNOWN;
const JobState JobState_MAX = CANCELLING;

// ===================================================================

class SDPAMessage : public ::google::protobuf::Message {
 public:
  SDPAMessage();
  virtual ~SDPAMessage();
  
  SDPAMessage(const SDPAMessage& from);
  
  inline SDPAMessage& operator=(const SDPAMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SDPAMessage& default_instance();
  void Swap(SDPAMessage* other);
  
  // implements Message ----------------------------------------------
  
  SDPAMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SDPAMessage& from);
  void MergeFrom(const SDPAMessage& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .sdpa.events.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  inline const ::sdpa::events::Error& error() const;
  inline ::sdpa::events::Error* mutable_error();
  
  // optional .sdpa.events.SubmitJob submit_job = 2;
  inline bool has_submit_job() const;
  inline void clear_submit_job();
  inline const ::sdpa::events::SubmitJob& submit_job() const;
  inline ::sdpa::events::SubmitJob* mutable_submit_job();
  
  // optional .sdpa.events.SubmitJobAck submit_job_ack = 3;
  inline bool has_submit_job_ack() const;
  inline void clear_submit_job_ack();
  inline const ::sdpa::events::SubmitJobAck& submit_job_ack() const;
  inline ::sdpa::events::SubmitJobAck* mutable_submit_job_ack();
  
  // optional .sdpa.events.CancelJob cancel_job = 4;
  inline bool has_cancel_job() const;
  inline void clear_cancel_job();
  inline const ::sdpa::events::CancelJob& cancel_job() const;
  inline ::sdpa::events::CancelJob* mutable_cancel_job();
  
  // optional .sdpa.events.CancelJobAck cancel_job_ack = 5;
  inline bool has_cancel_job_ack() const;
  inline void clear_cancel_job_ack();
  inline const ::sdpa::events::CancelJobAck& cancel_job_ack() const;
  inline ::sdpa::events::CancelJobAck* mutable_cancel_job_ack();
  
  // optional .sdpa.events.QueryStatus query_status = 6;
  inline bool has_query_status() const;
  inline void clear_query_status();
  inline const ::sdpa::events::QueryStatus& query_status() const;
  inline ::sdpa::events::QueryStatus* mutable_query_status();
  
  // optional .sdpa.events.StatusReply status_reply = 7;
  inline bool has_status_reply() const;
  inline void clear_status_reply();
  inline const ::sdpa::events::StatusReply& status_reply() const;
  inline ::sdpa::events::StatusReply* mutable_status_reply();
  
  // optional .sdpa.events.RetrieveResults retrieve_results = 8;
  inline bool has_retrieve_results() const;
  inline void clear_retrieve_results();
  inline const ::sdpa::events::RetrieveResults& retrieve_results() const;
  inline ::sdpa::events::RetrieveResults* mutable_retrieve_results();
  
  // optional .sdpa.events.Results results = 9;
  inline bool has_results() const;
  inline void clear_results();
  inline const ::sdpa::events::Results& results() const;
  inline ::sdpa::events::Results* mutable_results();
  
  // optional .sdpa.events.DeleteJob delete_job = 10;
  inline bool has_delete_job() const;
  inline void clear_delete_job();
  inline const ::sdpa::events::DeleteJob& delete_job() const;
  inline ::sdpa::events::DeleteJob* mutable_delete_job();
  
  // optional .sdpa.events.DeleteJobAck delete_job_ack = 11;
  inline bool has_delete_job_ack() const;
  inline void clear_delete_job_ack();
  inline const ::sdpa::events::DeleteJobAck& delete_job_ack() const;
  inline ::sdpa::events::DeleteJobAck* mutable_delete_job_ack();
  
  // optional .sdpa.events.Poll poll = 12;
  inline bool has_poll() const;
  inline void clear_poll();
  inline const ::sdpa::events::Poll& poll() const;
  inline ::sdpa::events::Poll* mutable_poll();
  
  // optional .sdpa.events.PollReply poll_reply = 13;
  inline bool has_poll_reply() const;
  inline void clear_poll_reply();
  inline const ::sdpa::events::PollReply& poll_reply() const;
  inline ::sdpa::events::PollReply* mutable_poll_reply();
  
  // optional .sdpa.events.JobFinished job_finished = 14;
  inline bool has_job_finished() const;
  inline void clear_job_finished();
  inline const ::sdpa::events::JobFinished& job_finished() const;
  inline ::sdpa::events::JobFinished* mutable_job_finished();
  
  // optional .sdpa.events.JobFinishedAck job_finished_ack = 15;
  inline bool has_job_finished_ack() const;
  inline void clear_job_finished_ack();
  inline const ::sdpa::events::JobFinishedAck& job_finished_ack() const;
  inline ::sdpa::events::JobFinishedAck* mutable_job_finished_ack();
  
  // optional .sdpa.events.JobFailed job_failed = 16;
  inline bool has_job_failed() const;
  inline void clear_job_failed();
  inline const ::sdpa::events::JobFailed& job_failed() const;
  inline ::sdpa::events::JobFailed* mutable_job_failed();
  
  // optional .sdpa.events.JobFailedAck job_failed_ack = 17;
  inline bool has_job_failed_ack() const;
  inline void clear_job_failed_ack();
  inline const ::sdpa::events::JobFailedAck& job_failed_ack() const;
  inline ::sdpa::events::JobFailedAck* mutable_job_failed_ack();
  
  // optional .sdpa.events.LifeSignal life_signal = 18;
  inline bool has_life_signal() const;
  inline void clear_life_signal();
  inline const ::sdpa::events::LifeSignal& life_signal() const;
  inline ::sdpa::events::LifeSignal* mutable_life_signal();
  
  // optional .sdpa.events.ConfigRequest config_request = 19;
  inline bool has_config_request() const;
  inline void clear_config_request();
  inline const ::sdpa::events::ConfigRequest& config_request() const;
  inline ::sdpa::events::ConfigRequest* mutable_config_request();
  
  // optional .sdpa.events.ConfigReply config_reply = 20;
  inline bool has_config_reply() const;
  inline void clear_config_reply();
  inline const ::sdpa::events::ConfigReply& config_reply() const;
  inline ::sdpa::events::ConfigReply* mutable_config_reply();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::sdpa::events::Error* error_;
  ::sdpa::events::SubmitJob* submit_job_;
  ::sdpa::events::SubmitJobAck* submit_job_ack_;
  ::sdpa::events::CancelJob* cancel_job_;
  ::sdpa::events::CancelJobAck* cancel_job_ack_;
  ::sdpa::events::QueryStatus* query_status_;
  ::sdpa::events::StatusReply* status_reply_;
  ::sdpa::events::RetrieveResults* retrieve_results_;
  ::sdpa::events::Results* results_;
  ::sdpa::events::DeleteJob* delete_job_;
  ::sdpa::events::DeleteJobAck* delete_job_ack_;
  ::sdpa::events::Poll* poll_;
  ::sdpa::events::PollReply* poll_reply_;
  ::sdpa::events::JobFinished* job_finished_;
  ::sdpa::events::JobFinishedAck* job_finished_ack_;
  ::sdpa::events::JobFailed* job_failed_;
  ::sdpa::events::JobFailedAck* job_failed_ack_;
  ::sdpa::events::LifeSignal* life_signal_;
  ::sdpa::events::ConfigRequest* config_request_;
  ::sdpa::events::ConfigReply* config_reply_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SDPAMessage* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .sdpa.events.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  inline sdpa::events::ErrorCode error_code() const;
  inline void set_error_code(sdpa::events::ErrorCode value);
  
  // required string error_description = 2;
  inline bool has_error_description() const;
  inline void clear_error_description();
  inline const ::std::string& error_description() const;
  inline void set_error_description(const ::std::string& value);
  inline void set_error_description(const char* value);
  inline ::std::string* mutable_error_description();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  ::std::string* error_description_;
  static const ::std::string _default_error_description_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();
  
  Task(const Task& from);
  
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();
  void Swap(Task* other);
  
  // implements Message ----------------------------------------------
  
  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes workflow = 2;
  inline bool has_workflow() const;
  inline void clear_workflow();
  inline const ::std::string& workflow() const;
  inline void set_workflow(const ::std::string& value);
  inline void set_workflow(const char* value);
  inline void set_workflow(const void* value, size_t size);
  inline ::std::string* mutable_workflow();
  
  // repeated .sdpa.events.Token input = 3;
  inline int input_size() const;
  inline void clear_input();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >* mutable_input();
  inline const ::sdpa::events::Token& input(int index) const;
  inline ::sdpa::events::Token* mutable_input(int index);
  inline ::sdpa::events::Token* add_input();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* workflow_;
  static const ::std::string _default_workflow_;
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token > input_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class FunctionCall : public ::google::protobuf::Message {
 public:
  FunctionCall();
  virtual ~FunctionCall();
  
  FunctionCall(const FunctionCall& from);
  
  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionCall& default_instance();
  void Swap(FunctionCall* other);
  
  // implements Message ----------------------------------------------
  
  FunctionCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string module = 1;
  inline bool has_module() const;
  inline void clear_module();
  inline const ::std::string& module() const;
  inline void set_module(const ::std::string& value);
  inline void set_module(const char* value);
  inline ::std::string* mutable_module();
  
  // required string method = 2;
  inline bool has_method() const;
  inline void clear_method();
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline ::std::string* mutable_method();
  
  // repeated .sdpa.events.Token input = 3;
  inline int input_size() const;
  inline void clear_input();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >* mutable_input();
  inline const ::sdpa::events::Token& input(int index) const;
  inline ::sdpa::events::Token* mutable_input(int index);
  inline ::sdpa::events::Token* add_input();
  
  // repeated .sdpa.events.Token output = 4;
  inline int output_size() const;
  inline void clear_output();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >& output() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >* mutable_output();
  inline const ::sdpa::events::Token& output(int index) const;
  inline ::sdpa::events::Token* mutable_output(int index);
  inline ::sdpa::events::Token* add_output();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* module_;
  static const ::std::string _default_module_;
  ::std::string* method_;
  static const ::std::string _default_method_;
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token > input_;
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token > output_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FunctionCall* default_instance_;
};
// -------------------------------------------------------------------

class Activity : public ::google::protobuf::Message {
 public:
  Activity();
  virtual ~Activity();
  
  Activity(const Activity& from);
  
  inline Activity& operator=(const Activity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Activity& default_instance();
  void Swap(Activity* other);
  
  // implements Message ----------------------------------------------
  
  Activity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Activity& from);
  void MergeFrom(const Activity& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional .sdpa.events.Task task = 2;
  inline bool has_task() const;
  inline void clear_task();
  inline const ::sdpa::events::Task& task() const;
  inline ::sdpa::events::Task* mutable_task();
  
  // optional .sdpa.events.FunctionCall function = 3;
  inline bool has_function() const;
  inline void clear_function();
  inline const ::sdpa::events::FunctionCall& function() const;
  inline ::sdpa::events::FunctionCall* mutable_function();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::sdpa::events::Task* task_;
  ::sdpa::events::FunctionCall* function_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Activity* default_instance_;
};
// -------------------------------------------------------------------

class Token : public ::google::protobuf::Message {
 public:
  Token();
  virtual ~Token();
  
  Token(const Token& from);
  
  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();
  void Swap(Token* other);
  
  // implements Message ----------------------------------------------
  
  Token* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes place = 1;
  inline bool has_place() const;
  inline void clear_place();
  inline const ::std::string& place() const;
  inline void set_place(const ::std::string& value);
  inline void set_place(const char* value);
  inline void set_place(const void* value, size_t size);
  inline ::std::string* mutable_place();
  
  // required bytes token = 2;
  inline bool has_token() const;
  inline void clear_token();
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* place_;
  static const ::std::string _default_place_;
  ::std::string* token_;
  static const ::std::string _default_token_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Token* default_instance_;
};
// -------------------------------------------------------------------

class Properties_Property : public ::google::protobuf::Message {
 public:
  Properties_Property();
  virtual ~Properties_Property();
  
  Properties_Property(const Properties_Property& from);
  
  inline Properties_Property& operator=(const Properties_Property& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Properties_Property& default_instance();
  void Swap(Properties_Property* other);
  
  // implements Message ----------------------------------------------
  
  Properties_Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Properties_Property& from);
  void MergeFrom(const Properties_Property& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline ::std::string* mutable_key();
  
  // required string val = 2;
  inline bool has_val() const;
  inline void clear_val();
  inline const ::std::string& val() const;
  inline void set_val(const ::std::string& value);
  inline void set_val(const char* value);
  inline ::std::string* mutable_val();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* val_;
  static const ::std::string _default_val_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Properties_Property* default_instance_;
};
// -------------------------------------------------------------------

class Properties : public ::google::protobuf::Message {
 public:
  Properties();
  virtual ~Properties();
  
  Properties(const Properties& from);
  
  inline Properties& operator=(const Properties& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Properties& default_instance();
  void Swap(Properties* other);
  
  // implements Message ----------------------------------------------
  
  Properties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Properties& from);
  void MergeFrom(const Properties& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Properties_Property Property;
  
  // accessors -------------------------------------------------------
  
  // repeated .sdpa.events.Properties.Property property = 1;
  inline int property_size() const;
  inline void clear_property();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Properties_Property >& property() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Properties_Property >* mutable_property();
  inline const ::sdpa::events::Properties_Property& property(int index) const;
  inline ::sdpa::events::Properties_Property* mutable_property(int index);
  inline ::sdpa::events::Properties_Property* add_property();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Properties_Property > property_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Properties* default_instance_;
};
// -------------------------------------------------------------------

class SubmitJob : public ::google::protobuf::Message {
 public:
  SubmitJob();
  virtual ~SubmitJob();
  
  SubmitJob(const SubmitJob& from);
  
  inline SubmitJob& operator=(const SubmitJob& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitJob& default_instance();
  void Swap(SubmitJob* other);
  
  // implements Message ----------------------------------------------
  
  SubmitJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitJob& from);
  void MergeFrom(const SubmitJob& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes workflow = 1;
  inline bool has_workflow() const;
  inline void clear_workflow();
  inline const ::std::string& workflow() const;
  inline void set_workflow(const ::std::string& value);
  inline void set_workflow(const char* value);
  inline void set_workflow(const void* value, size_t size);
  inline ::std::string* mutable_workflow();
  
  // repeated .sdpa.events.Token input = 2;
  inline int input_size() const;
  inline void clear_input();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >* mutable_input();
  inline const ::sdpa::events::Token& input(int index) const;
  inline ::sdpa::events::Token* mutable_input(int index);
  inline ::sdpa::events::Token* add_input();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* workflow_;
  static const ::std::string _default_workflow_;
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token > input_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SubmitJob* default_instance_;
};
// -------------------------------------------------------------------

class SubmitJobAck : public ::google::protobuf::Message {
 public:
  SubmitJobAck();
  virtual ~SubmitJobAck();
  
  SubmitJobAck(const SubmitJobAck& from);
  
  inline SubmitJobAck& operator=(const SubmitJobAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitJobAck& default_instance();
  void Swap(SubmitJobAck* other);
  
  // implements Message ----------------------------------------------
  
  SubmitJobAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitJobAck& from);
  void MergeFrom(const SubmitJobAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SubmitJobAck* default_instance_;
};
// -------------------------------------------------------------------

class CancelJob : public ::google::protobuf::Message {
 public:
  CancelJob();
  virtual ~CancelJob();
  
  CancelJob(const CancelJob& from);
  
  inline CancelJob& operator=(const CancelJob& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelJob& default_instance();
  void Swap(CancelJob* other);
  
  // implements Message ----------------------------------------------
  
  CancelJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelJob& from);
  void MergeFrom(const CancelJob& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional string reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline ::std::string* mutable_reason();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CancelJob* default_instance_;
};
// -------------------------------------------------------------------

class CancelJobAck : public ::google::protobuf::Message {
 public:
  CancelJobAck();
  virtual ~CancelJobAck();
  
  CancelJobAck(const CancelJobAck& from);
  
  inline CancelJobAck& operator=(const CancelJobAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelJobAck& default_instance();
  void Swap(CancelJobAck* other);
  
  // implements Message ----------------------------------------------
  
  CancelJobAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelJobAck& from);
  void MergeFrom(const CancelJobAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CancelJobAck* default_instance_;
};
// -------------------------------------------------------------------

class QueryStatus : public ::google::protobuf::Message {
 public:
  QueryStatus();
  virtual ~QueryStatus();
  
  QueryStatus(const QueryStatus& from);
  
  inline QueryStatus& operator=(const QueryStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryStatus& default_instance();
  void Swap(QueryStatus* other);
  
  // implements Message ----------------------------------------------
  
  QueryStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryStatus& from);
  void MergeFrom(const QueryStatus& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static QueryStatus* default_instance_;
};
// -------------------------------------------------------------------

class StatusReply : public ::google::protobuf::Message {
 public:
  StatusReply();
  virtual ~StatusReply();
  
  StatusReply(const StatusReply& from);
  
  inline StatusReply& operator=(const StatusReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusReply& default_instance();
  void Swap(StatusReply* other);
  
  // implements Message ----------------------------------------------
  
  StatusReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusReply& from);
  void MergeFrom(const StatusReply& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // required .sdpa.events.JobState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  inline sdpa::events::JobState state() const;
  inline void set_state(sdpa::events::JobState value);
  
  // optional .sdpa.events.Properties properties = 3;
  inline bool has_properties() const;
  inline void clear_properties();
  inline const ::sdpa::events::Properties& properties() const;
  inline ::sdpa::events::Properties* mutable_properties();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  int state_;
  ::sdpa::events::Properties* properties_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StatusReply* default_instance_;
};
// -------------------------------------------------------------------

class RetrieveResults : public ::google::protobuf::Message {
 public:
  RetrieveResults();
  virtual ~RetrieveResults();
  
  RetrieveResults(const RetrieveResults& from);
  
  inline RetrieveResults& operator=(const RetrieveResults& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RetrieveResults& default_instance();
  void Swap(RetrieveResults* other);
  
  // implements Message ----------------------------------------------
  
  RetrieveResults* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetrieveResults& from);
  void MergeFrom(const RetrieveResults& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RetrieveResults* default_instance_;
};
// -------------------------------------------------------------------

class Results : public ::google::protobuf::Message {
 public:
  Results();
  virtual ~Results();
  
  Results(const Results& from);
  
  inline Results& operator=(const Results& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Results& default_instance();
  void Swap(Results* other);
  
  // implements Message ----------------------------------------------
  
  Results* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Results& from);
  void MergeFrom(const Results& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // required int32 exit_code = 2;
  inline bool has_exit_code() const;
  inline void clear_exit_code();
  inline ::google::protobuf::int32 exit_code() const;
  inline void set_exit_code(::google::protobuf::int32 value);
  
  // repeated .sdpa.events.Token output_token = 3;
  inline int output_token_size() const;
  inline void clear_output_token();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >& output_token() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >* mutable_output_token();
  inline const ::sdpa::events::Token& output_token(int index) const;
  inline ::sdpa::events::Token* mutable_output_token(int index);
  inline ::sdpa::events::Token* add_output_token();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::google::protobuf::int32 exit_code_;
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token > output_token_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Results* default_instance_;
};
// -------------------------------------------------------------------

class DeleteJob : public ::google::protobuf::Message {
 public:
  DeleteJob();
  virtual ~DeleteJob();
  
  DeleteJob(const DeleteJob& from);
  
  inline DeleteJob& operator=(const DeleteJob& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteJob& default_instance();
  void Swap(DeleteJob* other);
  
  // implements Message ----------------------------------------------
  
  DeleteJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteJob& from);
  void MergeFrom(const DeleteJob& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteJob* default_instance_;
};
// -------------------------------------------------------------------

class DeleteJobAck : public ::google::protobuf::Message {
 public:
  DeleteJobAck();
  virtual ~DeleteJobAck();
  
  DeleteJobAck(const DeleteJobAck& from);
  
  inline DeleteJobAck& operator=(const DeleteJobAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteJobAck& default_instance();
  void Swap(DeleteJobAck* other);
  
  // implements Message ----------------------------------------------
  
  DeleteJobAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteJobAck& from);
  void MergeFrom(const DeleteJobAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteJobAck* default_instance_;
};
// -------------------------------------------------------------------

class Poll : public ::google::protobuf::Message {
 public:
  Poll();
  virtual ~Poll();
  
  Poll(const Poll& from);
  
  inline Poll& operator=(const Poll& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Poll& default_instance();
  void Swap(Poll* other);
  
  // implements Message ----------------------------------------------
  
  Poll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Poll& from);
  void MergeFrom(const Poll& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 queue_length = 1;
  inline bool has_queue_length() const;
  inline void clear_queue_length();
  inline ::google::protobuf::int32 queue_length() const;
  inline void set_queue_length(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 queue_length_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Poll* default_instance_;
};
// -------------------------------------------------------------------

class PollReply : public ::google::protobuf::Message {
 public:
  PollReply();
  virtual ~PollReply();
  
  PollReply(const PollReply& from);
  
  inline PollReply& operator=(const PollReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PollReply& default_instance();
  void Swap(PollReply* other);
  
  // implements Message ----------------------------------------------
  
  PollReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PollReply& from);
  void MergeFrom(const PollReply& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .sdpa.events.Activity activity = 1;
  inline bool has_activity() const;
  inline void clear_activity();
  inline const ::sdpa::events::Activity& activity() const;
  inline ::sdpa::events::Activity* mutable_activity();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::sdpa::events::Activity* activity_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PollReply* default_instance_;
};
// -------------------------------------------------------------------

class JobFinished : public ::google::protobuf::Message {
 public:
  JobFinished();
  virtual ~JobFinished();
  
  JobFinished(const JobFinished& from);
  
  inline JobFinished& operator=(const JobFinished& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobFinished& default_instance();
  void Swap(JobFinished* other);
  
  // implements Message ----------------------------------------------
  
  JobFinished* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFinished& from);
  void MergeFrom(const JobFinished& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // repeated .sdpa.events.Token output = 2;
  inline int output_size() const;
  inline void clear_output();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >& output() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >* mutable_output();
  inline const ::sdpa::events::Token& output(int index) const;
  inline ::sdpa::events::Token* mutable_output(int index);
  inline ::sdpa::events::Token* add_output();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token > output_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static JobFinished* default_instance_;
};
// -------------------------------------------------------------------

class JobFinishedAck : public ::google::protobuf::Message {
 public:
  JobFinishedAck();
  virtual ~JobFinishedAck();
  
  JobFinishedAck(const JobFinishedAck& from);
  
  inline JobFinishedAck& operator=(const JobFinishedAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobFinishedAck& default_instance();
  void Swap(JobFinishedAck* other);
  
  // implements Message ----------------------------------------------
  
  JobFinishedAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFinishedAck& from);
  void MergeFrom(const JobFinishedAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static JobFinishedAck* default_instance_;
};
// -------------------------------------------------------------------

class JobFailed : public ::google::protobuf::Message {
 public:
  JobFailed();
  virtual ~JobFailed();
  
  JobFailed(const JobFailed& from);
  
  inline JobFailed& operator=(const JobFailed& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobFailed& default_instance();
  void Swap(JobFailed* other);
  
  // implements Message ----------------------------------------------
  
  JobFailed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFailed& from);
  void MergeFrom(const JobFailed& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static JobFailed* default_instance_;
};
// -------------------------------------------------------------------

class JobFailedAck : public ::google::protobuf::Message {
 public:
  JobFailedAck();
  virtual ~JobFailedAck();
  
  JobFailedAck(const JobFailedAck& from);
  
  inline JobFailedAck& operator=(const JobFailedAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobFailedAck& default_instance();
  void Swap(JobFailedAck* other);
  
  // implements Message ----------------------------------------------
  
  JobFailedAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFailedAck& from);
  void MergeFrom(const JobFailedAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static JobFailedAck* default_instance_;
};
// -------------------------------------------------------------------

class LifeSignal : public ::google::protobuf::Message {
 public:
  LifeSignal();
  virtual ~LifeSignal();
  
  LifeSignal(const LifeSignal& from);
  
  inline LifeSignal& operator=(const LifeSignal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LifeSignal& default_instance();
  void Swap(LifeSignal* other);
  
  // implements Message ----------------------------------------------
  
  LifeSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LifeSignal& from);
  void MergeFrom(const LifeSignal& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // required bytes component_id = 2;
  inline bool has_component_id() const;
  inline void clear_component_id();
  inline const ::std::string& component_id() const;
  inline void set_component_id(const ::std::string& value);
  inline void set_component_id(const char* value);
  inline void set_component_id(const void* value, size_t size);
  inline ::std::string* mutable_component_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 timestamp_;
  ::std::string* component_id_;
  static const ::std::string _default_component_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LifeSignal* default_instance_;
};
// -------------------------------------------------------------------

class ConfigRequest : public ::google::protobuf::Message {
 public:
  ConfigRequest();
  virtual ~ConfigRequest();
  
  ConfigRequest(const ConfigRequest& from);
  
  inline ConfigRequest& operator=(const ConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigRequest& default_instance();
  void Swap(ConfigRequest* other);
  
  // implements Message ----------------------------------------------
  
  ConfigRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigRequest& from);
  void MergeFrom(const ConfigRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes component_id = 1;
  inline bool has_component_id() const;
  inline void clear_component_id();
  inline const ::std::string& component_id() const;
  inline void set_component_id(const ::std::string& value);
  inline void set_component_id(const char* value);
  inline void set_component_id(const void* value, size_t size);
  inline ::std::string* mutable_component_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* component_id_;
  static const ::std::string _default_component_id_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ConfigRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConfigReply : public ::google::protobuf::Message {
 public:
  ConfigReply();
  virtual ~ConfigReply();
  
  ConfigReply(const ConfigReply& from);
  
  inline ConfigReply& operator=(const ConfigReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigReply& default_instance();
  void Swap(ConfigReply* other);
  
  // implements Message ----------------------------------------------
  
  ConfigReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigReply& from);
  void MergeFrom(const ConfigReply& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes component_id = 1;
  inline bool has_component_id() const;
  inline void clear_component_id();
  inline const ::std::string& component_id() const;
  inline void set_component_id(const ::std::string& value);
  inline void set_component_id(const char* value);
  inline void set_component_id(const void* value, size_t size);
  inline ::std::string* mutable_component_id();
  
  // required .sdpa.events.Config config = 2;
  inline bool has_config() const;
  inline void clear_config();
  inline const ::sdpa::events::Config& config() const;
  inline ::sdpa::events::Config* mutable_config();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* component_id_;
  static const ::std::string _default_component_id_;
  ::sdpa::events::Config* config_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ConfigReply* default_instance_;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();
  
  Config(const Config& from);
  
  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();
  void Swap(Config* other);
  
  // implements Message ----------------------------------------------
  
  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .sdpa.events.Properties properties = 2;
  inline bool has_properties() const;
  inline void clear_properties();
  inline const ::sdpa::events::Properties& properties() const;
  inline ::sdpa::events::Properties* mutable_properties();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::sdpa::events::Properties* properties_;
  friend void protobuf_BuildDesc_sdpa_2dmsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// SDPAMessage

// optional .sdpa.events.Error error = 1;
inline bool SDPAMessage::has_error() const {
  return _has_bit(0);
}
inline void SDPAMessage::clear_error() {
  if (error_ != NULL) error_->::sdpa::events::Error::Clear();
  _clear_bit(0);
}
inline const ::sdpa::events::Error& SDPAMessage::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::sdpa::events::Error* SDPAMessage::mutable_error() {
  _set_bit(0);
  if (error_ == NULL) error_ = new ::sdpa::events::Error;
  return error_;
}

// optional .sdpa.events.SubmitJob submit_job = 2;
inline bool SDPAMessage::has_submit_job() const {
  return _has_bit(1);
}
inline void SDPAMessage::clear_submit_job() {
  if (submit_job_ != NULL) submit_job_->::sdpa::events::SubmitJob::Clear();
  _clear_bit(1);
}
inline const ::sdpa::events::SubmitJob& SDPAMessage::submit_job() const {
  return submit_job_ != NULL ? *submit_job_ : *default_instance_->submit_job_;
}
inline ::sdpa::events::SubmitJob* SDPAMessage::mutable_submit_job() {
  _set_bit(1);
  if (submit_job_ == NULL) submit_job_ = new ::sdpa::events::SubmitJob;
  return submit_job_;
}

// optional .sdpa.events.SubmitJobAck submit_job_ack = 3;
inline bool SDPAMessage::has_submit_job_ack() const {
  return _has_bit(2);
}
inline void SDPAMessage::clear_submit_job_ack() {
  if (submit_job_ack_ != NULL) submit_job_ack_->::sdpa::events::SubmitJobAck::Clear();
  _clear_bit(2);
}
inline const ::sdpa::events::SubmitJobAck& SDPAMessage::submit_job_ack() const {
  return submit_job_ack_ != NULL ? *submit_job_ack_ : *default_instance_->submit_job_ack_;
}
inline ::sdpa::events::SubmitJobAck* SDPAMessage::mutable_submit_job_ack() {
  _set_bit(2);
  if (submit_job_ack_ == NULL) submit_job_ack_ = new ::sdpa::events::SubmitJobAck;
  return submit_job_ack_;
}

// optional .sdpa.events.CancelJob cancel_job = 4;
inline bool SDPAMessage::has_cancel_job() const {
  return _has_bit(3);
}
inline void SDPAMessage::clear_cancel_job() {
  if (cancel_job_ != NULL) cancel_job_->::sdpa::events::CancelJob::Clear();
  _clear_bit(3);
}
inline const ::sdpa::events::CancelJob& SDPAMessage::cancel_job() const {
  return cancel_job_ != NULL ? *cancel_job_ : *default_instance_->cancel_job_;
}
inline ::sdpa::events::CancelJob* SDPAMessage::mutable_cancel_job() {
  _set_bit(3);
  if (cancel_job_ == NULL) cancel_job_ = new ::sdpa::events::CancelJob;
  return cancel_job_;
}

// optional .sdpa.events.CancelJobAck cancel_job_ack = 5;
inline bool SDPAMessage::has_cancel_job_ack() const {
  return _has_bit(4);
}
inline void SDPAMessage::clear_cancel_job_ack() {
  if (cancel_job_ack_ != NULL) cancel_job_ack_->::sdpa::events::CancelJobAck::Clear();
  _clear_bit(4);
}
inline const ::sdpa::events::CancelJobAck& SDPAMessage::cancel_job_ack() const {
  return cancel_job_ack_ != NULL ? *cancel_job_ack_ : *default_instance_->cancel_job_ack_;
}
inline ::sdpa::events::CancelJobAck* SDPAMessage::mutable_cancel_job_ack() {
  _set_bit(4);
  if (cancel_job_ack_ == NULL) cancel_job_ack_ = new ::sdpa::events::CancelJobAck;
  return cancel_job_ack_;
}

// optional .sdpa.events.QueryStatus query_status = 6;
inline bool SDPAMessage::has_query_status() const {
  return _has_bit(5);
}
inline void SDPAMessage::clear_query_status() {
  if (query_status_ != NULL) query_status_->::sdpa::events::QueryStatus::Clear();
  _clear_bit(5);
}
inline const ::sdpa::events::QueryStatus& SDPAMessage::query_status() const {
  return query_status_ != NULL ? *query_status_ : *default_instance_->query_status_;
}
inline ::sdpa::events::QueryStatus* SDPAMessage::mutable_query_status() {
  _set_bit(5);
  if (query_status_ == NULL) query_status_ = new ::sdpa::events::QueryStatus;
  return query_status_;
}

// optional .sdpa.events.StatusReply status_reply = 7;
inline bool SDPAMessage::has_status_reply() const {
  return _has_bit(6);
}
inline void SDPAMessage::clear_status_reply() {
  if (status_reply_ != NULL) status_reply_->::sdpa::events::StatusReply::Clear();
  _clear_bit(6);
}
inline const ::sdpa::events::StatusReply& SDPAMessage::status_reply() const {
  return status_reply_ != NULL ? *status_reply_ : *default_instance_->status_reply_;
}
inline ::sdpa::events::StatusReply* SDPAMessage::mutable_status_reply() {
  _set_bit(6);
  if (status_reply_ == NULL) status_reply_ = new ::sdpa::events::StatusReply;
  return status_reply_;
}

// optional .sdpa.events.RetrieveResults retrieve_results = 8;
inline bool SDPAMessage::has_retrieve_results() const {
  return _has_bit(7);
}
inline void SDPAMessage::clear_retrieve_results() {
  if (retrieve_results_ != NULL) retrieve_results_->::sdpa::events::RetrieveResults::Clear();
  _clear_bit(7);
}
inline const ::sdpa::events::RetrieveResults& SDPAMessage::retrieve_results() const {
  return retrieve_results_ != NULL ? *retrieve_results_ : *default_instance_->retrieve_results_;
}
inline ::sdpa::events::RetrieveResults* SDPAMessage::mutable_retrieve_results() {
  _set_bit(7);
  if (retrieve_results_ == NULL) retrieve_results_ = new ::sdpa::events::RetrieveResults;
  return retrieve_results_;
}

// optional .sdpa.events.Results results = 9;
inline bool SDPAMessage::has_results() const {
  return _has_bit(8);
}
inline void SDPAMessage::clear_results() {
  if (results_ != NULL) results_->::sdpa::events::Results::Clear();
  _clear_bit(8);
}
inline const ::sdpa::events::Results& SDPAMessage::results() const {
  return results_ != NULL ? *results_ : *default_instance_->results_;
}
inline ::sdpa::events::Results* SDPAMessage::mutable_results() {
  _set_bit(8);
  if (results_ == NULL) results_ = new ::sdpa::events::Results;
  return results_;
}

// optional .sdpa.events.DeleteJob delete_job = 10;
inline bool SDPAMessage::has_delete_job() const {
  return _has_bit(9);
}
inline void SDPAMessage::clear_delete_job() {
  if (delete_job_ != NULL) delete_job_->::sdpa::events::DeleteJob::Clear();
  _clear_bit(9);
}
inline const ::sdpa::events::DeleteJob& SDPAMessage::delete_job() const {
  return delete_job_ != NULL ? *delete_job_ : *default_instance_->delete_job_;
}
inline ::sdpa::events::DeleteJob* SDPAMessage::mutable_delete_job() {
  _set_bit(9);
  if (delete_job_ == NULL) delete_job_ = new ::sdpa::events::DeleteJob;
  return delete_job_;
}

// optional .sdpa.events.DeleteJobAck delete_job_ack = 11;
inline bool SDPAMessage::has_delete_job_ack() const {
  return _has_bit(10);
}
inline void SDPAMessage::clear_delete_job_ack() {
  if (delete_job_ack_ != NULL) delete_job_ack_->::sdpa::events::DeleteJobAck::Clear();
  _clear_bit(10);
}
inline const ::sdpa::events::DeleteJobAck& SDPAMessage::delete_job_ack() const {
  return delete_job_ack_ != NULL ? *delete_job_ack_ : *default_instance_->delete_job_ack_;
}
inline ::sdpa::events::DeleteJobAck* SDPAMessage::mutable_delete_job_ack() {
  _set_bit(10);
  if (delete_job_ack_ == NULL) delete_job_ack_ = new ::sdpa::events::DeleteJobAck;
  return delete_job_ack_;
}

// optional .sdpa.events.Poll poll = 12;
inline bool SDPAMessage::has_poll() const {
  return _has_bit(11);
}
inline void SDPAMessage::clear_poll() {
  if (poll_ != NULL) poll_->::sdpa::events::Poll::Clear();
  _clear_bit(11);
}
inline const ::sdpa::events::Poll& SDPAMessage::poll() const {
  return poll_ != NULL ? *poll_ : *default_instance_->poll_;
}
inline ::sdpa::events::Poll* SDPAMessage::mutable_poll() {
  _set_bit(11);
  if (poll_ == NULL) poll_ = new ::sdpa::events::Poll;
  return poll_;
}

// optional .sdpa.events.PollReply poll_reply = 13;
inline bool SDPAMessage::has_poll_reply() const {
  return _has_bit(12);
}
inline void SDPAMessage::clear_poll_reply() {
  if (poll_reply_ != NULL) poll_reply_->::sdpa::events::PollReply::Clear();
  _clear_bit(12);
}
inline const ::sdpa::events::PollReply& SDPAMessage::poll_reply() const {
  return poll_reply_ != NULL ? *poll_reply_ : *default_instance_->poll_reply_;
}
inline ::sdpa::events::PollReply* SDPAMessage::mutable_poll_reply() {
  _set_bit(12);
  if (poll_reply_ == NULL) poll_reply_ = new ::sdpa::events::PollReply;
  return poll_reply_;
}

// optional .sdpa.events.JobFinished job_finished = 14;
inline bool SDPAMessage::has_job_finished() const {
  return _has_bit(13);
}
inline void SDPAMessage::clear_job_finished() {
  if (job_finished_ != NULL) job_finished_->::sdpa::events::JobFinished::Clear();
  _clear_bit(13);
}
inline const ::sdpa::events::JobFinished& SDPAMessage::job_finished() const {
  return job_finished_ != NULL ? *job_finished_ : *default_instance_->job_finished_;
}
inline ::sdpa::events::JobFinished* SDPAMessage::mutable_job_finished() {
  _set_bit(13);
  if (job_finished_ == NULL) job_finished_ = new ::sdpa::events::JobFinished;
  return job_finished_;
}

// optional .sdpa.events.JobFinishedAck job_finished_ack = 15;
inline bool SDPAMessage::has_job_finished_ack() const {
  return _has_bit(14);
}
inline void SDPAMessage::clear_job_finished_ack() {
  if (job_finished_ack_ != NULL) job_finished_ack_->::sdpa::events::JobFinishedAck::Clear();
  _clear_bit(14);
}
inline const ::sdpa::events::JobFinishedAck& SDPAMessage::job_finished_ack() const {
  return job_finished_ack_ != NULL ? *job_finished_ack_ : *default_instance_->job_finished_ack_;
}
inline ::sdpa::events::JobFinishedAck* SDPAMessage::mutable_job_finished_ack() {
  _set_bit(14);
  if (job_finished_ack_ == NULL) job_finished_ack_ = new ::sdpa::events::JobFinishedAck;
  return job_finished_ack_;
}

// optional .sdpa.events.JobFailed job_failed = 16;
inline bool SDPAMessage::has_job_failed() const {
  return _has_bit(15);
}
inline void SDPAMessage::clear_job_failed() {
  if (job_failed_ != NULL) job_failed_->::sdpa::events::JobFailed::Clear();
  _clear_bit(15);
}
inline const ::sdpa::events::JobFailed& SDPAMessage::job_failed() const {
  return job_failed_ != NULL ? *job_failed_ : *default_instance_->job_failed_;
}
inline ::sdpa::events::JobFailed* SDPAMessage::mutable_job_failed() {
  _set_bit(15);
  if (job_failed_ == NULL) job_failed_ = new ::sdpa::events::JobFailed;
  return job_failed_;
}

// optional .sdpa.events.JobFailedAck job_failed_ack = 17;
inline bool SDPAMessage::has_job_failed_ack() const {
  return _has_bit(16);
}
inline void SDPAMessage::clear_job_failed_ack() {
  if (job_failed_ack_ != NULL) job_failed_ack_->::sdpa::events::JobFailedAck::Clear();
  _clear_bit(16);
}
inline const ::sdpa::events::JobFailedAck& SDPAMessage::job_failed_ack() const {
  return job_failed_ack_ != NULL ? *job_failed_ack_ : *default_instance_->job_failed_ack_;
}
inline ::sdpa::events::JobFailedAck* SDPAMessage::mutable_job_failed_ack() {
  _set_bit(16);
  if (job_failed_ack_ == NULL) job_failed_ack_ = new ::sdpa::events::JobFailedAck;
  return job_failed_ack_;
}

// optional .sdpa.events.LifeSignal life_signal = 18;
inline bool SDPAMessage::has_life_signal() const {
  return _has_bit(17);
}
inline void SDPAMessage::clear_life_signal() {
  if (life_signal_ != NULL) life_signal_->::sdpa::events::LifeSignal::Clear();
  _clear_bit(17);
}
inline const ::sdpa::events::LifeSignal& SDPAMessage::life_signal() const {
  return life_signal_ != NULL ? *life_signal_ : *default_instance_->life_signal_;
}
inline ::sdpa::events::LifeSignal* SDPAMessage::mutable_life_signal() {
  _set_bit(17);
  if (life_signal_ == NULL) life_signal_ = new ::sdpa::events::LifeSignal;
  return life_signal_;
}

// optional .sdpa.events.ConfigRequest config_request = 19;
inline bool SDPAMessage::has_config_request() const {
  return _has_bit(18);
}
inline void SDPAMessage::clear_config_request() {
  if (config_request_ != NULL) config_request_->::sdpa::events::ConfigRequest::Clear();
  _clear_bit(18);
}
inline const ::sdpa::events::ConfigRequest& SDPAMessage::config_request() const {
  return config_request_ != NULL ? *config_request_ : *default_instance_->config_request_;
}
inline ::sdpa::events::ConfigRequest* SDPAMessage::mutable_config_request() {
  _set_bit(18);
  if (config_request_ == NULL) config_request_ = new ::sdpa::events::ConfigRequest;
  return config_request_;
}

// optional .sdpa.events.ConfigReply config_reply = 20;
inline bool SDPAMessage::has_config_reply() const {
  return _has_bit(19);
}
inline void SDPAMessage::clear_config_reply() {
  if (config_reply_ != NULL) config_reply_->::sdpa::events::ConfigReply::Clear();
  _clear_bit(19);
}
inline const ::sdpa::events::ConfigReply& SDPAMessage::config_reply() const {
  return config_reply_ != NULL ? *config_reply_ : *default_instance_->config_reply_;
}
inline ::sdpa::events::ConfigReply* SDPAMessage::mutable_config_reply() {
  _set_bit(19);
  if (config_reply_ == NULL) config_reply_ = new ::sdpa::events::ConfigReply;
  return config_reply_;
}

// -------------------------------------------------------------------

// Error

// required .sdpa.events.ErrorCode error_code = 1;
inline bool Error::has_error_code() const {
  return _has_bit(0);
}
inline void Error::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline sdpa::events::ErrorCode Error::error_code() const {
  return static_cast< sdpa::events::ErrorCode >(error_code_);
}
inline void Error::set_error_code(sdpa::events::ErrorCode value) {
  GOOGLE_DCHECK(sdpa::events::ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// required string error_description = 2;
inline bool Error::has_error_description() const {
  return _has_bit(1);
}
inline void Error::clear_error_description() {
  if (error_description_ != &_default_error_description_) {
    error_description_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Error::error_description() const {
  return *error_description_;
}
inline void Error::set_error_description(const ::std::string& value) {
  _set_bit(1);
  if (error_description_ == &_default_error_description_) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void Error::set_error_description(const char* value) {
  _set_bit(1);
  if (error_description_ == &_default_error_description_) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline ::std::string* Error::mutable_error_description() {
  _set_bit(1);
  if (error_description_ == &_default_error_description_) {
    error_description_ = new ::std::string;
  }
  return error_description_;
}

// -------------------------------------------------------------------

// Task

// required bytes workflow = 2;
inline bool Task::has_workflow() const {
  return _has_bit(0);
}
inline void Task::clear_workflow() {
  if (workflow_ != &_default_workflow_) {
    workflow_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Task::workflow() const {
  return *workflow_;
}
inline void Task::set_workflow(const ::std::string& value) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(value);
}
inline void Task::set_workflow(const char* value) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(value);
}
inline void Task::set_workflow(const void* value, size_t size) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_workflow() {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  return workflow_;
}

// repeated .sdpa.events.Token input = 3;
inline int Task::input_size() const {
  return input_.size();
}
inline void Task::clear_input() {
  input_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >&
Task::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >*
Task::mutable_input() {
  return &input_;
}
inline const ::sdpa::events::Token& Task::input(int index) const {
  return input_.Get(index);
}
inline ::sdpa::events::Token* Task::mutable_input(int index) {
  return input_.Mutable(index);
}
inline ::sdpa::events::Token* Task::add_input() {
  return input_.Add();
}

// -------------------------------------------------------------------

// FunctionCall

// required string module = 1;
inline bool FunctionCall::has_module() const {
  return _has_bit(0);
}
inline void FunctionCall::clear_module() {
  if (module_ != &_default_module_) {
    module_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FunctionCall::module() const {
  return *module_;
}
inline void FunctionCall::set_module(const ::std::string& value) {
  _set_bit(0);
  if (module_ == &_default_module_) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline void FunctionCall::set_module(const char* value) {
  _set_bit(0);
  if (module_ == &_default_module_) {
    module_ = new ::std::string;
  }
  module_->assign(value);
}
inline ::std::string* FunctionCall::mutable_module() {
  _set_bit(0);
  if (module_ == &_default_module_) {
    module_ = new ::std::string;
  }
  return module_;
}

// required string method = 2;
inline bool FunctionCall::has_method() const {
  return _has_bit(1);
}
inline void FunctionCall::clear_method() {
  if (method_ != &_default_method_) {
    method_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& FunctionCall::method() const {
  return *method_;
}
inline void FunctionCall::set_method(const ::std::string& value) {
  _set_bit(1);
  if (method_ == &_default_method_) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void FunctionCall::set_method(const char* value) {
  _set_bit(1);
  if (method_ == &_default_method_) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline ::std::string* FunctionCall::mutable_method() {
  _set_bit(1);
  if (method_ == &_default_method_) {
    method_ = new ::std::string;
  }
  return method_;
}

// repeated .sdpa.events.Token input = 3;
inline int FunctionCall::input_size() const {
  return input_.size();
}
inline void FunctionCall::clear_input() {
  input_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >&
FunctionCall::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >*
FunctionCall::mutable_input() {
  return &input_;
}
inline const ::sdpa::events::Token& FunctionCall::input(int index) const {
  return input_.Get(index);
}
inline ::sdpa::events::Token* FunctionCall::mutable_input(int index) {
  return input_.Mutable(index);
}
inline ::sdpa::events::Token* FunctionCall::add_input() {
  return input_.Add();
}

// repeated .sdpa.events.Token output = 4;
inline int FunctionCall::output_size() const {
  return output_.size();
}
inline void FunctionCall::clear_output() {
  output_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >&
FunctionCall::output() const {
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >*
FunctionCall::mutable_output() {
  return &output_;
}
inline const ::sdpa::events::Token& FunctionCall::output(int index) const {
  return output_.Get(index);
}
inline ::sdpa::events::Token* FunctionCall::mutable_output(int index) {
  return output_.Mutable(index);
}
inline ::sdpa::events::Token* FunctionCall::add_output() {
  return output_.Add();
}

// -------------------------------------------------------------------

// Activity

// required bytes id = 1;
inline bool Activity::has_id() const {
  return _has_bit(0);
}
inline void Activity::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Activity::id() const {
  return *id_;
}
inline void Activity::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Activity::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Activity::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Activity::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional .sdpa.events.Task task = 2;
inline bool Activity::has_task() const {
  return _has_bit(1);
}
inline void Activity::clear_task() {
  if (task_ != NULL) task_->::sdpa::events::Task::Clear();
  _clear_bit(1);
}
inline const ::sdpa::events::Task& Activity::task() const {
  return task_ != NULL ? *task_ : *default_instance_->task_;
}
inline ::sdpa::events::Task* Activity::mutable_task() {
  _set_bit(1);
  if (task_ == NULL) task_ = new ::sdpa::events::Task;
  return task_;
}

// optional .sdpa.events.FunctionCall function = 3;
inline bool Activity::has_function() const {
  return _has_bit(2);
}
inline void Activity::clear_function() {
  if (function_ != NULL) function_->::sdpa::events::FunctionCall::Clear();
  _clear_bit(2);
}
inline const ::sdpa::events::FunctionCall& Activity::function() const {
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::sdpa::events::FunctionCall* Activity::mutable_function() {
  _set_bit(2);
  if (function_ == NULL) function_ = new ::sdpa::events::FunctionCall;
  return function_;
}

// -------------------------------------------------------------------

// Token

// required bytes place = 1;
inline bool Token::has_place() const {
  return _has_bit(0);
}
inline void Token::clear_place() {
  if (place_ != &_default_place_) {
    place_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Token::place() const {
  return *place_;
}
inline void Token::set_place(const ::std::string& value) {
  _set_bit(0);
  if (place_ == &_default_place_) {
    place_ = new ::std::string;
  }
  place_->assign(value);
}
inline void Token::set_place(const char* value) {
  _set_bit(0);
  if (place_ == &_default_place_) {
    place_ = new ::std::string;
  }
  place_->assign(value);
}
inline void Token::set_place(const void* value, size_t size) {
  _set_bit(0);
  if (place_ == &_default_place_) {
    place_ = new ::std::string;
  }
  place_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_place() {
  _set_bit(0);
  if (place_ == &_default_place_) {
    place_ = new ::std::string;
  }
  return place_;
}

// required bytes token = 2;
inline bool Token::has_token() const {
  return _has_bit(1);
}
inline void Token::clear_token() {
  if (token_ != &_default_token_) {
    token_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Token::token() const {
  return *token_;
}
inline void Token::set_token(const ::std::string& value) {
  _set_bit(1);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Token::set_token(const char* value) {
  _set_bit(1);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Token::set_token(const void* value, size_t size) {
  _set_bit(1);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_token() {
  _set_bit(1);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  return token_;
}

// -------------------------------------------------------------------

// Properties_Property

// required string key = 1;
inline bool Properties_Property::has_key() const {
  return _has_bit(0);
}
inline void Properties_Property::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Properties_Property::key() const {
  return *key_;
}
inline void Properties_Property::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Properties_Property::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline ::std::string* Properties_Property::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required string val = 2;
inline bool Properties_Property::has_val() const {
  return _has_bit(1);
}
inline void Properties_Property::clear_val() {
  if (val_ != &_default_val_) {
    val_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Properties_Property::val() const {
  return *val_;
}
inline void Properties_Property::set_val(const ::std::string& value) {
  _set_bit(1);
  if (val_ == &_default_val_) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline void Properties_Property::set_val(const char* value) {
  _set_bit(1);
  if (val_ == &_default_val_) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline ::std::string* Properties_Property::mutable_val() {
  _set_bit(1);
  if (val_ == &_default_val_) {
    val_ = new ::std::string;
  }
  return val_;
}

// -------------------------------------------------------------------

// Properties

// repeated .sdpa.events.Properties.Property property = 1;
inline int Properties::property_size() const {
  return property_.size();
}
inline void Properties::clear_property() {
  property_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Properties_Property >&
Properties::property() const {
  return property_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Properties_Property >*
Properties::mutable_property() {
  return &property_;
}
inline const ::sdpa::events::Properties_Property& Properties::property(int index) const {
  return property_.Get(index);
}
inline ::sdpa::events::Properties_Property* Properties::mutable_property(int index) {
  return property_.Mutable(index);
}
inline ::sdpa::events::Properties_Property* Properties::add_property() {
  return property_.Add();
}

// -------------------------------------------------------------------

// SubmitJob

// required bytes workflow = 1;
inline bool SubmitJob::has_workflow() const {
  return _has_bit(0);
}
inline void SubmitJob::clear_workflow() {
  if (workflow_ != &_default_workflow_) {
    workflow_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SubmitJob::workflow() const {
  return *workflow_;
}
inline void SubmitJob::set_workflow(const ::std::string& value) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(value);
}
inline void SubmitJob::set_workflow(const char* value) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(value);
}
inline void SubmitJob::set_workflow(const void* value, size_t size) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubmitJob::mutable_workflow() {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  return workflow_;
}

// repeated .sdpa.events.Token input = 2;
inline int SubmitJob::input_size() const {
  return input_.size();
}
inline void SubmitJob::clear_input() {
  input_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >&
SubmitJob::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >*
SubmitJob::mutable_input() {
  return &input_;
}
inline const ::sdpa::events::Token& SubmitJob::input(int index) const {
  return input_.Get(index);
}
inline ::sdpa::events::Token* SubmitJob::mutable_input(int index) {
  return input_.Mutable(index);
}
inline ::sdpa::events::Token* SubmitJob::add_input() {
  return input_.Add();
}

// -------------------------------------------------------------------

// SubmitJobAck

// required bytes id = 1;
inline bool SubmitJobAck::has_id() const {
  return _has_bit(0);
}
inline void SubmitJobAck::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SubmitJobAck::id() const {
  return *id_;
}
inline void SubmitJobAck::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SubmitJobAck::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SubmitJobAck::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubmitJobAck::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// CancelJob

// required bytes id = 1;
inline bool CancelJob::has_id() const {
  return _has_bit(0);
}
inline void CancelJob::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CancelJob::id() const {
  return *id_;
}
inline void CancelJob::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CancelJob::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CancelJob::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelJob::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional string reason = 2;
inline bool CancelJob::has_reason() const {
  return _has_bit(1);
}
inline void CancelJob::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CancelJob::reason() const {
  return *reason_;
}
inline void CancelJob::set_reason(const ::std::string& value) {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void CancelJob::set_reason(const char* value) {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline ::std::string* CancelJob::mutable_reason() {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// -------------------------------------------------------------------

// CancelJobAck

// required bytes id = 1;
inline bool CancelJobAck::has_id() const {
  return _has_bit(0);
}
inline void CancelJobAck::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CancelJobAck::id() const {
  return *id_;
}
inline void CancelJobAck::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CancelJobAck::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CancelJobAck::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelJobAck::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// QueryStatus

// required bytes id = 1;
inline bool QueryStatus::has_id() const {
  return _has_bit(0);
}
inline void QueryStatus::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& QueryStatus::id() const {
  return *id_;
}
inline void QueryStatus::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QueryStatus::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QueryStatus::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryStatus::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// StatusReply

// required bytes id = 1;
inline bool StatusReply::has_id() const {
  return _has_bit(0);
}
inline void StatusReply::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StatusReply::id() const {
  return *id_;
}
inline void StatusReply::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StatusReply::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void StatusReply::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusReply::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required .sdpa.events.JobState state = 2;
inline bool StatusReply::has_state() const {
  return _has_bit(1);
}
inline void StatusReply::clear_state() {
  state_ = 0;
  _clear_bit(1);
}
inline sdpa::events::JobState StatusReply::state() const {
  return static_cast< sdpa::events::JobState >(state_);
}
inline void StatusReply::set_state(sdpa::events::JobState value) {
  GOOGLE_DCHECK(sdpa::events::JobState_IsValid(value));
  _set_bit(1);
  state_ = value;
}

// optional .sdpa.events.Properties properties = 3;
inline bool StatusReply::has_properties() const {
  return _has_bit(2);
}
inline void StatusReply::clear_properties() {
  if (properties_ != NULL) properties_->::sdpa::events::Properties::Clear();
  _clear_bit(2);
}
inline const ::sdpa::events::Properties& StatusReply::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::sdpa::events::Properties* StatusReply::mutable_properties() {
  _set_bit(2);
  if (properties_ == NULL) properties_ = new ::sdpa::events::Properties;
  return properties_;
}

// -------------------------------------------------------------------

// RetrieveResults

// required bytes id = 1;
inline bool RetrieveResults::has_id() const {
  return _has_bit(0);
}
inline void RetrieveResults::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RetrieveResults::id() const {
  return *id_;
}
inline void RetrieveResults::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RetrieveResults::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RetrieveResults::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetrieveResults::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// Results

// required bytes id = 1;
inline bool Results::has_id() const {
  return _has_bit(0);
}
inline void Results::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Results::id() const {
  return *id_;
}
inline void Results::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Results::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Results::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Results::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required int32 exit_code = 2;
inline bool Results::has_exit_code() const {
  return _has_bit(1);
}
inline void Results::clear_exit_code() {
  exit_code_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Results::exit_code() const {
  return exit_code_;
}
inline void Results::set_exit_code(::google::protobuf::int32 value) {
  _set_bit(1);
  exit_code_ = value;
}

// repeated .sdpa.events.Token output_token = 3;
inline int Results::output_token_size() const {
  return output_token_.size();
}
inline void Results::clear_output_token() {
  output_token_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >&
Results::output_token() const {
  return output_token_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >*
Results::mutable_output_token() {
  return &output_token_;
}
inline const ::sdpa::events::Token& Results::output_token(int index) const {
  return output_token_.Get(index);
}
inline ::sdpa::events::Token* Results::mutable_output_token(int index) {
  return output_token_.Mutable(index);
}
inline ::sdpa::events::Token* Results::add_output_token() {
  return output_token_.Add();
}

// -------------------------------------------------------------------

// DeleteJob

// required bytes id = 1;
inline bool DeleteJob::has_id() const {
  return _has_bit(0);
}
inline void DeleteJob::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DeleteJob::id() const {
  return *id_;
}
inline void DeleteJob::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DeleteJob::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DeleteJob::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteJob::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// DeleteJobAck

// required bytes id = 1;
inline bool DeleteJobAck::has_id() const {
  return _has_bit(0);
}
inline void DeleteJobAck::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DeleteJobAck::id() const {
  return *id_;
}
inline void DeleteJobAck::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DeleteJobAck::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DeleteJobAck::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteJobAck::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// Poll

// required int32 queue_length = 1;
inline bool Poll::has_queue_length() const {
  return _has_bit(0);
}
inline void Poll::clear_queue_length() {
  queue_length_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Poll::queue_length() const {
  return queue_length_;
}
inline void Poll::set_queue_length(::google::protobuf::int32 value) {
  _set_bit(0);
  queue_length_ = value;
}

// -------------------------------------------------------------------

// PollReply

// required .sdpa.events.Activity activity = 1;
inline bool PollReply::has_activity() const {
  return _has_bit(0);
}
inline void PollReply::clear_activity() {
  if (activity_ != NULL) activity_->::sdpa::events::Activity::Clear();
  _clear_bit(0);
}
inline const ::sdpa::events::Activity& PollReply::activity() const {
  return activity_ != NULL ? *activity_ : *default_instance_->activity_;
}
inline ::sdpa::events::Activity* PollReply::mutable_activity() {
  _set_bit(0);
  if (activity_ == NULL) activity_ = new ::sdpa::events::Activity;
  return activity_;
}

// -------------------------------------------------------------------

// JobFinished

// required bytes id = 1;
inline bool JobFinished::has_id() const {
  return _has_bit(0);
}
inline void JobFinished::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFinished::id() const {
  return *id_;
}
inline void JobFinished::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFinished::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFinished::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobFinished::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// repeated .sdpa.events.Token output = 2;
inline int JobFinished::output_size() const {
  return output_.size();
}
inline void JobFinished::clear_output() {
  output_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >&
JobFinished::output() const {
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >*
JobFinished::mutable_output() {
  return &output_;
}
inline const ::sdpa::events::Token& JobFinished::output(int index) const {
  return output_.Get(index);
}
inline ::sdpa::events::Token* JobFinished::mutable_output(int index) {
  return output_.Mutable(index);
}
inline ::sdpa::events::Token* JobFinished::add_output() {
  return output_.Add();
}

// -------------------------------------------------------------------

// JobFinishedAck

// required bytes id = 1;
inline bool JobFinishedAck::has_id() const {
  return _has_bit(0);
}
inline void JobFinishedAck::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFinishedAck::id() const {
  return *id_;
}
inline void JobFinishedAck::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFinishedAck::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFinishedAck::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobFinishedAck::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// JobFailed

// required bytes id = 1;
inline bool JobFailed::has_id() const {
  return _has_bit(0);
}
inline void JobFailed::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFailed::id() const {
  return *id_;
}
inline void JobFailed::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFailed::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFailed::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobFailed::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// JobFailedAck

// required bytes id = 1;
inline bool JobFailedAck::has_id() const {
  return _has_bit(0);
}
inline void JobFailedAck::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFailedAck::id() const {
  return *id_;
}
inline void JobFailedAck::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFailedAck::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void JobFailedAck::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobFailedAck::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// -------------------------------------------------------------------

// LifeSignal

// required fixed64 timestamp = 1;
inline bool LifeSignal::has_timestamp() const {
  return _has_bit(0);
}
inline void LifeSignal::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 LifeSignal::timestamp() const {
  return timestamp_;
}
inline void LifeSignal::set_timestamp(::google::protobuf::uint64 value) {
  _set_bit(0);
  timestamp_ = value;
}

// required bytes component_id = 2;
inline bool LifeSignal::has_component_id() const {
  return _has_bit(1);
}
inline void LifeSignal::clear_component_id() {
  if (component_id_ != &_default_component_id_) {
    component_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LifeSignal::component_id() const {
  return *component_id_;
}
inline void LifeSignal::set_component_id(const ::std::string& value) {
  _set_bit(1);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void LifeSignal::set_component_id(const char* value) {
  _set_bit(1);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void LifeSignal::set_component_id(const void* value, size_t size) {
  _set_bit(1);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LifeSignal::mutable_component_id() {
  _set_bit(1);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  return component_id_;
}

// -------------------------------------------------------------------

// ConfigRequest

// required bytes component_id = 1;
inline bool ConfigRequest::has_component_id() const {
  return _has_bit(0);
}
inline void ConfigRequest::clear_component_id() {
  if (component_id_ != &_default_component_id_) {
    component_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ConfigRequest::component_id() const {
  return *component_id_;
}
inline void ConfigRequest::set_component_id(const ::std::string& value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void ConfigRequest::set_component_id(const char* value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void ConfigRequest::set_component_id(const void* value, size_t size) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigRequest::mutable_component_id() {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  return component_id_;
}

// -------------------------------------------------------------------

// ConfigReply

// required bytes component_id = 1;
inline bool ConfigReply::has_component_id() const {
  return _has_bit(0);
}
inline void ConfigReply::clear_component_id() {
  if (component_id_ != &_default_component_id_) {
    component_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ConfigReply::component_id() const {
  return *component_id_;
}
inline void ConfigReply::set_component_id(const ::std::string& value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void ConfigReply::set_component_id(const char* value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void ConfigReply::set_component_id(const void* value, size_t size) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigReply::mutable_component_id() {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  return component_id_;
}

// required .sdpa.events.Config config = 2;
inline bool ConfigReply::has_config() const {
  return _has_bit(1);
}
inline void ConfigReply::clear_config() {
  if (config_ != NULL) config_->::sdpa::events::Config::Clear();
  _clear_bit(1);
}
inline const ::sdpa::events::Config& ConfigReply::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::sdpa::events::Config* ConfigReply::mutable_config() {
  _set_bit(1);
  if (config_ == NULL) config_ = new ::sdpa::events::Config;
  return config_;
}

// -------------------------------------------------------------------

// Config

// optional .sdpa.events.Properties properties = 2;
inline bool Config::has_properties() const {
  return _has_bit(0);
}
inline void Config::clear_properties() {
  if (properties_ != NULL) properties_->::sdpa::events::Properties::Clear();
  _clear_bit(0);
}
inline const ::sdpa::events::Properties& Config::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::sdpa::events::Properties* Config::mutable_properties() {
  _set_bit(0);
  if (properties_ == NULL) properties_ = new ::sdpa::events::Properties;
  return properties_;
}


}  // namespace events
}  // namespace sdpa
#endif  // PROTOBUF_sdpa_2dmsg_2eproto__INCLUDED
