#!/bin/bash

init_screen_ver=5
env_file="$HOME/.init-screen.env"
tab_file="$HOME/.init-screen.tab"
rc_file="$HOME/.init-screen.rc"
cfg_file="$HOME/.init-screen.cfg"

test -r "$HOME/.init-screen.cfg" && source "$HOME/.init-screen.cfg"

head_node="${SDPA_HEAD_NODE}"
if [ -z "$head_node" ] ; then
    head_node="${PBS_O_HOST}"
fi

node_file="${PBS_NODEFILE}"
scratch_dir="$SDPA_SCRATCH_DIR"
log_dir="$SDPA_LOG_DIR"
temp_dir="$SDPA_TEMP_DIR"
gui_url="$SDPA_GUI"
gpi_priv_dir="$GPI_PRIV_DIR"
screen_name="$SCREEN_SOCKET"

prefix="$SDPA_HOME"
if [ -z "$prefix" ] ; then
    mydir=$(cd $(dirname $( which $0 )) && pwd)
    prefix=$(dirname "$mydir")
fi

function usage ()
{
	cat >&2 <<EOF
usage $0 [-h] [-f node-file] [-n head-node] [-d scratch-dir] [-s screen-name]

   -f node-file ($node_file)     specifies the node file to use
   -n head node ($head_node)     specifies the head node host (where screen runs)
   -t temporary dir ($temp_dir)  path to a (local) temporary directory
   -s screen name (=$screen_name) the name of the screen session
   -C                             clear state tracking files
   -c                             configure init-screen
   -l                             print shell code to load init-screen environment

important environment variables:
	export IN_INIT_SCREEN="$IN_INIT_SCREEN"
	export SDPA_HEAD_NODE="$head_node"
        export SDPA_SCRATCH_DIR="$scratch_dir"
        export SDPA_TEMP_DIR="$temp_dir"
	export SDPA_GUI="$gui_url"
	export SDPA_MASTER="$SDPA_MASTER"
	export FHGLOG_to_console="$FHGLOG_to_console"
	export FHGLOG_to_server="$FHGLOG_to_server"
	export FHGLOG_threaded="$FHGLOG_threaded"
        export KVS_URL="$KVS_URL"
EOF
}

function configure ()
{
    echo "Starting configuration routine..."

    # creates $HOME/.init-screen.cfg
    cat <<EOF


=====   GPI priviledged directory  ====

The "gpi priviledged" directory is the  directory that is used by the GPI daemon
to execute  binary files. It should point  to a directory you  have write access
to.

EOF
    read -e -p "  GPI priviledged directory to use [$gpi_priv_dir]: " new_gpi_priv_dir
    if [ -n "$new_gpi_priv_dir" ] ; then
	gpi_priv_dir="$new_gpi_priv_dir"
    fi

    cat <<EOF


=====   Scratch directory  ====

The "scratch"  directory should be a directory  you are allowed to  write to and
that is shared among all nodes. I will create a "log" directory within that into
which all components are going to log.

EOF
    read -e -p "  scratch directory to use [$scratch_dir]: " new_scratch_dir
    if [ -n "$new_scratch_dir" ] ; then
	scratch_dir="$new_scratch_dir"
    fi
    log_dir="$scratch_dir/log"

    cat <<EOF


=====   Node-local temporary directory  ====

This  directory  should point  to  a  path that  is  local  to  each node,  like
/var/tmp. It is used to create local temporary files that might be necessary for
some executions.

EOF
    read -e -p "  temporary directory to use [$temp_dir]: " new_temp_dir
    if [ -n "$new_temp_dir" ] ; then
	temp_dir="$new_temp_dir"
    fi

    cat <<EOF


=====   GUI configuration  ====

Now I need a 'host:port' string on which the graphical monitor interface will be
running.  It  does not  have to run  all the  time, but if  you want  to monitor
activities, I need to know that location. Please make sure that nobody else uses
this location.

EOF
    read -e -p "  location of the monitor gui (host:port) [$gui_url]: " new_gui_url
    if [ -n "$new_gui_url" ] ; then
	gui_url="$new_gui_url"
    fi

    if [ ! -e "$HOME/.screenrc" ] ; then
	cat <<EOF

====  Screen configuration  ====

It seems that you  don't have a .screenrc yet. It is  recommended to create one,
though. For  your convenience, I  can create an  example .screenrc file  for you
with the following content:

#
# example .screenrc created by 'init-screen' on `date`
#
defutf8 on
startup_message off
caption always "%{= d} %{+b dr}%H%{= dg} | %c %{= dy}%d.%m.%Y | %{= dw}%?%-Lw%?%{b}%n*%f %t%?(%u)%?%{= dw}%?%+Lw%?%{= d}"
autodetach on
bind x
bind ^X
vbell off

EOF
	read -e -n 1 -p "  Shall I create this file now? [Y/n] " create_screenrc
	case "$create_screenrc" in
	    n|N)
		;;
	    *)
		cat > ~/.screenrc <<EOF
#
# example .screenrc created by 'init-screen' on `date`
#
defutf8 on
startup_message off
caption always "%{= d} %{+b dr}%H%{= dg} | %c %{= dy}%d.%m.%Y | %{= dw}%?%-Lw%?%{b}%n*%f %t%?(%u)%?%{= dw}%?%+Lw%?%{= d}"
autodetach on
bind x
bind ^X
vbell off
EOF
		;;
	esac
    fi

    # backup old config
    if [ -e "$HOME/.init-screen.cfg" ] ; then
	mv "$HOME/.init-screen.cfg" "$HOME/.init-screen.cfg.bak"
    fi
    # create config
    cat > "$HOME/.init-screen.cfg" <<EOF
export INIT_SCREEN_VER="$init_screen_ver"
export SDPA_SCRATCH_DIR="$scratch_dir"
export SDPA_LOG_DIR="$log_dir"
export SDPA_TEMP_DIR="$temp_dir"
export SDPA_GUI="$gui_url"
export GPI_PRIV_DIR="$gpi_priv_dir"
export PC_LIBRARY_PATH="$HOME/.sdpa/modules:$PC_LIBRARY_PATH"
EOF

    cat <<EOF

Congratulations,    your    configuration    file    has    been    stored    in
~/.init-screen.cfg.

To  finish the  setup of  init-screen,  please add  the following  line to  your
~/.bashrc:

   eval \$(init-screen -l)

You can do so, by executing

   echo 'eval \$(init-screen -l)' >> ~/.bashrc
EOF
}

function print_load_instructions ()
{
# please pass the following to the 'eval' function
     cat <<EOF
if test -r "${tab_file}" ; then if grep -q "\$(hostname -s)" "${tab_file}" ; then if test -r "${env_file}" ; then source "${env_file}"; fi; fi; fi
EOF
}

while getopts ":hcClf:n:s:" opt; do
    case $opt in
	h)
	    usage
	    exit 0
	    ;;
	c)
	    configure
	    exit 0
	    ;;
	C)
	    echo "clearing state files..." >&2
	    rm -f "${tab_file}"
	    rm -f "${env_file}"
	    echo "please logout and reinitialize now"
	    exit 0
	    ;;
	f)
	    node_file=$OPTARG
	    ;;
	n)
	    head_node=$OPTARG
	    ;;
	s)
	    screen_name=$OPTARG
	    ;;
	l)
	    print_load_instructions
	    exit 0
	    ;;
	\?)
	    echo "invalid option: $OPTARG" >&2
	    echo "try `basename $0` -h to get a list of options" >&2
	    exit 1
    esac
done

function log ()
{
    echo "$@" >&2
}

function sanity_check_directories ()
{
    # GPI priviledged directory
    if [ ! -d "$gpi_priv_dir" ] ; then
	log "W: priviledged GPI directory ($gpi_priv_dir) does not exist!"
	tmp=$( mkdir -p "$gpi_priv_dir" 2>&1 )
	if [ $? -ne 0 ] ; then
	    log "E: could not create $gpi_priv_dir: $tmp"
	    return 1
	fi
    else
	if [ ! -w "$gpi_priv_dir" ] ; then
	    log "W: you are not permitted to write to the priviledged GPI directory."
	    log "I:     dir: $gpi_priv_dir"
	fi
    fi

    # sanity check for scratch directory
    if [ -z "$scratch_dir" ] ; then
	log "W: scrach_dir is not defined, please export SDPA_SCRATCH_DIR or put a definition in ~/.init-screen.cfg"
	read -e -n 1 -p "scratch dir to use: " scratch_dir
    fi

    if [ ! -d "${scratch_dir}" ] ; then
	read -e -n 1 -p "W: $scratch_dir does not exist, shall i create it for you [y/N]? " do_create
	case "$do_create" in
	    y|Y)
		if ! mkdir -p "$scratch_dir" ; then
		    log "E: could not create directory!"
		    return 1
		fi
		;;
	    *)
		log "bye."
		return 1
		;;
	esac
    fi

    if [ ! -d "${scratch_dir}" -o ! -w "${scratch_dir}" ] ; then
	log "scratch-dir ${scratch_dir} still does not exist or cannot be written do, giving up" >&2
	return 1
    fi

    if [ ! -d "$log_dir" ] ; then
	mkdir -p "$log_dir" || { log "E: could not create log directory: $log_dir" >&2 ; return 1; }
    fi

    if [ ! -d "$HOME/.sdpa/modules" ] ; then
	mkdir -p "$HOME/.sdpa/modules" || { log "E: could not create $HOME/.sdpa/modules" >&2 ; return 1; }
    fi
    return 0
}

if [ ! -e "$HOME/.init-screen.cfg" ] ; then
    log "E: \"$HOME/.init-screen.cfg\" does not exist, please run `basename $0` -c to create one."
    exit 1
fi

if [ x"$init_screen_ver" != x"$INIT_SCREEN_VER" ] ; then
    log "E: \"$HOME/.init-screen.cfg\" is outdated and needs to be recreated. Please run `basename $0` -c"
    exit 1
fi

# check GPI config
if [ ! -e "$HOME/.sdpa/configs/gpi.rc" ] ; then
    log "E: $HOME/.sdpa/configs/gpi.rc does not exist!"
    log "I:    please copy it from $prefix/share/gpi/gpi.rc.tpl"
    log "-:"
    log "I:        cp $prefix/share/gpi/gpi.rc.tpl $HOME/.sdpa/configs/gpi.rc"
    log "-:"
    log "I:    edit the file to your needs."
    exit 1
fi

if ! sanity_check_directories ; then
    log "E: directory check failed!"
    exit 1
fi

export SDPA_SCRATCH_DIR="$scratch_dir"
export SDPA_TEMP_DIR="$temp_dir"

# sanity check for node file
if [ -z "$node_file" ] ; then
    log "W: node_file is not defined, please enter it now or export PBS_NODEFILE."
    read -e -p "type in the node file to use: " node_file
    node_file=$( eval echo "$node_file" )
fi

if [ ! -f "$node_file" -o ! -r "$node_file" ] ; then
    log "E: cannot access node-file in $node_file: not a file or not readable!"
    exit 1
fi

cp "$node_file" "$HOME/.init-screen.nodefile"
if [ $? -ne 0 ] ; then
    log "E: could not save node-file!"
    exit 1
fi

export SDPA_NODEFILE="$HOME/.init-screen.nodefile"

node_name=`hostname -s`
first_node=$( head -n 1 "$node_file" )
if [ x"$first_node" != x"$node_name" ] ; then
    log "Sorry, but I have to be run on the master node ($first_node)!"
    exit 1
fi

# check head node
if [ -z "$head_node" ] ; then
    log "Sorry, I don't know my head node, can you help me out here?"
    read -p "head node to use: " head_node
fi

if ! ping -c 1 "$head_node" >/dev/null 2>&1 ; then
    log "head-node ($head_node) is not reachable ;-("
    exit 1
fi

job_id="${PBS_JOB_ID}"
if [ -z "$job_id" ] ; then
    job_id="job.$head_node.$RANDOM"
fi

master="$node_name"
if [ -r "${tab_file}" ]; then
    if grep -q "$master" "${tab_file}"; then
	log "# It seems, that there is already another screen environment running."
	log "#"
	log "# hint:"
	log "#   possibly running on: `cat ${tab_file} | awk '{print $3}'`"
	read -n 1 -p "Do you want me to fix this? [y/N] " ignore_running
	case $ignore_running in
	    y|Y)
		/bin/rm -f "${tab_file}"
		;;
	    *)
		exit 0
		;;
	esac
    fi
fi

tmp=`cat $node_file | grep -v "$master" | uniq`
tmp=`echo $master $tmp`
echo "${job_id} = $tmp" > "${tab_file}"

log "clearing ${env_file}..."
/bin/rm -f "$env_file"
log "writing environment info to $env_file..."

test -d "$HOME/.sdpa/data" || mkdir -p "$HOME/.sdpa/data"

export SDPA_LOG_DIR="$scratch_dir/log"
test -d "$SDPA_LOG_DIR" || mkdir -p "$SDPA_LOG_DIR"

cat > "$env_file" <<EOF
#
# init screen internal
#
export IN_INIT_SCREEN="yes"
export SDPA_HEAD_NODE="$head_node"
export SDPA_MASTER="$master"
export SDPA_NODEFILE="$HOME/.init-screen.nodefile"

#
# logging config
#
export FHGLOG_to_server="$master"
export FHGLOG_threaded="false"
export FHGLOG_level="WARN"
#
# key value store config
#
export KVS_URL="$master:2439"
export KVS_STORE="$HOME/.sdpa/data/kvs.dat"

function log ()
{
  echo "\$@" >&2
  test -x "`which fhglogc 2>/dev/null`" && fhglogc -t "\$0" -p 2 -m "\$@"
}

test -r "$HOME/.init-screen.cfg" && source "$HOME/.init-screen.cfg"

#
# user config follows (may override above values, please be careful!)
#
test -r "$HOME/.init-screen.rc" && source "$HOME/.init-screen.rc"
EOF

if [ ! -r "$HOME/.init-screen.rc" ]; then
    log "creating default .init-screen.rc file..."
    cat > "$HOME/.init-screen.rc" <<EOF
export PC_LIBRARY_PATH="\$HOME/.sdpa/modules:${PC_LIBRARY_PATH}"
export PC_MODULE_DATA="\$HOME/.sdpa/moddata"
EOF
fi

function open_screen_window ()
{
    title="${1:?}"
    node="${2:?}"
    log "opening screen window $title on node $node"
    screen_opts="-D -RR -r"
    if [ -n "$screen_name" ] ; then
	screen_opts="$screen_opts -S $screen_name"
    fi
    ssh -Y -t "$head_node" screen $screen_opts -X "screen -t $title ssh -Y -t $node"
}

# fix permissions on ~/.Xauthority?
touch $HOME/.Xauthority
chmod u=rw,g=,o= $HOME/.Xauthority

for t in log sdpa ; do
    open_screen_window "$t" "$master"
done
open_screen_window "master:$master" "$master"

log "using slave nodes from ${node_file}..."
nodes=`cat ${node_file} | grep -v "$master" | uniq`
num_nodes=`echo $nodes | wc -w`
max_nodes=${SDPA_MAX_SCREEN_NODES:=8}

open_slave_screens=true
if [ $num_nodes -gt $max_nodes ] ; then
    read -n 1 -p "Do you really want to start screen sessions on $num_nodes nodes (configured maximum=$max_nodes)? [y/N]: " answer
    case "$answer" in
	y|Y)
	    log "ok, I'll do as you whish"
	    open_slave_screens=true
	    ;;
	*)
	    open_slave_screens=false
	    log "Puh."
	    ;;
    esac
fi

if [ "$open_slave_screens" == "true" ] ; then
    log "going to start screen session on nodes:" $nodes
    bunch_size=16
    count=0
    for n in $nodes; do
	open_screen_window "$n" "$n" &
	count=$(( count + 1 ))
	if [ $count -ge $bunch_size ] ; then
	    wait
	    count=0
	fi
    done
    wait
    ssh -Y -t "$head_node" screen -D -RR -r -X 'select 0'
fi

echo "# entering new shell, please logout twice from this window"
# use the sideeffect that it will source the init-screen.env
trap "init-screen -C" EXIT
$SHELL
