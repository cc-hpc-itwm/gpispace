#!/bin/bash

CLEAR_LOGS_REQUIRE_FORCE=true
cat ~/.sdpa/state/sdpa.env >/dev/null 2>&1

test -r ~/.sdpa/state/sdpa.env && source ~/.sdpa/state/sdpa.env

dry_run=false
use_force=false
remove_all=false
remove_unknown=false
dir="$SDPA_LOG_DIR"
match_comp=

function usage ()
{
    cat >&2 <<EOF
usage: $0 [-h] [-a] [-x] [-n] [-f] [-d dir] [-c component]

   -h: this help
   -a: remove all logfiles
   -x: remove 'unknown' logfiles (not matching component.host.log)
   -n: dry-run
   -f: force execution
   -d logdir: specifiy directory to work on (default: $dir)
   -c component: remove only log files from this component

you may set CLEAR_LOGS_REQUIRE_FORCE to "true" or "false" in order
to control the default behavior (current: $CLEAR_LOGS_REQUIRE_FORCE)
EOF
}

function is_fake_mode ()
{
    if [ "$dry_run" == "true" ] ; then
	return 0
    elif [ "$CLEAR_LOGS_REQUIRE_FORCE" == "true" -a "$use_force" == "false" ] ; then
	return 0
    fi
    return 1
}

function remove ()
{
    target="$1"
    info="$2"
    if [ -e "$target" ] ; then
	if is_fake_mode ; then
	    echo "would remove: $target $2" >&2
	else
	    err=$( rm -f -- "$target" 2>&1 )
	    if [ $? -ne 0 ] ; then
		echo "W: failed to remove $target: $err" >&2
	    fi
	fi
    fi
}

while getopts ":hxanfd:c:" opt ; do
    case "$opt" in
	h)
	    usage
	    exit 0
	    ;;
	x)
	    remove_unknown=true
	    ;;
	a)
	    remove_all=true
	    ;;
	n)
	    dry_run=true
	    ;;
	f)
	    use_force=true
	    ;;
	d)
	    dir="$OPTARG"
	    ;;
	c)
	    match_comp="$OPTARG"
	    ;;
	\?)
	    echo "invalid option: $OPTARG" >&2
	    echo "try $0 -h to get a list of options" >&2
	    exit 1
	    ;;
    esac
done

if [ ! -w "$dir" ] ; then
    echo "you don't have write access to $dir" >&2
    exit 2
fi

if [ -z "$SDPA_NODEFILE" ] ; then
    echo "W: SDPA_NODEFILE is not defined!" >&2
    if [ $use_force == "false" ] ; then
	echo "I: switching to dry_run for safety reasons, specify -f to override" >&2
	dry_run="true"
    else
	echo "I: probably removing all files"
    fi
fi

for logfile in "$dir"/*.log ; do
    base=$( basename "$logfile" )
    # logfile name format: comp.host.log
    comp=$( echo "$base" | cut -d. -f 1 2>/dev/null)
    node=$( echo "$base" | cut -d. -f 2 2>/dev/null)
    tail=$( echo "$base" | cut -d. -f 3 2>/dev/null)
    err=$?
    if [ -n "$match_comp" -a "$match_comp" != "$comp" ] ; then
	continue
    fi

    if [ $err -eq 0 -a -n "$node" -a x"$tail" == x"log" ] ; then
	if ! grep -q -e "$node" "$SDPA_NODEFILE" </dev/null 2>/dev/null; then
	    remove "$logfile"
	else
	    if [ $remove_all == "true" ] ; then
		remove "$logfile" "(all)"
	    fi
	fi
    else
	if [ $remove_unknown == "true" ] ; then
	    remove "$logfile" "(unknown)"
	fi
    fi

    if [ -e "$logfile" ] ; then
	if is_fake_mode ; then
	    echo "would clear: $logfile" >&2
	else
	    err=$( :> "$logfile" 2>&2 )
	    if [ $? -ne 0 ] ; then
		echo "W: could not clear $logfile: $err"
	    fi
	fi
    fi
done
