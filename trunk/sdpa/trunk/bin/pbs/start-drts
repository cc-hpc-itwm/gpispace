#!/bin/bash

test -r "$HOME/.sdpa/state/sdpa.env" && source "$HOME/.sdpa/state/sdpa.env"

# set some default values
gui="$SDPA_GUI"
if [ -z "$gui" ]
then
  gui="$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g sdpa.gui)"
fi

force=false
debug=false
verbose=false
daemonize=false
backlog=$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g plugin.drts.backlog -v 3)
identity=0
name_prefix="drts-$(hostname -s)"
master=
gpi_enabled="$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g gpi.enabled -v true)"
gpi_socket="$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g gpi.socket_path -v /var/tmp/gpi-space)"
gpi_socket="$gpi_socket/GPISpace-$(id -u)"
gpi_socket="$gpi_socket/$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g gpi.socket_name -v control)"
lib_path="$PC_LIBRARY_PATH"
kvs_url="${KVS_URL}"
count=

function usage ()
{
    cat >&2 <<EOF
usage: $(basename "$0") [options]

    -h: print this help
    -v: verbose
    -f: force: kill still running processes
    -i ident (=$identiy): identity
    -m master (=$master): master to connect to
    -g ip:port (=$gui): gui address
    -b N (=$backlog): set the backlog
    -S path (=$gpi_socket): gpi socket path
    -l path (=$lib_path): library path
    -k kvs-url (=$kvs_url): url to the key-value-store
    -c count: start this many processes (0==#cores)
    -D daemonize
    -L logfile
EOF
}

# sends a given pid after N(=0) seconds to the background
function to_bg ()
{
    local pid="$1"; shift
    if [ -z "$pid" ] ; then
	return 1
    fi
    if ! kill -0 "$pid" &>/dev/null ; then
	return 2
    fi
    local when="$1"; shift
    if [ -z "$when" ] ; then
	when=0
    fi
    #echo "to_bg: sleeping $when second(s)"
    sleep $when
    #echo "to_bg: stopping $pid"
    # note: the builtin kill doesn't seem to to work always(?)
    /bin/kill -STOP "$pid"
    #echo "to_bg: resuming $pid"
    /bin/kill -CONT "$pid"
}

while getopts ":hvfg:m:i:b:S:l:k:Dc:L:M:" opt; do
    case $opt in
	h)
	    usage
	    exit 0
	    ;;
	v)
	    verbose=true
	    ;;
	f)
	    force=true
	    ;;
	g)
	    gui=$OPTARG
	    ;;
	m)
	    master=$OPTARG
	    ;;
	i)
	    identity=$OPTARG
	    ;;
	b)
	    backlog=$OPTARG
	    ;;
	S)
	    gpi_socket=$OPTARG
	    ;;
	l)
	    lib_path=$OPTARG
	    ;;
	k)
	    kvs_url=$OPTARG
	    ;;
	D)
	    daemonize=true
	    ;;
	L)
	    logfile="$OPTARG"
	    ;;
	c)
	    count="$OPTARG"
	    ;;
	\?)
	    echo "invalid option: -$OPTARG" >&2
	    echo "try: $0 -h" >&2
	    exit 1
	    ;;
    esac
done

if [ -z "$kvs_url" ] ; then
    log "E: no kvs-url specified!"
    exit 1
fi

if [ -z "$master" ] ; then
    log "E: no master specified!"
    exit 1
fi

# quick hack to easily start multiple instances
if [ -n "$count" ] ; then
    if [ $count -eq 0 ] ; then
	count=$(grep ^processor /proc/cpuinfo | wc -l)
    fi
    stop-drts
    for i in $(seq 1 $count) ; do
	$0 -i $i -m $master -k "$kvs_url" -b "$backlog" -S "$gpi_socket" -g "$gui" -l "$lib_path" -D -f </dev/null &>/dev/null &
    done
    exit 0
fi

name="${name_prefix}-${identity}"

logfile="$SDPA_LOG_DIR/${name}.log"

bin="$(which fhgkernel)"
if [ ! -x "$bin" ] ; then
  log "# could not find fhgkernel in the path!"
  exit 1
fi

# check if still running
still_running=$(ps -C fhgkernel -o pid=)
for p in $still_running ; do
    if grep -q -e "plugin.drts.name=$name" /proc/$p/cmdline ; then
	if [ "$force" == "true" ] ; then
	    log "W: $name is still running, terminating it"
	    kill -TERM "$p"
	    sleep 3
	    kill -KILL "$p" &>/dev/null
	else
	    log "E: $name still running, cannot start"
	    exit 1
	fi
    fi
done

# TODO: get those from the .sdpa/configs/sdpa.rc file, at least parts of it

# config values (kernel)
cfg="$cfg -s kernel.load.lazy=0"

# config values (kvs plugin)
kvs_host=$(echo "$kvs_url" | cut -d: -f1)
kvs_port=$(echo "$kvs_url" | cut -d: -f2)
cfg="$cfg -s plugin.kvs.host=$kvs_host"
cfg="$cfg -s plugin.kvs.port=$kvs_port"

# config values (drts plugin)
cfg="$cfg -s plugin.drts.name=$name"
cfg="$cfg -s plugin.drts.master=$master"
cfg="$cfg -s plugin.drts.backlog=$backlog"

# config values (gpi plugin)
cfg="$cfg -s plugin.gpi.socket=${gpi_socket}"
cfg="$cfg -s plugin.gpi.startmode=$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g plugin.gpi.startmode -v wait)"

# config values (gpi-compat plugin)
cfg="$cfg -s plugin.gpi-compat.shm_size=$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g plugin.gpi-compat.shm_size -v 536870912)"
cfg="$cfg -s plugin.gpi-compat.com_size=$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g plugin.gpi-compat.com_size -v 16777216)"

# config values (gui plugin)
cfg="$cfg -s plugin.gui.url=$gui"

# config values (wfe plugin)
cfg="$cfg -s plugin.wfe.library_path=${PC_LIBRARY_PATH}"

plugins="$(fhgcfg -f ~/.sdpa/configs/sdpa.rc -g kernel.plugins)"

plugin_load_flags=""
for p in $(echo $plugins | tr ',' ' '); do
    if [ x"$gpi_enabled" == x"false" ] ; then
	if echo $p | grep -q 'gpi' ; then
	    continue
	fi
    fi
    plugin_load_flags="$plugin_load_flags -l $SDPA_HOME/libexec/plugins/$p.so"
done

cmd="${bin} $cfg $plugin_load_flags"

log "Running $cmd on node $hostname"
export FHGLOG_to_file="$logfile"

if [ "$daemonize" == "true" ] ; then
    to_bg $$ 3 </dev/null &>/dev/null &
    exec $cmd </dev/null &> "${logfile}"
    echo "exec failed: $?"
else
    exec $cmd
fi
