#!/bin/bash
#
# usage: sdpa {start|stop|status|submit file}
#

# increment this value up to date if anything config related changes!
CONFIG_VERSION=2

config_file=${SDPA_CONFIG:="$HOME/.sdpa/configs/sdpa.rc"}
state_dir=${SDPA_STATE_DIR:="$HOME/.sdpa/state"}

##############################################
#                                            #
#  F U N C T I O N    D E F I N I T I O N S  #
#                                            #
##############################################

function log ()
{
    echo "$@" >&2
}

function get ()
{
    local key="$1"; shift
    local def="$1"; shift

    fhgcfg -f "$config_file" -g "$key" -v "$def"
}

function put ()
{
    local key="$1"; shift
    local val="$1"; shift

    fhgcfg -f "$config_file" -a "$key" -v "$val"
}

#
# check, if we have to start the setup routine
#
function setup_required ()
{
    if ! test -e "$config_file" ; then
      mkdir -p $(dirname "$config_file") 2>/dev/null
      touch "$config_file"
      return 0
    fi
    local cfg_version=$( get "config.version" )
    test -n "$cfg_version" || return 0
    if ! test "$cfg_version" == "$CONFIG_VERSION" ; then
	log "W: config is outdated"
	return 0
    fi
    return 1
}

function setup_state ()
{
    if [ ! -d "$state_dir" ] ; then
	local msg=$( mkdir -p "$state_dir" 2>&1 )
	if [ $? -ne 0 ] ; then
	    echo "E: failed to create state-dir: $state_dir: $msg" >&2
	    return 1
	fi
    fi

    local sdpa_home=$(get "sdpa.home" "$SDPA_HOME")
    if [ -z "$sdpa_home" ] ; then
	mydir=$(cd $(dirname $( which $0 )) && pwd)
	sdpa_home=$(dirname "$mydir")
    fi
    get_user_input "SDPA installation directory [$sdpa_home]:" sdpa_home

    put "sdpa.home" "$sdpa_home"

    local node_file="$state_dir/nodefile"

    put "sdpa.node_file" "$node_file"
    log "I: node file configured to be stored in $node_file"

    put "sdpa.state_dir" "$state_dir"
    log "I: state directory configured to be in $state_dir"
    return 0
}

function setup_kvs ()
{
    local kvs_data_dir="$HOME/.sdpa/data"
    if ! test -d "$kvs_data_dir" ; then
	if ! mkdir -p "$kvs_data_dir" ; then
	    log "E: failed to create kvs data directory: $kvs_data_dir"
	    return 1
	fi
    fi
    local kvs_store="$kvs_data_dir/kvs.dat"

    put "kvs.store" "$kvs_store"

    log "I: kvs configured to store data in $kvs_store"

    return 0
}

function y_n_p ()
{
    local prompt="$1" ; shift
    read -n 1 -p "$prompt [y/N] " yes_or_no
    case "$yes_or_no" in
	y|Y)
	    echo
	    return 0
	    ;;
	?)
	    echo
	    return 1
	    ;;
	*)
	    return 1
	    ;;
    esac
}

function prepend_to_path ()
{
    local var="$1"; shift
    local val=$(eval echo \$${var})
    for v ; do
	val=$(echo "$val" | sed "s,:$v:,:,g")
	val=$(echo "$val" | sed -e "s,^$v:,,g")
	val=$(echo "$val" | sed -e "s,:$v\$,,g")
	if ! echo "$val" | grep -q -- "$v" ; then
	    val="$v:$val"
	fi
    done
    eval "$var=$val"
}

function append_to_path ()
{
    local var="$1"; shift
    local val=$(eval echo \$${var})
    for v ; do
	if ! echo "$val" | grep -q -- "$v" ; then
	    val="$val:$v"
	fi
    done
    eval "$var=$val"
}

function get_user_input ()
{
    local prompt="$1"; shift
    local var="$1"; shift
    local doc="$1"; shift
    if [ -n "$doc" ] ; then
	cat <<EOF
$doc
EOF
    fi
    read -e -p "  $prompt " new_val
    if [ -n "$new_val" ] ; then
	new_val=$(eval echo "$new_val")
	eval "$var=$new_val"
    fi
}

function setup_scratch ()
{
    local doc='

                 ================================
                 *       Scratch directory      *
                 ================================

The "scratch"  directory should be a directory  you are allowed to  write to and
that is shared among all nodes.
'

    local scratch_dir=$(get "sdpa.scratch_dir")
    get_user_input "scratch directory to use [$scratch_dir]:" scratch_dir "$doc"

    if ! test -d "$scratch_dir" ; then
	if ! mkdir -p "$scratch_dir" ; then
	    log "E: failed to create scratch directory: $scratch_dir"
	    return 1
	fi
    fi

    put "sdpa.scratch_dir" "$scratch_dir"
    log "-: using scratch dir $scratch_dir"
}

function setup_logging ()
{
    local doc='

                 ================================
                 *     Logging Configuration    *
                 ================================

This "host:port" definition  defines where all the components  send log messages
to. It should be on the same host that you run the GUI on.
'
    local url=$(get "log.server.url" "$(hostname -f):$(( $(id -u) + 1024))")
    local prompt="remote logging to (host:port) [$url]:"
    get_user_input "$prompt" url "$doc"

    local lvl=$(get "log.server.level" "INFO")
    local prompt="log level [$lvl]:"
    get_user_input "log level to use [$lvl]:" lvl ""
    lvl=$( echo "$lvl" | tr [a-z] [A-Z] )

    local log_dir=$(get "sdpa.log_dir")
    if [ -z "$log_dir" ] ; then
	log_dir=$(get "sdpa.scratch_dir")/log
    fi
    get_user_input "log directory to use [$log_dir]:" log_dir ""

    if ! test -d "$log_dir" ; then
	if ! mkdir -p "$log_dir" ; then
	    log "E: failed to create log directory: $log_dir"
	    return 1
	fi
    fi

    put "log.server.url" "$url"
    put "log.server.level" "$lvl"
    put "sdpa.log_dir" "$log_dir"

    log "-: using log server at $url"
    log "-: using log level of $lvl"
    log "-: using log dir $log_dir"
}

function setup_temp ()
{
    local doc='

                 ================================
                 *     Node local directory     *
                 ================================

This  directory  should point  to  a  path that  is  local  to  each node,  like
/var/tmp. It is used to create local temporary files that might be necessary for
some components.
'
    local key="sdpa.temp_dir"
    local val=$(get "$key")
    local prompt="temporary directory to use [$val]:"
    get_user_input "$prompt" val "$doc"

    if ! test -d "$val" ; then
	if ! mkdir -p "$val" ; then
	    log "E: failed to create temporary directory: $val"
	    return 1
	fi
    fi

    put "$key" "$val"

    log "-: using node local directory $val"
}

function setup_gui ()
{
    local doc='

                 ================================
                 *   Graphical User Interface   *
                 ================================

Now I need a "host:port" string on which the graphical monitor interface will be
running.  It  does not  have to run  all the  time, but if  you want  to monitor
activities, I need to know that location. Please make sure that nobody else uses
this location.
'
    local key="sdpa.gui"
    local val=$(get "$key" "$(hostname -f):$(( $(id -u) + 1023))")
    local prompt="location of the monitor gui (host:port) [$val]:"
    get_user_input "$prompt" val "$doc"
    put "$key" "$val"

    log "-: using gui at $val"
}

function setup_plugins ()
{
    cat <<EOF

Setting up plugins....
EOF

    local mod_dir="$HOME/.sdpa/modules"
    if ! test -d "$mod_dir" ; then
	if ! mkdir -p "$mod_dir" ; then
	    log "E: failed to create modules directory: $mod_dir"
	    return 1
	fi
    fi

    local plugin_dir="$HOME/.sdpa/plugins/autoload"
    if ! test -d "$plugin_dir" ; then
	if ! mkdir -p "$plugin_dir" ; then
	    log "E: failed to create plugins directory: $plugin_dir"
	    return 1
	fi
    fi

    local prefix=$(get "sdpa.home" "$SDPA_HOME")
    if [ -z "$prefix" ] ; then
	log "E: sdpa.home is not defined!"
	return 1
    fi

    log "-: using SDPA plugins from $prefix"

    local count=0
    # fill in some autoload plugins
    for p in fvm-pc-compat sinc ; do
	local plugin="$prefix/libexec/lib${p}.so"
	if test -e "$plugin" ; then
	    local c=$( printf "%0.2d" $count )
	    local link="$plugin_dir/${c}${p}.so"
	    if ln -sf "$plugin" "$link" ; then
		log "I: autoloading plugin $p (from $plugin)"
	    fi
	    count=$(( count + 1 ))
	fi
    done
}

function parse_human_readable_size ()
{
    local size_value="$1"; shift
    local var="$1"; shift
    size_value=$( echo "$size_value" | tr [a-z] [A-Z] )
    size_value=$( echo "$size_value" | sed -e 's/E$/*1024T/' )
    size_value=$( echo "$size_value" | sed -e 's/T$/*1024G/' )
    size_value=$( echo "$size_value" | sed -e 's/G$/*1024M/' )
    size_value=$( echo "$size_value" | sed -e 's/M$/*1024K/' )
    size_value=$( echo "$size_value" | sed -e 's/K$/*1024B/'  )
    size_value=$( echo "$size_value" | sed -e 's/B$/*1/'  )

    # compute the total and round to an integer
    size_value=$( echo "$size_value" | bc | xargs printf "%1.0f" )
    if [ -n "$var" ] ; then
	eval "$var=$size_value"
    else
	echo "$size_value"
    fi
}

function to_human_readable_size ()
{
    local size_value="$1"; shift
    local var="$1"; shift

    local new_val="1"
    local tmp=$( echo "$size_value > 1024" | bc )
    while test "$tmp" == "1" ; do
	new_val="$new_val*1024"
	size_value=$( echo "scale=2; $size_value/1024.0" | bc )
	tmp=$( echo "$size_value > 1024" | bc )
    done

    new_val=$( echo "$new_val" | sed -e 's/*1024$/K/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024K$/M/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024M$/G/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024G$/T/' )
    new_val=$( echo "$new_val" | sed -e 's/^1//')

    new_val="${size_value}${new_val}"
    if [ -n "$var" ] ; then
	eval "$var=$new_val"
    else
	echo "$new_val"
    fi
}

function setup_gpi ()
{
    local doc='

                 ================================
                 *        Fraunhofer GPI        *
                 ================================

This step configures  the GPI part of  the SDPA.  I will ask  for the privileged
directory from which user binaries are  allowed to be executed (the -p parameter
to the  gpid.exe). Additionally I will  ask for the  amount of GPI memory  to be
used on each node.

'
    local gpid_pid=$(ps -C gpid.exe -o pid= | tr -d ' ')
    local gpid_dir=$(cat /proc/$gpid_pid/cmdline 2>/dev/null | tr '\0' ' ' | grep -o -- '-p [^ ]*' | cut -d' ' -f 2)

    gpid_dir=$(get "gpi.priv_dir" "$gpid_dir")
    get_user_input "GPI privileged directory to use [$gpid_dir]:" gpid_dir "$doc"

    local gpi_size=$(get "gpi.memory_size" "5G")
    get_user_input "gpi memory size (per node) [$gpi_size]:" gpi_size
    parse_human_readable_size $gpi_size gpi_size
    if [ $gpi_size -le 0 ] ; then
	log "E: size must be larger than 0: $gpi_size"
	return 1
    fi

    local shm_size=$(get "api.compat.shm_size" "1G")
    get_user_input "shm memory size (per node) [$shm_size]:" shm_size
    parse_human_readable_size $shm_size shm_size
    if [ $shm_size -le 0 ] ; then
	log "E: size must be larger than 0: $shm_size"
	return 1
    fi

    local mem_size=$(( $gpi_size + $shm_size ))

    # try to get total memory size
    local total_mem=$( grep ^MemTotal: /proc/meminfo | awk '{print $2}')
    total_mem=$(( total_mem * 1024 ))
    if [ $mem_size -gt $total_mem ] ; then
	log "W: the sum of your specified memory sizes exceeds your available memory!"
	log "-:     max available: $total_mem"
	log "-:          gpi size: $gpi_size"
	log "-:          shm size: $shm_size"
	if ! y_n_p "Are you really sure to use these values?" ; then
	    return 1
	fi
    fi

    put "gpi.memory_size" "$gpi_size"
    put "api.compat.shm_size" "$shm_size"
    put "gpi.priv_dir" "$gpid_dir"

    put "gpi.api" $(get gpi.api "gpi.api.real")
    put "gpi.timeout" $(get gpi.timeout "30")
    put "gpi.socket_mode" $(get gpi.socket_mode "0700")
    put "gpi.mtu" $(get gpi.mtu "default")
    put "gpi.network_type" $(get gpi.network_type "default")
    put "gpi.port" $(get gpi.port "default")
    put "gpi.processes" $(get gpi.processes "-1")

    local sdpa_temp_dir=$(get "sdpa.temp_dir")
    local gpi_socket_path=$(get gpi.socket_path "$sdpa_temp_dir/gpi-space")
    put "gpi.socket_path" "$gpi_socket_path"
    if ! test -d "$gpi_socket_path" ; then
	if ! mkdir -p "$gpi_socket_path" ; then
	    log "E: failed to create gpi socket directory: $gpi_socket_path"
	    return 1
	fi
    fi
    chmod 1777 "$gpi_socket_path"

    put "gpi.socket_name" $(get gpi.socket_name "control")
}

function setup_client ()
{
    if ! test -e "$HOME/.sdpa/configs/sdpac.rc" ; then
	sdpac --make-config
    fi
}

function setup ()
{
    cat <<EOF
                 ================================
                 *          SDPA setup          *
                 ================================

Initiating the  setup routine of  SDPA. In case  of errors or  questions, please
contact 'Alexander Petry <petry@itwm.fhg.de>'.




EOF

    local real_config_file="$config_file"
    local temp_config_file="${config_file}~"

    local old_trap=$(trap -p EXIT)
    trap -- "rm -f $temp_config_file" EXIT

    local parts=$1
    if [ -z "$parts" ] ; then
	parts="state kvs scratch logging temp gui plugins gpi client"
    else
	shift
    fi

    if test -f "$real_config_file" ; then
	cp "$real_config_file" "$temp_config_file"
    fi
    config_file="$temp_config_file"

    local p
    for p in $parts ; do
	setup_$p $@ || { log "E: setup_$p failed!" ; return 1 ; }
    done

    put "config.version" "$CONFIG_VERSION"
    put "config.modified" "$(date)"

    cp "$real_config_file" "${real_config_file}.bak"
    mv "$temp_config_file" "$real_config_file"

    # putting config in place
    config_file="$real_config_file"
    eval $old_trap

    if test -L "$HOME/.sdpa/configs/gpi.rc" ; then
	:
    elif test -f "$HOME/.sdpa/configs/gpi.rc" ; then
	mv "$HOME/.sdpa/configs/gpi.rc" "$HOME/.sdpa/configs/gpi.rc.bak"
	log "I: created a backup of your old gpi.rc"
    fi
    ln -sf "$config_file" "$HOME/.sdpa/configs/gpi.rc"

    echo
    log "I: setup complete."
}

function generate_environment ()
{
    if ! on_master_node ; then
	log "E: cannot generate environment on slave node!"
	return 1
    fi

    echo export KVS_URL="$(hostname -s):2439"

    # read variables from config and write them to an environment file
    #     replacing init-screen.env in principle

    fhgcfg -f "$config_file" -l | while read key dummy val ; do
	case "$key" in
	    log.server.level)
		echo export FHGLOG_level="$val"
		;;
	    log.server.url)
		echo export FHGLOG_to_server="$val"
		;;
	    kvs.store)
		echo export KVS_STORE="$val"
		;;
	    kvs.url)
		echo export KVS_URL="$val"
		;;
	    gpi.priv_dir)
		echo export GPI_PRIV_DIR="$val"
		;;
	    sdpa.gui)
		echo export SDPA_GUI="$val"
		;;
	    sdpa.scratch_dir)
		echo export SDPA_SCRATCH_DIR="$val"
		;;
	    sdpa.temp_dir)
		echo export SDPA_TEMP_DIR="$val"
		;;
	    sdpa.log_dir)
		echo export SDPA_LOG_DIR="$val"
		;;
	    sdpa.state_dir)
		echo export SDPA_STATE_DIR="$val"
		;;
	    sdpa.node_file)
		echo export SDPA_NODEFILE="$val"
		;;
	    sdpa.home)
		local sdpa_home="$val"

		echo export SDPA_HOME="$sdpa_home"
		echo export SDPA_LIBEXEC="$sdpa_home/libexec"

		prepend_to_path PATH "$SDPA_HOME/bin"
		prepend_to_path PATH "$SDPA_HOME/bin/pbs"
		prepend_to_path PATH "$SDPA_HOME/bin/parsu"
		prepend_to_path LD_LIBRARY_PATH "$sdpa_home/lib"
		prepend_to_path LD_LIBRARY_PATH "$sdpa_home/libexec"
		prepend_to_path PC_LIBRARY_PATH "$sdpa_home/libexec"
		;;
	    *)
		;;
	esac
    done

    prepend_to_path LD_LIBRARY_PATH "$HOME/.sdpa/plugins"
    prepend_to_path PC_LIBRARY_PATH "$HOME/.sdpa/modules"
    prepend_to_path PC_LIBRARY_PATH "$HOME/.sdpa/plugins"

    echo export LD_LIBRARY_PATH="$LD_LIBRARY_PATH"
    echo export PC_LIBRARY_PATH="$PC_LIBRARY_PATH"
    echo export PATH="$PATH"
}

function dump_config ()
{
    fhgcfg -f "$config_file" -p
}

function initialize ()
{
    local node_file=$(get "sdpa.node_file" "$SDPA_NODEFILE")
    if [ -z "$PBS_NODEFILE" ] ; then
	log "E: PBS_NODEFILE is not set, please export it before and run init again"
	return 1
    fi

    if ! cp "$PBS_NODEFILE" "$node_file" ; then
	log "E: could not copy nodefile from $PBS_NODEFILE to $node_file"
	return 1
    fi

    local tmp_file="$state_dir/sdpa.env~"
    :> "$tmp_file"
    echo test -e "$state_dir/sdpa.pre.env" \&\& source "$state_dir/sdpa.pre.env" >> "$tmp_file"
    if ! generate_environment >> "$tmp_file" ; then
	return 1
    fi
    cat >>"$tmp_file" <<EOF
function log()
{
  echo "\$@" >&2
  test -x "\$SDPA_HOME/bin/fhglogc" && "\$SDPA_HOME/bin/fhglogc" -t "\$0" -p 2 -m "\$*"
}
EOF
    echo test -e "$state_dir/sdpa.post.env" \&\& source "$state_dir/sdpa.post.env" >> "$tmp_file"
    echo ":" >> "$tmp_file"

    local sdpa_home=$(get "sdpa.home" "$SDPA_HOME")
    if [ -z "$sdpa_home" ] ; then
	log "W: sdpa.home is not defined!"
    fi
    mv "$tmp_file" "$state_dir/sdpa.env"
}

function cleanup ()
{
    echo "cleaning up" >&2
    echo "  * logs" >&2
    clear-logs -f -a -x
    echo "  * backup files" >&2
    for f in "$HOME"/*.bkp *.bkp ; do
	if [ -e "$f" ] ; then
	    read -t 5 -n 1 -p "    remove $f? [y/N] " do_rm
	    case "$do_rm" in
		y|Y|j|J)
		    echo
		    rm -f "$f"
		    ;;
		*)
		    echo
		    ;;
	    esac
	fi
    done
    return 0
}

function help ()
{
    echo "usage: $0 {start|stop|status|setup|gui|cleanup|submit <file>}" >&2
    return 0
}

function start_log ()
{
    echo "  - fhglog (disabled)" >&2
    return 0
}

function is_proc_alive ()
{
    local name="$1" ; shift
    local pid="$1" ; shift

    if [ -z "$name" ] ; then
	echo "E: usage: is_proc_alive <binary> <pid>" >&2
	exit 42
    fi

    if [ -z "$pid" ] ; then
	return 1
    fi

    if grep -q "$name" /proc/$pid/cmdline >/dev/null 2>&1 ; then
	if kill -0 "$pid" >/dev/null 2>&1 ; then
	    return 0
	else
	    echo "E: $name: there seems to be an alien around!" >&2
	    echo "E:       cannot send signal to $pid" >&2
	    return 2 # not allowed to send signals!
	fi
    else
	return 1 # not there
    fi
}

function start_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    # check for old one
    local pid_file="$state_dir/$name.pid"
    local log_file="$SDPA_LOG_DIR/$name.log"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if is_proc_alive "$name" "$pid" ; then
	echo "  * $name ($pid)" >&2
    else
	:> "$pid_file"
	$binary $@ </dev/null >"$log_file" 2>&1 &
	pid=$!
	sleep 0.5
	if is_proc_alive "$name" "$pid" ; then
	    echo "  + $name ($pid)" >&2
	    echo "$pid" > "$pid_file"
	    disown -a
	    return 0
	else
	    echo "  - $name (dead)" >&2
	    return 1
	fi
    fi
}

function stop_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    local pid_file="$state_dir/$name.pid"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if [ -n "$pid" ] ; then
	echo -n "    sending SIGTERM to $name ($pid)..." >&2
	for (( i=0; i<3; ++i )); do
	    if is_proc_alive "$name" "$pid" ; then
		echo -n "."
		kill -TERM "$pid" >/dev/null 2>&1
		sleep 1
	    else
		:> "$pid_file"
		echo "ok" >&2
		break
	    fi
	done
    fi

    if is_proc_alive "$name" "$pid" ; then
	kill -KILL "$pid" >/dev/null 2>&1
	echo "killed" >&2
    else
	pkill "$name" >/dev/null 2>&1
	return 0
    fi
}

function start_kvs ()
{
    if ! start_proc "fhgkvsd" "fhgkvsd" "-C"; then
	echo "E: could not start kvs, giving up!" >&2
	return 1
    else
	sleep 1
	return 0
    fi
}

function stop_kvs ()
{
    echo "  * fhgkvsd"
    if ! stop_proc "fhgkvsd" "fhgkvsd" ; then
	echo "E: could not stop kvs!" >&2
	return 1
    fi
}

function start_orch ()
{
    if ! start_proc "orchestrator" "start-orch" ; then
	echo "E: could not start orchestrator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_orch ()
{
    echo "  * orchestrator"
    if ! stop_proc "orchestrator" "start-orch" ; then
	echo "E: could not stop orchestrator" >&2
	return 1
    fi
}

function start_agg ()
{
    if ! start_proc "aggregator" "start-agg" ; then
	echo "E: could not start aggregator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_agg ()
{
    echo "  * aggregator"
    if ! stop_proc "aggregator" "start-agg" ; then
	echo "E: could not stop aggregator" >&2
	return 1
    fi
}

function node_loop ()
{
    if [ ! -r "$SDPA_NODEFILE" ] ; then
	echo "Cannot read nodefile: $SDPA_NODEFILE" >&2
	return 1
    fi

    local body="$1" ; shift
    local nodes="$1" ; shift
    local node_max=$( uniq $SDPA_NODEFILE | wc -l )

    if [ -z "$nodes" ] ; then
	nodes=$( echo $( seq 1 $node_max ) )
    fi

    local rc=0
    local bunch_size=16
    local count=0
    local procs=
    local node_num
    local p
    for node_num in $nodes; do
	if test $node_num -lt 1 -o $node_num -gt $node_max ; then
	    echo "E: invalid node number: $node_num" >&2
	    rc=$(( rc + 1 ))
	    continue
	fi
	count=$(( count + 1 ))
	local node_name=$( uniq $SDPA_NODEFILE | tail -n +$node_num | head -n 1 )

	echo "    * executing $body $@ on $node_name" >&2
	local rank=$(( $node_num - 1 ))
	$body $node_name $rank $@ &
	procs="$procs $!"
	if [ $count -ge $bunch_size ] ; then
	    for p in $procs ; do
		wait $p
		rc=$(( rc + $? ))
	    done
	    procs=
	    count=0
	fi
    done
    for p in $procs ; do
	wait $p
	rc=$(( rc + $? ))
    done
    return $rc
}

function kill_pc ()
{
    if [ $# -ne 1 ] ; then
	echo "you have to specify a signal to send!" >&2
	return 1
    fi
    node_loop send_signal_to_pc "" $@
}

function send_signal_to_pc ()
{
    local node=$1 ; shift
    local rank=$1 ; shift
    local sig=$1 ; shift
    echo send-signal -n "nre-pcd" -s "$sig" | ssh -T -x "$node" 2>&1
    if [ $? -ne 0 ] ; then
	echo "could not send signal $sig to pc on node $node" >&2
	return 1
    else
	return 0
    fi
}

function start_pc ()
{
    sleep 1
    echo "  * process container" >&2
    node_loop start_pc_on_node $@
}

function start_pc_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift

    rm -f "$SDPA_LOG_DIR/pc.$node.log"
    echo start-pc -D -r $rank $@ | ssh -T -x "$node" >/dev/null 2>&1
    if [ $? -ne 0 ] ; then
	echo "pc did not startup on node $node: $output" >&2
	return 1
    else
	return 0
    fi
}

function start_nre ()
{
    sleep 1
    echo "  * nres" >&2
    node_loop start_nre_on_node $@
}

function start_nre_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift

    rm -f "$SDPA_LOG_DIR/nre.$node.log"
    echo start-nre -D $@ | ssh -T -x "$node" >/dev/null 2>&1
    if [ $? -ne 0 ] ; then
	echo "nre did not startup on node $node: $output" >&2
	return 1
    else
	return 0
    fi
}

function stop_pc_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift
    echo stop-pc -r $rank | ssh -T -x $node >/dev/null 2>&1
}

function stop_pc ()
{
    echo "  * process container" >&2
    node_loop stop_pc_on_node $@
}

function stop_nre_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift
    echo stop-nre -r $rank | ssh -T -x $node >/dev/null 2>&1
}

function stop_nre ()
{
    echo "  * nres" >&2
    node_loop stop_nre_on_node $@
}

function start_gui ()
{
    local log_url=$(get "log.server.url")
    local log_port=$(echo "$log_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$log_port" ] ; then
	log "E: log url ($log_url) does not contain a port!"
	return 1
    fi
    local log_host=$(echo "$log_url" | cut -d ':' -f 1)

    local gui_url=$(get "sdpa.gui")
    local gui_port=$(echo "$gui_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$gui_port" ] ; then
	log "E: gui url ($gui_url) does not contain a port!"
	return 1
    fi
    local gui_host=$(echo "$gui_url" | cut -d ':' -f 1)

    local cmd="start-gui $gui_port $log_port"
    if [ "$gui_host" != "$(hostname -f)" ] ; then
	log "W: gui-url ($gui_url) specifies a different host than your current host: $(hostname -f)"
	cmd="ssh -X $gui_host $cmd"
    fi

    if [ "$log_host" != "$gui_host" ] ; then
	log "E: cannot start gui on different hosts: $log_host vs. $gui_host"
	return 1
    fi

    log "I: starting gui with $cmd ..."
    $cmd &
}

function start_gpi ()
{
    if ! start_proc "gpi-space" "start-gpi" "-f" ; then
	echo "E: could not start GPI, giving up!" >&2
	return 1
    else
	sleep 5
	return 0
    fi
}

function stop_gpi ()
{
    echo "  * gpi"
    if ! stop_proc "gpi-space" "gpi-space" ; then
	echo "E: could not stop gpi" >&2
	return 1
    else
	return 0
    fi
}

function start ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
	parts="kvs gpi orch agg pc nre"
    else
	shift
    fi

    local p
    local rc=0
    for p in $parts ; do
	status $@ >/dev/null 2>&1
	if [ $? -eq 0 ] ; then
	    echo "W: $p still running!" >&2
	fi

	if ! start_$p $@ ; then
	    echo "Start of $p failed!" >&2
	    rc=$(( rc + 1 ))
	    break
	fi
    done
    return $rc
}

function stop ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
	parts="nre pc agg orch gpi kvs"
    else
	shift
    fi

    local p
    local rc=0
    for p in $parts ; do
	if ! stop_$p $@ ; then
	    rc=$(( rc + 1 ))
	fi
    done
    return $rc
}

function restart ()
{
    if stop $@ ; then
	start $@
    else
	echo "E: stop failed, not starting!" >&2
	return 1
    fi
}

function program_status ()
{
    local p=$1 ; shift
    local rc=0
    local pid_file="$state_dir/$p.pid"
    local pid=$( cat "$pid_file" 2>/dev/null)
    if [ -z "$pid" ] ; then
	pid=$(pidof "$p")
    fi

    if is_proc_alive "$p" "$pid" ; then
	return 0
    else
	return 1
    fi
}

function status_orch ()
{
    program_status "orchestrator"
}

function status_agg ()
{
    program_status "aggregator"
}

function status_nre_on_node ()
{
    local node=$1; shift
    local rank=$1; shift
    local pid=$( echo pidof nre | ssh -T -x $node 2>/dev/null )
    if [ -z "$pid" ] ; then
	return 1
    else
	return 0
    fi
}

function status_pc_on_node ()
{
    local node=$1; shift
    local rank=$1; shift
    local pid=$( echo pidof nre-pcd | ssh -T -x $node 2>/dev/null )
    if [ -z "$pid" ] ; then
	return 1
    else
	return 0
    fi
}

function status_nre ()
{
    node_loop status_nre_on_node $@ >/dev/null 2>&1
}

function status_pc ()
{
    node_loop status_pc_on_node $@ >/dev/null 2>&1
}

function status_kvs ()
{
    program_status "fhgkvsd"
}

function status_gpi ()
{
    program_status "gpi-space"
}

function status ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
      parts="kvs orch agg gpi nre pc"
    else
      shift
    fi

    # check system status
    local rc=0
    local p
    for p in $parts ; do
	echo -n "  $p is " >&2
	status_$p $@
	if [ $? -ne 0 ] ; then
	    echo "dead" >&2
	    rc=$(( rc + 1 ))
	else
	    echo "alive" >&2
	fi
    done
    return $rc
}

function cancel ()
{
    local jobs="$@"
    if [ -z "$jobs" ] ; then
	if test -e "$state_dir/current_job" ; then
	    jobs=$(cat "$state_dir/current_job")
	fi
    fi

    if [ -z "$jobs" ] ; then
	log "E: nothing to cancel"
	return 1
    fi

    for job in $jobs ; do
	echo -n "cancelling $job"
	sdpac cancel $job
	local err=$(sdpac cancel "$job" 2>&1)
	local ec=$?
	if [ $ec -ne 0 ] ; then
	    echo " failed: $ec: $err"
	else
	    echo " ok"
	fi
    done
}

function submit ()
{
    # check system health
    #    if not running:
    #       abort/ask
    #    else
    #       submit
    net="$1" ; shift
    if [ ! -r "$net" ] ; then
	echo "E: submit: cannot read file: $net" >&2
	return 42
    fi

    echo -n "checking system status..." >&2
    if ! status kvs >/dev/null 2>&1 || ! status orch >/dev/null 2>&1 ; then
	echo "dead" >&2
	read -t 15 -n 1 -p "Do you want me to start it? [Y/n] " do_start
	case "$do_start" in
	    n|N)
		return 1
		;;
	    *)
		echo
		if ! start ; then
		    echo "Could not start, please check the logs" >&2
		    return 3
		else
		    sleep 5
		fi
		;;
	esac
    else
	echo "ok" >&2
    fi

    echo "submitting file: $net" >&2
    jobid=$( sdpac submit "$net" 2>&1 )
    if [ $? -ne 0 ] ; then
	echo "Submission failed: $jobid"
	return 4
    else
	echo "  + job ($jobid)"
	echo "$jobid" > "$state_dir/current_job"
	sdpac wait "$jobid"
	s=$( sdpac status "${jobid}" )
	echo "$jobid -> $s" >&2
	if echo "$s" | grep -q -i 'finish' ; then
	    echo "Done." >&2
	    sdpac results "$jobid"
	fi
	sdpac delete "${jobid}"
	if [ $? -eq 0 ] ; then
	    echo "  - job ($jobid)"
	fi
    fi
}

function configure()
{
    test -e "$state_dir/sdpa.env" && source "$state_dir/sdpa.env"
}

function on_valid_host ()
{
    local host="$(hostname -s)"
    if test -r "$state_dir/nodefile" ; then
	if [ -n "$PBS_NODEFILE" ] ; then
	    if ! diff -q "$PBS_NODEFILE" "$state_dir/nodefile" >/dev/null ; then
		log "E: $PBS_NODEFILE and $state_dir/nodefile differ"
		return 1
	    fi
	fi
	if grep -q -e "$host" "$state_dir/nodefile" ; then
	    return 0
	else
	    log "E: your hostname ($host) does not match any in $state_dir/nodefile"
	fi
    else
	log "E: no nodefile present"
    fi
    return 1
}

function on_master_node ()
{
    local host="$(hostname -s)"
    if test -r "$state_dir/nodefile" ; then
	local master=$( head -n 1 "$state_dir/nodefile" )
	if [ "$host" = "$master" ] ; then
	    return 0
	fi
    else
	log "E: no nodefile present"
    fi
    return 1
}

function selftest ()
{
    log "I: performing self-test"

    local xml="$SDPA_HOME/share/sdpa/examples/selftest/selftest.xml"
    if ! test -r "$xml" ; then
	log "E: cannot read $xml"
	return 1
    fi

    local pnetc=$(which pnetc)
    if ! test -x "$pnetc" ; then
	log "E: cannot execute $pnetc"
	return 2
    fi

    local sdpac=$(which sdpac)
    if ! test -x "$sdpac" ; then
	log "E: cannot execute sdpac"
	return 3
    fi

    local pnetget=$(which pnetget)
    if ! test -x "$pnetget" ; then
	log "E: cannot execute pnetget"
	return 3
    fi

    if ! restart ; then
	stop
	log "E: restart failed"
	return 4
    fi

    local job_desc=$(mktemp)
    local old_trap=$(trap -p EXIT)
    trap -- "rm -f $job_desc" EXIT

    log "I: building job description..."
    if ! $pnetc "$xml" > "$job_desc" ; then
	log "E: could not generate job description"
	return 5
    fi

    log "I: submitting job..."
    local job_id=$(sdpac submit "$job_desc")
    log "I: JOB-ID: $job_id"

    local walltime=120
    log "I: waiting at most $walltime seconds for job to return..."
    local job_state=42
    for ((i=0 ; i < $walltime ; ++i)) ; do
	sleep 1
	local job_status=$(sdpac status "$job_id")
	if echo "$job_status" | grep -q -i -e 'finished' ; then
	    log "I: job has finished"
	    job_state=0
	    break
	elif echo "$job_status" | grep -q -i -e 'failed' ; then
	    log "E: job has failed"
	    job_state=1
	    break
	elif echo "$job_status" | grep -q -i -e 'cancelled' ; then
	    log "E: job has been cancelled"
	    job_state=2
	    break
	fi
    done

    if [ "$job_state" -eq 0 ] ; then
	log "I: retrieving results"
	if ! sdpac --force -o "$job_desc" results "$job_id" ; then
	    log "E: could not retrieve results"
	    rm "$job_desc"
	    stop
	    return 6
	fi

	if ! sdpac delete "$job_id" ; then
	    log "E: could not delete job"
	    rm "$job_desc"
	    stop
	    return 7
	fi
	local tokens=$(pnetget -i "$job_desc")
	log "I: result tokens: $tokens"
    else
	log "E: self test job could not be executed!"
	return 8
    fi

    rm "$job_desc"
    stop

    return 0
}

##########################################################
#                                                        #
#          S C R I P T     B E H A V I O R               #
#                                                        #
##########################################################

if setup_required ; then
    if setup ; then
	log "I: setup complete"
    else
	rc=$?
	log E: setup was unsuccessful: $rc
	exit $rc
    fi
fi

if [ "$1" = "init" ] ; then
    if ! initialize ; then
	log "E: could not initialize!"
	exit 1
    else
	log "I: please don't forget to execute \"eval \$(sdpa load)\""
	exit 0
    fi
fi

if ! on_valid_host ; then
    log "E: you are executing 'sdpa' on an invalid host"
    log "E: please run 'sdpa init' on the master node first!"
    exit 1
fi

if ! configure ; then
    log "E: configure() failed"
    exit $?
fi

case "$1" in
    start)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	start $@
	;;
    stop)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	stop $@
	;;
    restart)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	restart $@
	;;
    status)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	status $@
	;;
    cleanup)
	if status >/dev/null 2>&1 ; then
	    echo "E: still running!" >&2
	    exit 1
	else
	    cleanup
	fi
	;;
    cancel)
	shift
	cancel $@
	;;
    submit)
	shift
	submit $@
	;;
    setup)
	shift
	setup $@
	;;
    help)
	help
	;;
    gui)
	start_gui
	;;
    config)
	dump_config
	;;
    load)
	if test -f "$state_dir/sdpa.env" ; then
	    echo source "$state_dir/sdpa.env"\;
	fi
	;;
    unload)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	kill_pc HUP
	;;
    selftest)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	selftest
	;;
    '')
	help
	;;
    *)
	echo "E: unknown command: $1, try '$0 help'" >&2
	exit 1
	;;
esac
