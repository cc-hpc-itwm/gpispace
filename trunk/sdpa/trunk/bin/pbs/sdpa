#!/bin/bash
#
# usage: sdpa {start|stop|status|submit file}
#

# increment this value up to date if anything config related changes!
CONFIG_VERSION=3

#debug_enabled=true
config_file=${SDPA_CONFIG:="$HOME/.sdpa/configs/sdpa.rc"}
state_dir=${SDPA_STATE_DIR:="$HOME/.sdpa/state"}
debug_enabled=false

##############################################
#                                            #
#  F U N C T I O N    D E F I N I T I O N S  #
#                                            #
##############################################

function log_helper ()
{
    local fn="$1"; shift
    local ln="$1"; shift
    local file="$0"

    echo "$file:$ln - $@" >&2
    $SDPA_HOME/bin/fhglogc -L "$ln" -F "$file" -p 2 -m "$@"
}

do_log="eval log_helper \"\$FUNCNAME\" \"\$LINENO\""

function log ()
{
    echo "$@" >&2
}

function debug ()
{
    if [ x"$debug_enabled" == x"true" ] ; then
	echo $@ >&2
    fi
}

function get ()
{
    local key="$1"; shift
    local def="$1"; shift

    fhgcfg -f "$config_file" -g "$key" -v "$def"
}

function put ()
{
    local key="$1"; shift
    local val="$1"; shift

    fhgcfg -f "$config_file" -a "$key" -v "$val"
}

function rexec ()
{
    local node="$1"; shift
    local err
    local ssh_opts="-q -x -T -n -o CheckHostIP=no -o Ciphers=arcfour -o StrictHostKeyChecking=no"
    local cmd="ssh $ssh_opts $node $@"
    debug $cmd
    err=$($cmd 2>&1)
    local rc=$?
    if [ $rc -ne 0 ] ; then
	echo $err
	return $rc
    else
	echo $err
	return 0
    fi
}

function guess_head_node ()
{
    if [ -n "$PBS_O_HOST" ] ; then
	echo "$PBS_O_HOST"
    else
	echo "$(hostname -f)"
    fi
}

#
# check, if we have to start the setup routine
#
function setup_required ()
{
    if ! test -e "$config_file" ; then
      mkdir -p $(dirname "$config_file") 2>/dev/null
      touch "$config_file"
      return 0
    fi
    local cfg_version=$( get "config.version" "0" )
    if test "$cfg_version" -lt "$CONFIG_VERSION" ; then
	log "W: config is outdated"
	return 0
    fi
    return 1
}

function setup_state ()
{
    if [ ! -d "$state_dir" ] ; then
	local msg=$( mkdir -p "$state_dir" 2>&1 )
	if [ $? -ne 0 ] ; then
	    echo "E: failed to create state-dir: $state_dir: $msg" >&2
	    return 1
	fi
    fi

    local sdpa_home="$SDPA_HOME"
    if [ -z "$sdpa_home" ] ; then
	mydir=$(cd $(dirname $( which $0 )) && pwd)
	sdpa_home=$(dirname "$mydir")
    fi
    get_user_input "SDPA installation directory [$sdpa_home]:" sdpa_home

    export SDPA_HOME="$sdpa_home"

    #put "sdpa.home" "$sdpa_home"

    local node_file="$state_dir/nodefile"

    put "sdpa.node_file" "$node_file"
    log "I: node file configured to be stored in $node_file"

    put "sdpa.state_dir" "$state_dir"
    log "I: state directory configured to be in $state_dir"

    local data_dir="$HOME/.sdpa/data"
    if ! test -d "$data_dir" ; then
	if ! mkdir -p "$data_dir" ; then
	    log "E: failed to create data directory: $data_dir"
	    return 1
	fi
    fi

    if [ -n "$PBS_NODEFILE" ] ; then
        test -e ~/.sdpa/data/aux && rm -f ~/.sdpa/data/aux
        /bin/ln -sf $(dirname $PBS_NODEFILE) ~/.sdpa/data/aux
    else
        log "E: PBS_NODEFILE is empty, could not figure out where the aux directory should be!"
    fi

    return 0
}

function setup_kvs ()
{
    local kvs_data_dir="$HOME/.sdpa/data"
    if ! test -d "$kvs_data_dir" ; then
	if ! mkdir -p "$kvs_data_dir" ; then
	    log "E: failed to create kvs data directory: $kvs_data_dir"
	    return 1
	fi
    fi
    local kvs_store="$kvs_data_dir/kvs.dat"

    put "kvs.store" "$kvs_store"

    log "I: kvs configured to store data in $kvs_store"

    return 0
}

function y_n_p ()
{
    local prompt="$1" ; shift
    read -n 1 -p "$prompt [y/N] " yes_or_no
    case "$yes_or_no" in
	y|Y)
	    echo
	    return 0
	    ;;
	n|N)
	    echo
	    return 1
	    ;;
	?)
	    echo
	    return 2
	    ;;
	*)
	    return 2
	    ;;
    esac
}

function prepend_to_path ()
{
    local var="$1"; shift
    local val=$(eval echo \$${var})
    for v ; do
	val=$(echo "$val" | sed "s,:$v:,:,g")
	val=$(echo "$val" | sed -e "s,^$v:,,g")
	val=$(echo "$val" | sed -e "s,:$v\$,,g")
	val="$v:$val"
    done
    eval "$var=$val"
}

function append_to_path ()
{
    local var="$1"; shift
    local val=$(eval echo \$${var})
    for v ; do
	if ! echo "$val" | grep -q -- "$v" ; then
	    val="$val:$v"
	fi
    done
    eval "$var=$val"
}

function get_user_input ()
{
    local prompt="$1"; shift
    local var="$1"; shift
    local doc="$1"; shift
    if [ -n "$doc" ] ; then
	cat <<EOF
$doc
EOF
    fi
    read -e -p "  $prompt " new_val
    if [ -n "$new_val" ] ; then
	new_val=$(eval echo "$new_val")
	eval "$var=$new_val"
    fi
}

function setup_scratch ()
{
    local doc='

                 ================================
                 *       Scratch directory      *
                 ================================

The "scratch"  directory should be a directory  you are allowed to  write to and
that is shared among all nodes.
'

    local scratch_dir=$(get "sdpa.scratch_dir" "/scratch/$USER/sdpa")
    get_user_input "scratch directory to use [$scratch_dir]:" scratch_dir "$doc"

    if ! test -d "$scratch_dir" ; then
	if ! mkdir -p "$scratch_dir" ; then
	    log "E: failed to create scratch directory: $scratch_dir"
	    return 1
	fi
    fi

    put "sdpa.scratch_dir" "$scratch_dir"
    log "-: using scratch dir $scratch_dir"
}

function setup_logging ()
{
    local doc='

                 ================================
                 *     Logging Configuration    *
                 ================================

This "host:port" definition  defines where all the components  send log messages
to. It should be on the same host that you run the GUI on.
'
    local head_node=$(guess_head_node)

    local url=$(get "log.server.url" "${head_node}:$(( $(id -u) + 1024))")
    local prompt="remote logging to (host:port) [$url]:"
    get_user_input "$prompt" url "$doc"

    local lvl=$(get "log.server.level" "INFO")
    local prompt="log level [$lvl]:"
    get_user_input "log level to use [$lvl]:" lvl ""
    lvl=$( echo "$lvl" | tr [a-z] [A-Z] )

    local log_dir=$(get "sdpa.log_dir")
    if [ -z "$log_dir" ] ; then
	log_dir=$(get "sdpa.scratch_dir")/log
    fi
    get_user_input "log directory to use [$log_dir]:" log_dir ""

    if ! test -d "$log_dir" ; then
	if ! mkdir -p "$log_dir" ; then
	    log "E: failed to create log directory: $log_dir"
	    return 1
	fi
    fi

    put "log.server.url" "$url"
    put "log.server.level" "$lvl"
    put "sdpa.log_dir" "$log_dir"

    log "-: using log server at $url"
    log "-: using log level of $lvl"
    log "-: using log dir $log_dir"
}

function setup_temp ()
{
    local doc='

                 ================================
                 *     Node local directory     *
                 ================================

This  directory  should point  to  a  path that  is  local  to  each node,  like
/var/tmp. It is used to create local temporary files that might be necessary for
some components.
'
    local key="sdpa.temp_dir"
    local val=$(get "$key" "/var/tmp")
    local prompt="temporary directory to use [$val]:"
    get_user_input "$prompt" val "$doc"

    if ! test -d "$val" ; then
	if ! mkdir -p "$val" ; then
	    log "E: failed to create temporary directory: $val"
	    return 1
	fi
    fi

    put "$key" "$val"

    log "-: using node local directory $val"
}

function setup_gui ()
{
    local doc='

                 ================================
                 *   Graphical User Interface   *
                 ================================

Now I need a "host:port" string on which the graphical monitor interface will be
running.  It  does not  have to run  all the  time, but if  you want  to monitor
activities, I need to know that location. Please make sure that nobody else uses
this location.
'
    local head_node=$(guess_head_node)
    local key="sdpa.gui"
    local val=$(get "$key" "${head_node}:$(( $(id -u) + 1023))")
    local prompt="location of the monitor gui (host:port) [$val]:"
    get_user_input "$prompt" val "$doc"
    put "$key" "$val"

    log "-: using gui at $val"
}

function setup_plugins ()
{
    cat <<EOF

Setting up plugins....
EOF

    local mod_dir="$HOME/.sdpa/modules"
    if ! test -d "$mod_dir" ; then
	if ! mkdir -p "$mod_dir" ; then
	    log "E: failed to create modules directory: $mod_dir"
	    return 1
	fi
    fi

    local plugin_dir="$HOME/.sdpa/plugins/autoload"
    if ! test -d "$plugin_dir" ; then
	if ! mkdir -p "$plugin_dir" ; then
	    log "E: failed to create plugins directory: $plugin_dir"
	    return 1
	fi
    fi

    local prefix="$SDPA_HOME"
    if [ -z "$prefix" ] ; then
	log "E: SDPA_HOME is not defined!"
	return 1
    fi

    log "-: using SDPA plugins from $prefix"

    local count=0
    # fill in some autoload plugins
    for p in fvm-pc-compat sinc ; do
	local plugin="$prefix/libexec/lib${p}.so"
	if test -e "$plugin" ; then
	    local c=$( printf "%0.2d" $count )
	    local link="$plugin_dir/${c}${p}.so"
	    if ln -sf "$plugin" "$link" ; then
		log "I: autoloading plugin $p (from $plugin)"
	    fi
	    count=$(( count + 1 ))
	fi
    done

    log "-: setting up the DRTS"
    put "kernel.plugins" "gui,kvs,wfe,gpi,gpi-compat,drts"

    log "-: configuring plugins"
    put "plugin.gpi.startmode" "wait"
    put "plugin.drts.backlog" "2"
}

function setup_topology ()
{
    local doc='

                 ================================
                 *    Topology Configuration    *
                 ================================

This step asks  you some questions about the topology that  will be setup during
the start routine.

If you decide to run a mediator on each node, I will start a separate process on
every node that  takes care of the worker processes on  that node. Otherwise all
workers will be attached to a single master.

The number  of workers on each  node can either be  set to a fixed  number or to
zero. In case of a zero, I will start as many workers as there are processors.
'

    local key="topology.with-mediator"
    local val=$(get "$key" "yes")
    local prompt="Do you want to use a per-node mediator? [$val]:"
    get_user_input "$prompt" val "$doc"
    put "$key" "$val"

    local key="topology.per-node"
    local val=$(get "$key" "0")
    local prompt="How many workers shall I start on each node? [$val]:"
    get_user_input "$prompt" val ""
    sanity_val=$(( val + 0 ))
    put "$key" "$sanity_val"
}

function parse_human_readable_size ()
{
    local size_value="$1"; shift
    local var="$1"; shift
    size_value=$( echo "$size_value" | tr [a-z] [A-Z] )
    size_value=$( echo "$size_value" | sed -e 's/E$/*1024T/' )
    size_value=$( echo "$size_value" | sed -e 's/T$/*1024G/' )
    size_value=$( echo "$size_value" | sed -e 's/G$/*1024M/' )
    size_value=$( echo "$size_value" | sed -e 's/M$/*1024K/' )
    size_value=$( echo "$size_value" | sed -e 's/K$/*1024B/'  )
    size_value=$( echo "$size_value" | sed -e 's/B$/*1/'  )

    # compute the total and round to an integer
    size_value=$( echo "$size_value" | bc | xargs printf "%1.0f" )
    if [ -n "$var" ] ; then
	eval "$var=$size_value"
    else
	echo "$size_value"
    fi
}

function to_human_readable_size ()
{
    local size_value="$1"; shift
    local var="$1"; shift

    local new_val="1"
    local tmp=$( echo "$size_value > 1024" | bc )
    while test "$tmp" == "1" ; do
	new_val="$new_val*1024"
	size_value=$( echo "scale=2; $size_value/1024.0" | bc )
	tmp=$( echo "$size_value > 1024" | bc )
    done

    new_val=$( echo "$new_val" | sed -e 's/*1024$/K/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024K$/M/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024M$/G/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024G$/T/' )
    new_val=$( echo "$new_val" | sed -e 's/^1//')

    new_val="${size_value}${new_val}"
    if [ -n "$var" ] ; then
	eval "$var=$new_val"
    else
	echo "$new_val"
    fi
}

function setup_gpi ()
{
    local doc='

                 ================================
                 *        Fraunhofer GPI        *
                 ================================

This step configures  the GPI part of  the SDPA.  I will ask  for the privileged
directory from which user binaries are  allowed to be executed (the -p parameter
to the  gpid.exe). Additionally I will  ask for the  amount of GPI memory  to be
used on each node.

On  each   node,  so  called  process-containers  (worker   processes)  will  be
started.   Those  need   a  bit   of  memory   to  communicate   with   the  GPI
process. Depending on  how many workers you are planning to  use, you might have
to adjust the amount.

'
    local gpid_pid=$(ps -C gpid.exe -o pid= | tr -d ' ')
    local gpid_dir=$(cat /proc/$gpid_pid/cmdline 2>/dev/null | tr '\0' ' ' | grep -o -- '-p [^ ]*' | cut -d' ' -f 2)

    gpid_dir=$(get "gpi.priv_dir" "$gpid_dir")
    get_user_input "GPI privileged directory to use [$gpid_dir]:" gpid_dir "$doc"

    local gpi_size=$(get "gpi.memory_size" "5G")
    get_user_input "gpi memory size (per node) [$gpi_size]:" gpi_size
    parse_human_readable_size $gpi_size gpi_size
    if [ $gpi_size -le 0 ] ; then
	log "E: size must be larger than 0: $gpi_size"
	return 1
    fi

    local shm_size=$(get "plugin.gpi-compat.shm_size" "1G")
    get_user_input "shm memory size (per worker) [$shm_size]:" shm_size
    parse_human_readable_size $shm_size shm_size
    if [ $shm_size -le 0 ] ; then
	log "E: size must be larger than 0: $shm_size"
	return 1
    fi

    local com_size=$(get "plugin.gpi-compat.com_size" "16M")
    get_user_input "communication buffer size (per worker) [$com_size]:" com_size
    parse_human_readable_size $com_size com_size
    if [ $com_size -le 0 ] ; then
	log "E: size must be larger than 0: $com_size"
	return 1
    fi

    local mem_size=$(( $gpi_size + $shm_size + $com_size ))

    # try to get total memory size
    local total_mem=$( grep ^MemTotal: /proc/meminfo | awk '{print $2}')
    total_mem=$(( total_mem * 1024 ))
    if [ $mem_size -gt $total_mem ] ; then
	log "W: the sum of your specified memory sizes exceeds your available memory!"
	log "-:     max available: $total_mem"
	log "-:          gpi size: $gpi_size"
	log "-:          shm size: $shm_size"
	log "-:          com size: $com_size"
	if ! y_n_p "Are you really sure to use these values?" ; then
	    return 1
	fi
    fi

    put "gpi.memory_size" "$gpi_size"
    put "gpi.priv_dir" "$gpid_dir"
    put "plugin.gpi-compat.shm_size" "$shm_size"
    put "plugin.gpi-compat.com_size" "$com_size"

    put "gpi.enabled" $(get gpi.enabled "true")
    put "gpi.api" $(get gpi.api "gpi.api.real")
    put "gpi.timeout" $(get gpi.timeout "30")
    put "gpi.socket_mode" $(get gpi.socket_mode "0700")
    put "gpi.mtu" $(get gpi.mtu "default")
    put "gpi.network_type" $(get gpi.network_type "default")
    put "gpi.port" $(get gpi.port "default")
    put "gpi.processes" $(get gpi.processes "default")

    local sdpa_temp_dir=$(get "sdpa.temp_dir")
    local gpi_socket_path=$(get gpi.socket_path "$sdpa_temp_dir/gpi-space")
    put "gpi.socket_path" "$gpi_socket_path"
    if ! test -d "$gpi_socket_path" ; then
	if ! mkdir -p "$gpi_socket_path" ; then
	    log "E: failed to create gpi socket directory: $gpi_socket_path"
	    return 1
	else
	    if ! chmod 1777 "$gpi_socket_path" ; then
		log "E: failed to adjust mode on $gpi_socket_path"
		return 1
	    fi
	fi
    fi

    put "gpi.socket_name" $(get gpi.socket_name "control")
}

function setup_client ()
{
    if ! test -e "$HOME/.sdpa/configs/sdpac.rc" ; then
	touch "$HOME/.sdpa/configs/sdpac.rc"
    fi
}

function setup ()
{
    cat <<EOF
                 ================================
                 *          SDPA setup          *
                 ================================

Initiating the  setup routine of  SDPA. In case  of errors or  questions, please
contact 'Alexander Petry <petry@itwm.fhg.de>'.




EOF
    if ! test -e "$config_file" ; then
      mkdir -p $(dirname "$config_file") 2>/dev/null
      touch "$config_file"
    fi

    local real_config_file="$config_file"
    local temp_config_file="${config_file}~"

    local old_trap=$(trap -p EXIT)
    trap -- "rm -f $temp_config_file" EXIT

    local parts=$1
    if [ -z "$parts" ] ; then
	parts="state kvs scratch logging temp gui plugins gpi client topology"
    else
	shift
    fi

    if test -f "$real_config_file" ; then
	cp "$real_config_file" "$temp_config_file"
    fi
    config_file="$temp_config_file"

    local p
    for p in $parts ; do
	setup_$p $@ || { log "E: setup_$p failed!" ; return 1 ; }
    done

    put "config.version" "$CONFIG_VERSION"
    put "config.modified" "$(date)"

    cp "$real_config_file" "${real_config_file}.bak"
    mv "$temp_config_file" "$real_config_file"

    # putting config in place
    config_file="$real_config_file"
    eval $old_trap

    if test -L "$HOME/.sdpa/configs/gpi.rc" ; then
	:
    elif test -f "$HOME/.sdpa/configs/gpi.rc" ; then
	mv "$HOME/.sdpa/configs/gpi.rc" "$HOME/.sdpa/configs/gpi.rc.bak"
	log "I: created a backup of your old gpi.rc"
    fi
    ln -sf "$config_file" "$HOME/.sdpa/configs/gpi.rc"

    echo
    log "I: setup complete."
}

function generate_environment ()
{
    if ! on_master_node ; then
	log "E: cannot generate environment on slave node!"
	return 1
    fi

    echo export KVS_URL="$(hostname -s):2439"

    # read variables from config and write them to an environment file
    #     replacing init-screen.env in principle



    fhgcfg -f "$config_file" -l | while read key dummy val ; do
	case "$key" in
	    log.server.level)
		echo export FHGLOG_level="$val"
		;;
	    log.server.url)
		echo export FHGLOG_to_server="$val"
		;;
	    kvs.store)
		echo export KVS_STORE="$val"
		;;
	    kvs.url)
		echo export KVS_URL="$val"
		;;
	    gpi.priv_dir)
		echo export GPI_PRIV_DIR="$val"
		;;
	    sdpa.gui)
		echo export SDPA_GUI="$val"
		;;
	    sdpa.scratch_dir)
		echo export SDPA_SCRATCH_DIR="$val"
		;;
	    sdpa.temp_dir)
		echo export SDPA_TEMP_DIR="$val"
		;;
	    sdpa.log_dir)
		echo export SDPA_LOG_DIR="$val"
		;;
	    sdpa.state_dir)
		echo export SDPA_STATE_DIR="$val"
		;;
	    sdpa.node_file)
		echo export SDPA_NODEFILE="$val"
		;;
	    sdpa.home)
		;;
	    *)
		;;
	esac
    done

    if [ -z "$SDPA_HOME" ] ; then
	mydir="$(cd $(dirname $( which $0 )) && pwd)"
	export SDPA_HOME=$(dirname "$mydir")
    else
	# sanitize HOME
	export SDPA_HOME="$(echo $SDPA_HOME | sed -e 's,/\+$,,')"
    fi
    export SDPA_LIBEXEC="$SDPA_HOME/libexec"

    echo export SDPA_HOME="$SDPA_HOME"
    echo export SDPA_LIBEXEC="$SDPA_HOME/libexec"

    echo "path = $PATH" >&2

    prepend_to_path PATH "$SDPA_HOME/bin"

    echo "path = $PATH" >&2

    prepend_to_path PATH "$SDPA_HOME/bin/pbs"

    echo "path = $PATH" >&2

    prepend_to_path PATH "$SDPA_HOME/bin/parsu"

    echo "path = $PATH" >&2

    prepend_to_path LD_LIBRARY_PATH "$SDPA_HOME/lib"
    prepend_to_path LD_LIBRARY_PATH "$SDPA_HOME/libexec"
    prepend_to_path PC_LIBRARY_PATH "$SDPA_HOME/libexec"

    prepend_to_path LD_LIBRARY_PATH "$HOME/.sdpa/plugins"

    for f in $( find "$SDPA_LIBEXEC/apps" -type f -name "*.so" ) ; do
	app_module_dir=$(dirname "$f")
	prepend_to_path PC_LIBRARY_PATH "$app_module_dir"
    done
    prepend_to_path PC_LIBRARY_PATH "$HOME/.sdpa/modules"
    prepend_to_path PC_LIBRARY_PATH "$HOME/.sdpa/plugins"

    echo export LD_LIBRARY_PATH="$LD_LIBRARY_PATH"
    echo export PC_LIBRARY_PATH="$PC_LIBRARY_PATH"
    echo export PATH="$PATH"
}

function dump_config ()
{
    fhgcfg -f "$config_file" -p
}

function initialize ()
{
    local node_file=$(get "sdpa.node_file" "$SDPA_NODEFILE")
    if [ -z "$PBS_NODEFILE" ] ; then
	log "E: PBS_NODEFILE is not set, please export it before and run init again"
	return 1
    fi

    if ! cp "$PBS_NODEFILE" "$node_file" ; then
	log "E: could not copy nodefile from $PBS_NODEFILE to $node_file"
	return 1
    fi

    local tmp_file="$state_dir/sdpa.env~"
    :> "$tmp_file"
    echo test -e "$state_dir/sdpa.pre.env" \&\& source "$state_dir/sdpa.pre.env" >> "$tmp_file"
    if ! generate_environment >> "$tmp_file" ; then
	log "E: could not generate environment"
	return 1
    fi
    cat >>"$tmp_file" <<EOF
function log()
{
  echo "\$@" >&2
  test -x "\$SDPA_HOME/bin/fhglogc" && "\$SDPA_HOME/bin/fhglogc" -t "\$0" -p 2 -m "\$*"
}
EOF
    echo test -e "$state_dir/sdpa.post.env" \&\& source "$state_dir/sdpa.post.env" >> "$tmp_file"
    echo ":" >> "$tmp_file"

    local sdpa_home="$SDPA_HOME"
    if [ -z "$sdpa_home" ] ; then
	log "E: SDPA_HOME is not defined!"
    fi
    mv "$tmp_file" "$state_dir/sdpa.env"
}

function cleanup ()
{
    echo "cleaning up" >&2
    echo "  * logs" >&2
    clear-logs -f -a -x
    echo "  * backup files" >&2
    for f in "$HOME"/*.bkp *.bkp ; do
	if [ -e "$f" ] ; then
	    read -t 5 -n 1 -p "    remove $f? [y/N] " do_rm
	    case "$do_rm" in
		y|Y|j|J)
		    echo
		    rm -f "$f"
		    ;;
		*)
		    echo
		    ;;
	    esac
	fi
    done
    return 0
}

function help ()
{
    cat >&2 <<EOF
usage: `basename $0` command [parameters...]

   available commands:
        setup       - setup SDPA
        init        - initialize environment file
                      execute this in a a fresh allocation
        load        - print instructions to load
                      the environment file: eval \$(sdpa load)
     selftest       - perform a self-test
       config       - dump the current config

  start [component] - start all components or "component"
   stop [component] - stop all components or "component"
restart [component] - restart all components or "component"
 status [component] - get the current status of component
                gui - start the GUI

      submit <file> - submit a job
 cancel [job-id...] - cancel the given job or the current job
     unload-modules - unload modules in the process containers

EOF
    return 0
}

function start_log ()
{
    echo "  - fhglog (disabled)" >&2
    return 0
}

function is_proc_alive ()
{
    local name="$1" ; shift
    local pid="$1" ; shift

    if [ -z "$name" ] ; then
	echo "E: usage: is_proc_alive <binary> <pid>" >&2
	exit 42
    fi

    if [ -z "$pid" ] ; then
	return 1
    fi

    if grep -q "$name" /proc/$pid/cmdline >/dev/null 2>&1 ; then
	if kill -0 "$pid" >/dev/null 2>&1 ; then
	    return 0
	else
	    echo "E: $name: there seems to be an alien around!" >&2
	    echo "E:       cannot send signal to $pid" >&2
	    return 2 # not allowed to send signals!
	fi
    else
	return 1 # not there
    fi
}

function start_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    # check for old one
    local pid_file="$state_dir/$name.pid"
    local log_file="$SDPA_LOG_DIR/$name.log"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if is_proc_alive "$name" "$pid" ; then
	echo "* $name ($pid)" >&2
    else
	:> "$pid_file"
	debug $binary $@
	$binary $@ </dev/null >"$log_file" 2>&1 &
	pid=$!
	for (( i = 0 ; i < 3 ; ++i )) ; do
	    sleep 0.5
	    if is_proc_alive "$name" "$pid" ; then
		echo "+ $name ($pid)" >&2
		echo "$pid" > "$pid_file"
		disown -a
		return 0
	    fi
	done
	echo "- $name (dead)" >&2
	return 1
    fi
}

function stop_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    local pid_file="$state_dir/$name.pid"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if [ -n "$pid" ] ; then
	echo -n "    sending SIGTERM to $name ($pid)..." >&2
	for (( i=0; i<3; ++i )); do
	    if is_proc_alive "$name" "$pid" ; then
		echo -n "."
		kill -TERM "$pid" >/dev/null 2>&1
		sleep 1
	    else
		:> "$pid_file"
		echo "ok" >&2
		break
	    fi
	done
    fi

    if is_proc_alive "$name" "$pid" ; then
	kill -KILL "$pid" >/dev/null 2>&1
	echo "killed" >&2
    else
	pkill "$name" >/dev/null 2>&1
	return 0
    fi
}

function start_agent ()
{
    local name="$1" ; shift
    local master="$1" ; shift

    if [ -z "$name" ] ; then
	echo "E: start_agent(): no name given!" >&2
	return 1
    fi

    if [ -z "$master" ] ; then
	echo "E: start_agent(): no master given!" >&2
	return 1
    fi

    # name format: name[-node]
    local node="$(echo $name | cut -d- -f 2)"
    if [ "$node" == "$name" ] ; then
	node=localhost
    fi

    local cmd="rexec $node $SDPA_HOME/bin/start-agent -D -n $name -m $master -f"
    debug $cmd
    $cmd </dev/null >"$SDPA_LOG_DIR/$name.log" 2>&1
    if [ $? -eq 0 ] ; then
	echo "+ $name" >&2
    else
	echo "- $name" >&2
    fi
}

function stop_agent ()
{
    local name="$1" ; shift

    # name format: name[-node[-id]]
    local node="$(echo $name | cut -d- -f 2)"
    if [ "$node" == "$name" ] ; then
	node=localhost # maybe we should use the master node?
    fi
    local cmd="rexec $node $SDPA_HOME/bin/stop-agent -n $name"
    debug $cmd
    $cmd </dev/null >/dev/null 2>&1 &
}

function status_agent ()
{
    local name="$1" ; shift

    local node="$(echo $name | cut -d- -f 2)"
    if [ "$node" == "$name" ] ; then
	node=localhost # maybe we should use the master node?
    fi

    local cmd="rexec $node $SDPA_HOME/bin/status-agent -n $name"
    debug $cmd
    $cmd </dev/null >/dev/null 2>&1
}

function start_kvs ()
{
    if ! start_proc "fhgkvsd" "fhgkvsd" "-C -b 0 -p 2439"; then
	echo "E: could not start kvs, giving up!" >&2
	return 1
    else
	sleep 1
	return 0
    fi
}

function stop_kvs ()
{
    echo "* fhgkvsd"
    if ! stop_proc "fhgkvsd" "fhgkvsd" ; then
	echo "E: could not stop kvs!" >&2
	return 1
    fi
}

function start_orch ()
{
    if ! start_proc "orchestrator" "start-orch" ; then
	echo "E: could not start orchestrator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_orch ()
{
    echo "* orchestrator"
    if ! stop_proc "orchestrator" "start-orch" ; then
	echo "E: could not stop orchestrator" >&2
	return 1
    fi
}

function start_agg ()
{
    if ! start_agent "aggregator" "orchestrator" ; then
	echo "E: could not start aggregator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_agg ()
{
    echo "* aggregator"
    if ! stop_agent "aggregator" ; then
	echo "E: could not stop aggregator" >&2
	return 1
    fi
}

function node_loop ()
{
    if [ ! -r "$SDPA_NODEFILE" ] ; then
	echo "Cannot read nodefile: $SDPA_NODEFILE" >&2
	return 1
    fi

    local body="$1" ; shift
    local nodes="$1" ; shift
    local node_max=$( uniq $SDPA_NODEFILE | wc -l )

    if [ -z "$nodes" ] ; then
	nodes=$( echo $( seq 1 $node_max ) )
    fi

    local rc=0
    local bunch_size=16
    local count=0
    local procs=
    local node_num
    local p
    for node_num in $nodes; do
	if test $node_num -lt 1 -o $node_num -gt $node_max ; then
	    echo "E: invalid node number: $node_num" >&2
	    rc=$(( rc + 1 ))
	    continue
	fi
	count=$(( count + 1 ))
	local node_name=$( uniq $SDPA_NODEFILE | tail -n +$node_num | head -n 1 )

	echo "    * executing $body $@ on $node_name" >&2
	$body $node_name $@ &
	procs="$procs $!"
	if [ $count -ge $bunch_size ] ; then
	    for p in $procs ; do
		wait $p
		rc=$(( rc + $? ))
	    done
	    procs=
	    count=0
	fi
    done
    for p in $procs ; do
	wait $p
	rc=$(( rc + $? ))
    done
    return $rc
}

function kill_pc ()
{
    if [ $# -ne 1 ] ; then
	echo "you have to specify a signal to send!" >&2
	return 1
    fi
    node_loop send_signal_to_pc "" $@
}

function send_signal_to_pc ()
{
    local node=$1 ; shift
    local sig=$1 ; shift
    local err=$(rexec "$node" "$SDPA_HOME/bin/send-signal" -n "nre-pcd" -s "$sig")
    ec=$?
    if [ $ec -ne 0 ] ; then
	log "E: could not send signal $sig to pc on node $node: $err"
	return 1
    else
	return 0
    fi
}

function start_nre ()
{
    local with_mediator=$(get "topology.with-mediator" "true")
    if [ x"$with_mediator" == x"true" ] ; then
	log "* nres" >&2
	node_loop start_nre_on_node $@
    else
	log "* nres (deactivated)" >&2
    fi
}

function stop_nre ()
{
    log "* nres" >&2
#    local with_mediator=$(get "topology.with-mediator" "true")
#    if [ x"$with_mediator" == x"true" ] ; then
    node_loop stop_nre_on_node $@
#    else
#	log "      * deactivated" >&2
#    fi
}

function status_nre ()
{
    local err
    local ec

    local with_mediator=$(get "topology.with-mediator" "true")
    if [ x"$with_mediator" == x"true" ] ; then
	err=$(node_loop status_nre_on_node $@ 2>&1)
	ec=$?
    else
	ec=255
    fi
    return $ec
}

function start_nre_on_node ()
{
    local node=$1 ; shift

    if ! start_agent "nre-$node" "aggregator" $@ ; then
	log "E: could not start nre on $node!" >&2
	return 1
    else
	return 0
    fi
}

function stop_nre_on_node ()
{
    local node=$1 ; shift
    local err
    local ec
    err=$(rexec "$node" "$SDPA_HOME/bin/stop-agent" -n "nre-$node")
    ec=$?
    if [ $ec -ne 0 ] ; then
	log "W: stop-nre on node $node failed: $ec: $err"
    fi
    return $ec
}

function status_nre_on_node ()
{
    local node=$1; shift
    local pid
    status_agent "nre-$node"
    return $?
}

function start_drts ()
{
    echo "* process container" >&2
    node_loop start_drts_on_node $@
}

function stop_drts ()
{
    log "* process container" >&2
    node_loop stop_drts_on_node $@
}

function status_drts ()
{
    local err
    local ec
    err=$(node_loop status_drts_on_node $@ 2>&1)
    if [ $? -ne 0 ] ; then
	return 1
    else
	return 0
    fi
}

function start_drts_on_node ()
{
    local node=$1 ; shift
    local master="$1" ; shift
    if [ -z "$master" ] ; then
	master="aggregator"
    fi

    local with_mediator=$(get "topology.with-mediator" "true")
    if [ x"$with_mediator" == x"true" ] ; then
	master="nre-$node"
    fi

    local per_node=$(get "topology.per-node" "0")
    local err=$(rexec "$node" "$SDPA_HOME/bin/start-drts" -m "$master" -c "$per_node" $@)
    if [ $? -ne 0 ] ; then
	log "E: pc did not startup on node $node: $err" >&2
	return 1
    else
	return 0
    fi
}

function stop_drts_on_node ()
{
    local node=$1 ; shift
    local err
    local ec
    err=$(rexec "$node" "$SDPA_HOME/bin/stop-drts")
    ec=$?
    if [ $ec -ne 0 ] ; then
	log "W: stop-drts on node $node failed: $ec: $err"
    fi
    return $ec
}

function status_drts_on_node ()
{
    local node="$1"; shift
    local name="$1"; shift
    local pids
    pids=$(rexec $node "$SDPA_HOME/bin/status-drts" -s -n "$name")
    return $?
}

function start_gui ()
{
    local log_url=$(get "log.server.url")
    local log_port=$(echo "$log_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$log_port" ] ; then
	log "E: log url ($log_url) does not contain a port!"
	return 1
    fi
    local log_host=$(echo "$log_url" | cut -d ':' -f 1)

    local gui_url=$(get "sdpa.gui")
    local gui_port=$(echo "$gui_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$gui_port" ] ; then
	log "E: gui url ($gui_url) does not contain a port!"
	return 1
    fi
    local gui_host=$(echo "$gui_url" | cut -d ':' -f 1)

    local cmd="$SDPA_HOME/bin/start-gui $gui_port $log_port"
    if [ "$gui_host" != "$(hostname -f)" ] ; then
	log "W: gui-url ($gui_url) specifies a different host than your current host: $(hostname -f)"
	cmd="ssh -X $gui_host $cmd"
    fi

    if [ "$log_host" != "$gui_host" ] ; then
	log "E: cannot start gui on different hosts: $log_host vs. $gui_host"
	return 1
    fi

    log "I: starting gui with $cmd ..."
    $cmd &
}

function start_gpi ()
{
    local gpi_enabled=$(get "gpi.enabled" "true")
    if [ x"$gpi_enabled" == x"true" ] ; then
	if ! start_proc "gpi-space" "start-gpi" "-f" ; then
	    log "E: could not start GPI, giving up!"
	    return 1
	else
	    sleep 5
	    return 0
	fi
    else
	log "* gpi (deactivated)" >&2
    fi
}

function stop_gpi ()
{
    log "* gpi"
    if ! stop_proc "gpi-space" "gpi-space" ; then
	log "E: could not stop gpi"
	return 1
    else
	return 0
    fi
}

function start ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
	parts="kvs gpi orch agg nre drts"
    else
	shift
    fi

    local p
    local rc=0
    for p in $parts ; do
	status_$p $@ >/dev/null 2>&1
	if [ $? -eq 0 ] ; then
	    log "* $p"
	    continue
	fi

	if ! start_$p $@ ; then
	    log "Start of $p failed!"
	    rc=$(( rc + 1 ))
	    break
	fi
    done
    return $rc
}

function stop ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
	parts="drts nre agg orch gpi kvs"
    else
	shift
    fi

    local p
    local rc=0
    for p in $parts ; do
	if ! stop_$p $@ ; then
	    rc=$(( rc + 1 ))
	fi
    done
    return $rc
}

function restart ()
{
    if stop $@ ; then
	start $@
    else
	log "E: stop failed, not starting!"
	return 1
    fi
}

function program_status ()
{
    local p=$1 ; shift
    local rc=0
    local pid
    pid=$(pidof "$p")

    if is_proc_alive "$p" "$pid" ; then
	return 0
    else
	return 1
    fi
}

function status_orch ()
{
    program_status "orchestrator"
}

function status_agg ()
{
    status_agent "aggregator"
}

function status_kvs ()
{
    program_status "fhgkvsd"
}

function status_gpi ()
{
    local ec=0
    local gpi_enabled=$(get "gpi.enabled" "true")
    if [ x"$gpi_enabled" == x"true" ] ; then
	program_status "gpi-space"
	ec=$?
    else
	ec=255
    fi
    return $ec
}

function status ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
      parts="kvs orch agg gpi nre drts"
    else
      shift
    fi

    # check system status
    local rc=0
    local p
    local err
    for p in $parts ; do
	local cmd
	cmd="status_$p"
	if type "$cmd" >/dev/null 2>&1 ; then
	    err=$(status_$p $@)
	    ec=$?
	    if [ $ec -eq 0 ] ; then
		log "$p is alive"
	    elif [ $ec -eq 255 ] ; then
		log "$p is deactivated"
	    else
		if [ -z "$err" ] ; then
		    log "$p is dead"
		else
		    log "$p is dead: $err"
		fi
		rc=$(( rc + 1 ))
	    fi
	else
	    sdpac status $p
	fi
    done
    return $rc
}

function cancel ()
{
    local jobs="$@"
    if [ -z "$jobs" ] ; then
	if test -e "$state_dir/current_job" ; then
	    jobs=$(cat "$state_dir/current_job")
	fi
    fi

    if [ -z "$jobs" ] ; then
	log "E: nothing to cancel"
	return 1
    fi

    local err
    for job in $jobs ; do
	log "I: cancelling job $job"
	err=$(sdpac cancel "$job" 2>&1)
	local ec=$?
	if [ $ec -ne 0 ] ; then
	    log "E: failed: $ec: $err"
	fi
    done
}

function submit ()
{
    # check system health
    #    if not running:
    #       abort/ask
    #    else
    #       submit
    local net="$1" ; shift
    if [ ! -r "$net" ] ; then
	log "E: submit: cannot read file: $net"
	return 42
    fi

    log "I: checking system status..."
    if ! status kvs >/dev/null 2>&1 || ! status orch >/dev/null 2>&1 ; then
	log "W: system not completely up and running"
	read -t 15 -n 1 -p "Do you want me to start it? [Y/n] " do_start
	case "$do_start" in
	    n|N)
		return 1
		;;
	    *)
		echo
		if ! start ; then
		    log "E: could not start, please check the logs"
		    return 3
		else
		    sleep 5
		fi
		;;
	esac
    fi

    log "I: submitting file: $net"
    jobid=$( sdpac submit "$net" 2>&1 )
    if [ $? -ne 0 ] ; then
	log "E: submission failed: $jobid"
	return 4
    else
	log "  + job ($jobid)"
	echo "$jobid" > "$state_dir/current_job"
	sdpac wait "$jobid"
	s=$(sdpac status "${jobid}")
	log "    $jobid -> $s"
	s=$(echo "$s" | tr [A-Z] [a-z])
	case "$s" in
	    *finish*)
		log "I: job finished"
		;;
	    *fail*)
		log "E: job faiiled"
		;;
	    *cancel*)
		log "E: job cancelled"
		;;
	    *)
		log "W: unknown state: $s"
		;;
	esac
	sdpac results "$jobid"
	sdpac delete "${jobid}"
	if [ $? -eq 0 ] ; then
	    echo "  - job ($jobid)"
	fi
    fi
}

function configure()
{
    test -e "$state_dir/sdpa.env" && source "$state_dir/sdpa.env"
    # write the kvs url to a file
    echo "$KVS_URL" > "$state_dir/kvs.url"
}

function on_valid_host ()
{
    local host="$(hostname -s)"
    if test -r "$state_dir/nodefile" ; then
	if [ -n "$PBS_NODEFILE" ] ; then
	    if ! diff -q "$PBS_NODEFILE" "$state_dir/nodefile" >/dev/null ; then
		log "E: $PBS_NODEFILE and $state_dir/nodefile differ"
		return 1
	    fi
	fi
	if grep -q -e "$host" "$state_dir/nodefile" ; then
	    return 0
	else
	    log "E: your hostname ($host) does not match any in $state_dir/nodefile"
	fi
    else
	log "E: no nodefile present"
    fi
    return 1
}

function on_master_node ()
{
    local host="$(hostname -s)"
    if test -r "$state_dir/nodefile" ; then
	local master=$( head -n 1 "$state_dir/nodefile" )
	if [ "$host" = "$master" ] ; then
	    return 0
	fi
    else
	log "E: no nodefile present"
    fi
    return 1
}

function selftest ()
{
    log "I: performing self-test"

    local xml="$SDPA_HOME/share/sdpa/examples/selftest/selftest.xml"
    if ! test -r "$xml" ; then
	log "E: cannot read $xml"
	return 1
    fi

    local pnetc=$(which pnetc)
    if ! test -x "$pnetc" ; then
	log "E: cannot execute $pnetc"
	return 2
    fi

    local sdpac=$(which sdpac)
    if ! test -x "$sdpac" ; then
	log "E: cannot execute sdpac"
	return 3
    fi

    local pnetget=$(which pnetget)
    if ! test -x "$pnetget" ; then
	log "E: cannot execute pnetget"
	return 3
    fi

    if ! restart ; then
	stop
	log "E: restart failed"
	return 4
    fi

    local job_desc=$(mktemp)
    local old_trap=$(trap -p EXIT)
    trap -- "rm -f $job_desc" EXIT

    log "I: building job description..."
    if ! $pnetc "$xml" > "$job_desc" ; then
	log "E: could not generate job description"
	return 5
    fi

    log "I: submitting job..."
    local job_id=$(sdpac submit "$job_desc")
    log "I: JOB-ID: $job_id"

    local walltime=120
    log "I: waiting at most $walltime seconds for job to return..."
    local job_state=42
    for ((i=0 ; i < $walltime ; ++i)) ; do
	sleep 1
	local job_status=$(sdpac status "$job_id")
	if echo "$job_status" | grep -q -i -e 'finished' ; then
	    log "I: job has finished"
	    job_state=0
	    break
	elif echo "$job_status" | grep -q -i -e 'failed' ; then
	    log "E: job has failed"
	    job_state=1
	    break
	elif echo "$job_status" | grep -q -i -e 'cancelled' ; then
	    log "E: job has been cancelled"
	    job_state=2
	    break
	fi
    done

    if [ "$job_state" -eq 0 ] ; then
	log "I: retrieving results"
	if ! sdpac --force -o "$job_desc" results "$job_id" ; then
	    log "E: could not retrieve results"
	    rm "$job_desc"
	    stop
	    return 6
	fi

	if ! sdpac delete "$job_id" ; then
	    log "E: could not delete job"
	    rm "$job_desc"
	    stop
	    return 7
	fi
	local tokens=$(pnetget -i "$job_desc")
	log "I: result tokens:"
	log $(pnetget < "$job_desc" --type=output)
    else
	log "E: self test job could not be executed!"
	return 8
    fi

    rm "$job_desc"
    stop

    return 0
}

##########################################################
#                                                        #
#          S C R I P T     B E H A V I O R               #
#                                                        #
##########################################################

if [ "$1" = "help" ] ; then
    shift
    help $@
    exit $?
fi

if [ "$1" = "version" ] ; then
    shift
    sdpac --version
    exit $?
fi

if [ "$1" = "setup" ] ; then
    shift
    setup $@
    exit $?
fi

if setup_required ; then
    if setup ; then
	log "I: setup complete"
    else
	rc=$?
	log E: setup was unsuccessful: $rc
	exit $rc
    fi
fi

if [ "$1" = "init" ] ; then
    shift
    if ! initialize $@; then
	log "E: could not initialize!"
	exit 1
    else
	log "I: please don't forget to execute \"eval \$(sdpa load)\""
	exit 0
    fi
fi

if [ "$1" = "gui" ] ; then
    start_gui
    exit $?
fi

if ! on_valid_host ; then
    log "E: you are executing 'sdpa' on an invalid host"
    log "E: please run 'sdpa init' on the master node first!"
    exit 1
fi

if ! configure ; then
    log "E: configure() failed"
    exit $?
fi

case "$1" in
    start)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	start $@
	;;
    stop)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	stop $@
	;;
    restart)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	restart $@
	;;
    status)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	status $@
	;;
    cleanup)
	if status >/dev/null 2>&1 ; then
	    echo "E: still running!" >&2
	    exit 1
	else
	    cleanup
	fi
	;;
    cancel)
	shift
	cancel $@
	;;
    submit)
	shift
	submit $@
	;;
    help)
	help
	;;
    gui)
	start_gui
	;;
    config)
	dump_config
	;;
    load)
	if test -f "$state_dir/sdpa.env" ; then
	    echo source "$state_dir/sdpa.env"\;
	fi
	;;
    unload-modules)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	shift
	restart drts
	;;
    selftest)
	if ! on_master_node ; then
	    log "E: not on master node"
	    exit 1
	fi
	selftest
	;;
    '')
	help
	;;
    *)
	echo "E: unknown command: $1, try '$0 help'" >&2
	exit 1
	;;
esac
