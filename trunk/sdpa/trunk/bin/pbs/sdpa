#!/bin/bash
#
# usage: sdpa {start|stop|status|submit file}
#

config_file=""
state_dir="$HOME/.sdpa/state"

function setup ()
{
    if [ ! -d "$state_dir" ] ; then
	local msg=$( mkdir -p "$state_dir" 2>&1 )
	if [ $? -ne 0 ] ; then
	    echo "E: failed to create state-dir: $state_dir: $msg" >&2
	    return 1
	fi
    fi
    # read config file
    # read pids etc
    return 0
}

function configure ()
{
    return 0
}

function cleanup ()
{
    echo "cleaning up" >&2
    echo "  * logs" >&2
    clear-logs -f -a -x
    echo "  * IPC" >&2
    ipc-cleanup >/dev/null 2>&1
    echo "  * backup files" >&2
    for f in "$HOME"/*.bkp *.bkp ; do
	if [ -e "$f" ] ; then
	    read -t 5 -n 1 -p "    remove $f? [y/N] " do_rm
	    case "$do_rm" in
		y|Y|j|J)
		    echo
		    rm -f "$f"
		    ;;
		*)
		    echo
		    ;;
	    esac
	fi
    done
    return 0
}

function help ()
{
    echo "usage: $0 {start|stop|status|cleanup|submit <file>}" >&2
    return 0
}

function start_log ()
{
    echo "  - fhglog (disabled)" >&2
    return 0
}

function is_proc_alive ()
{
    local name="$1" ; shift
    local pid="$1" ; shift

    if [ -z "$name" ] ; then
	echo "E: usage: is_proc_alive <binary> <pid>" >&2
	exit 42
    fi

    if [ -z "$pid" ] ; then
	return 1
    fi

    if grep -q "$name" /proc/$pid/cmdline >/dev/null 2>&1 ; then
	if kill -0 "$pid" >/dev/null 2>&1 ; then
	    return 0
	else
	    echo "E: $name: there seems to be an alien around!" >&2
	    echo "E:       cannot send signal to $pid" >&2
	    return 2 # not allowed to send signals!
	fi
    else
	return 1 # not there
    fi
}

function start_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    # check for old one
    local pid_file="$state_dir/$name.pid"
    local log_file="$SDPA_LOG_DIR/$name.log"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if is_proc_alive "$name" "$pid" ; then
	echo "  * $name ($pid)" >&2
    else
	:> "$pid_file"
	$binary $@ </dev/null >"$log_file" 2>&1 &
	pid=$!
	sleep 0.5
	if is_proc_alive "$name" "$pid" ; then
	    echo "  + $name ($pid)" >&2
	    echo "$pid" > "$pid_file"
	    disown -a
	    return 0
	else
	    echo "  - $name (dead)" >&2
	    return 1
	fi
    fi
}

function stop_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    local pid_file="$state_dir/$name.pid"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if [ -n "$pid" ] ; then
	echo -n "    sending SIGTERM to $name ($pid)..." >&2
	for (( i=0; i<3; ++i )); do
	    if is_proc_alive "$name" "$pid" ; then
		echo -n "."
		kill -TERM "$pid" >/dev/null 2>&1
		sleep 1
	    else
		:> "$pid_file"
		echo "ok" >&2
		break
	    fi
	done
    fi

    if is_proc_alive "$name" "$pid" ; then
	kill -KILL "$pid" >/dev/null 2>&1
	echo "killed" >&2
    else
	pkill "$name" >/dev/null 2>&1
	return 0
    fi
}

function start_kvs ()
{
    if ! start_proc "fhgkvsd" "fhgkvsd" "-C"; then
	echo "E: could not start kvs, giving up!" >&2
	return 1
    else
	sleep 1
	return 0
    fi
}

function stop_kvs ()
{
    echo "  * fhgkvsd"
    if ! stop_proc "fhgkvsd" "fhgkvsd" ; then
	echo "E: could not stop kvs!" >&2
	return 1
    fi
}

function start_orch ()
{
    if ! start_proc "orchestrator" "start-orch" ; then
	echo "E: could not start orchestrator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_orch ()
{
    echo "  * orchestrator"
    if ! stop_proc "orchestrator" "start-orch" ; then
	echo "E: could not stop orchestrator" >&2
	return 1
    fi
}

function start_agg ()
{
    if ! start_proc "aggregator" "start-agg" ; then
	echo "E: could not start aggregator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_agg ()
{
    echo "  * aggregator"
    if ! stop_proc "aggregator" "start-agg" ; then
	echo "E: could not stop aggregator" >&2
	return 1
    fi
}

function node_loop ()
{
    if [ ! -r "$SDPA_NODEFILE" ] ; then
	echo "Cannot read nodefile: $SDPA_NODEFILE" >&2
	return 1
    fi

    local body="$1" ; shift
    local nodes="$1" ; shift
    local node_max=$( uniq $SDPA_NODEFILE | wc -l )

    if [ -z "$nodes" ] ; then
	nodes=$( echo $( seq 1 $node_max ) )
    fi

    local rc=0
    local bunch_size=16
    local count=0
    local procs=
    local node_num
    local p
    for node_num in $nodes; do
	if test $node_num -lt 1 -o $node_num -gt $node_max ; then
	    echo "E: invalid node number: $node_num" >&2
	    rc=$(( rc + 1 ))
	    continue
	fi
	count=$(( count + 1 ))
	local node_name=$( uniq $SDPA_NODEFILE | tail -n +$node_num | head -n 1 )

	echo "    * executing $body $@ on $node_name" >&2
	local rank=$(( $node_num - 1 ))
	$body $node_name $rank $@ &
	procs="$procs $!"
	if [ $count -ge $bunch_size ] ; then
	    for p in $procs ; do
		wait $p
		rc=$(( rc + $? ))
	    done
	    procs=
	    count=0
	fi
    done
    for p in $procs ; do
	wait $p
	rc=$(( rc + $? ))
    done
    return $rc
}

function start_pc ()
{
    sleep 1
    echo "  * process container" >&2
    node_loop start_pc_on_node $@
}

function start_pc_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift

    rm -f "$SDPA_LOG_DIR/pc.$node.log"
    echo start-pc -D -r $rank $@ | ssh -T -x "$node" >/dev/null 2>&1
    if [ $? -ne 0 ] ; then
	echo "pc did not startup on node $node: $output" >&2
	return 1
    else
	return 0
    fi
}

function start_nre ()
{
    sleep 1
    echo "  * nres" >&2
    node_loop start_nre_on_node $@
}

function start_nre_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift

    rm -f "$SDPA_LOG_DIR/nre.$node.log"
    echo start-nre -D $@ | ssh -T -x "$node" >/dev/null 2>&1
    if [ $? -ne 0 ] ; then
	echo "nre did not startup on node $node: $output" >&2
	return 1
    else
	return 0
    fi
}

function stop_pc_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift
    echo stop-pc -r $rank | ssh -T -x $node >/dev/null 2>&1
}

function stop_pc ()
{
    echo "  * process container" >&2
    node_loop stop_pc_on_node $@
}

function stop_nre_on_node ()
{
    local node=$1 ; shift
    local rank=$1 ; shift
    echo stop-nre -r $rank | ssh -T -x $node >/dev/null 2>&1
}

function stop_nre ()
{
    echo "  * nres" >&2
    node_loop stop_nre_on_node $@
}

function start_gpi ()
{
    if ! start_proc "gpi-space" "start-gpi" "-f" ; then
	echo "E: could not start GPI, giving up!" >&2
	return 1
    else
	sleep 5
	return 0
    fi
}

function stop_gpi ()
{
    echo "  * gpi"
    if ! stop_proc "gpi-space" "gpi-space" ; then
	echo "E: could not stop gpi" >&2
	return 1
    else
	return 0
    fi
}

function start ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
	parts="kvs gpi orch agg pc nre"
    else
	shift
    fi

    local p
    local rc=0
    for p in $parts ; do
	status $@ >/dev/null 2>&1
	if [ $? -eq 0 ] ; then
	    echo "W: $p still running!" >&2
	fi

	if ! start_$p $@ ; then
	    echo "Start of $p failed!" >&2
	    rc=$(( rc + 1 ))
	fi
    done
    return $rc
}

function stop ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
	parts="nre pc agg orch gpi kvs"
    else
	shift
    fi

    local p
    local rc=0
    for p in $parts ; do
	if ! stop_$p $@ ; then
	    rc=$(( rc + 1 ))
	fi
    done
    return $rc
}

function program_status ()
{
    local p=$1 ; shift
    local rc=0
    local pid_file="$state_dir/$p.pid"
    local pid=$( cat "$pid_file" 2>/dev/null)
    if [ -z "$pid" ] ; then
	pid=$(pidof "$p")
    fi

    if is_proc_alive "$p" "$pid" ; then
	return 0
    else
	return 1
    fi
}

function status_orch ()
{
    program_status "orchestrator"
}

function status_agg ()
{
    program_status "aggregator"
}

function status_nre_on_node ()
{
    local node=$1; shift
    local rank=$1; shift
    local pid=$( echo pidof nre | ssh -T -x $node 2>/dev/null )
    if [ -z "$pid" ] ; then
	return 1
    else
	return 0
    fi
}

function status_pc_on_node ()
{
    local node=$1; shift
    local rank=$1; shift
    local pid=$( echo pidof nre-pcd | ssh -T -x $node 2>/dev/null )
    if [ -z "$pid" ] ; then
	return 1
    else
	return 0
    fi
}

function status_nre ()
{
    node_loop status_nre_on_node $@ >/dev/null 2>&1
}

function status_pc ()
{
    node_loop status_pc_on_node $@ >/dev/null 2>&1
}

function status_kvs ()
{
    program_status "fhgkvsd"
}

function status_gpi ()
{
    program_status "gpi-space"
}

function status ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
      parts="kvs orch agg gpi nre pc"
    else
      shift
    fi

    # check system status
    local rc=0
    local p
    for p in $parts ; do
	echo -n "  $p is " >&2
	status_$p $@
	if [ $? -ne 0 ] ; then
	    echo "dead" >&2
	    rc=$(( rc + 1 ))
	else
	    echo "alive" >&2
	fi
    done
    return $rc
}

function submit ()
{
    # check system health
    #    if not running:
    #       abort/ask
    #    else
    #       submit
    net="$1" ; shift
    if [ ! -r "$net" ] ; then
	echo "E: submit: cannot read file: $net" >&2
	return 42
    fi

    echo -n "checking system status..." >&2
    if ! status kvs >/dev/null 2>&1 || ! status orch >/dev/null 2>&1 ; then
	echo "dead" >&2
	read -t 15 -n 1 -p "Do you want me to start it? [Y/n] " do_start
	case "$do_start" in
	    n|N)
		return 1
		;;
	    *)
		echo
		if ! start ; then
		    echo "Could not start, please check the logs" >&2
		    return 3
		else
		    sleep 5
		fi
		;;
	esac
    else
	echo "ok" >&2
    fi

    echo "submitting file: $net" >&2
    jobid=$( sdpac submit "$net" 2>&1 )
    if [ $? -ne 0 ] ; then
	echo "Submission failed: $jobid"
	return 4
    else
	echo "  + job ($jobid)"
	echo "$jobid" > "$state_dir/current_job"
	sdpac wait "$jobid"
	s=$( sdpac status "${jobid}" )
	echo "$jobid -> $s" >&2
	if echo "$s" | grep -q -i 'finish' ; then
	    echo "Done." >&2
	    sdpac results "$jobid"
	fi
	sdpac delete "${jobid}"
	if [ $? -eq 0 ] ; then
	    echo "  - job ($jobid)"
	fi
    fi
}

if ! setup ; then
    exit $?
fi

case "$1" in
    start)
	shift
	start $@
	;;
    stop)
	shift
	stop $@
	;;
    restart)
	shift
	stop $@
	start $@
	;;
    status)
	shift
	status $@
	;;
    cleanup)
	if status >/dev/null 2>&1 ; then
	    echo "E: still running!" >&2
	    exit 1
	else
	    cleanup
	fi
	;;
    submit)
	shift
	submit $@
	;;
    help)
	help
	;;
    '')
	help
	;;
    *)
	echo "E: unknown command: $1, try '$0 help'" >&2
	exit 1
	;;
esac
