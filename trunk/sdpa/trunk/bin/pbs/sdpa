#!/bin/bash
#
# usage: sdpa {start|stop|status|submit file}
#

config_file=""
state_dir="$HOME/.sdpa/state"

function setup ()
{
    if [ ! -d "$state_dir" ] ; then
	msg=$( mkdir -p "$state_dir" 2>&1 )
	if [ $? -ne 0 ] ; then
	    echo "E: failed to create state-dir: $state_dir: $msg" >&2
	    return 1
	fi
    fi
    # read config file
    # read pids etc
    return 0
}

function configure ()
{
    return 0
}

function cleanup ()
{
    echo "cleaning up" >&2
    echo "  * logs" >&2
    clear-logs -f -a -x
    echo "  * IPC" >&2
    ipc-cleanup >/dev/null 2>&1
    echo "  * backup files" >&2
    for f in "$HOME"/*.bkp *.bkp ; do
	if [ -e "$f" ] ; then
	    read -t 5 -n 1 -p "    remove $f? [y/N] " do_rm
	    case "$do_rm" in
		y|Y|j|J)
		    echo
		    rm -f "$f"
		    ;;
		*)
		    echo
		    ;;
	    esac
	fi
    done
    return 0
}

function help ()
{
    echo "usage: $0 {start|stop|status|cleanup|submit <file>}" >&2
    return 0
}

function start_log ()
{
    echo "  - fhglog (disabled)" >&2
    return 0
}

function is_proc_alive ()
{
    name="$1"
    pid="$2"
    shift 2

    if [ -z "$name" ] ; then
	echo "E: usage: is_proc_alive <binary> <pid>" >&2
	exit 42
    fi

    if [ -z "$pid" ] ; then
	return 1
    fi

    if grep -q "$name" /proc/$pid/cmdline >/dev/null 2>&1 ; then
	if kill -0 "$pid" >/dev/null 2>&1 ; then
	    return 0
	else
	    echo "E: $name: there seems to be an alien around!" >&2
	    echo "E:       cannot send signal to $pid" >&2
	    return 2 # not allowed to send signals!
	fi
    else
	return 1 # not there
    fi
}

function start_proc ()
{
    name="$1"
    binary="$2"
    shift 2

    # check for old one
    pid_file="$state_dir/$name.pid"
    log_file="$SDPA_LOG_DIR/$name.log"
    pid=$( cat "$pid_file" 2>/dev/null )
    if is_proc_alive "$name" "$pid" ; then
	echo "  * $name ($pid)" >&2
    else
	:> "$pid_file"
	$binary $@ </dev/null >"$log_file" 2>&1 &
	pid=$!
	sleep 0.5
	if is_proc_alive "$name" "$pid" ; then
	    echo "  + $name ($pid)" >&2
	    echo "$pid" > "$pid_file"
	    disown -a
	    return 0
	else
	    echo "  - $name (dead)" >&2
	    return 1
	fi
    fi
}

function stop_proc ()
{
    name="$1"
    binary="$2"

    pid_file="$state_dir/$name.pid"
    pid=$( cat "$pid_file" 2>/dev/null )
    if [ -n "$pid" ] ; then
	echo -n "    sending SIGTERM to $name ($pid)..." >&2
	for (( i=0; i<3; ++i )); do
	    if is_proc_alive "$name" "$pid" ; then
		echo -n "."
		kill -TERM "$pid" >/dev/null 2>&1
		sleep 1
	    else
		:> "$pid_file"
		echo "ok" >&2
		break
	    fi
	done
    fi

    if is_proc_alive "$name" "$pid" ; then
	kill -KILL "$pid" >/dev/null 2>&1
	echo "killed" >&2
    else
	killall "$name" >/dev/null 2>&1
	return 0
    fi
}

function start_kvs ()
{
    if ! start_proc "fhgkvsd" "fhgkvsd" "-C"; then
	echo "E: could not start kvs, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_kvs ()
{
    echo "  * fhgkvsd"
    if ! stop_proc "fhgkvsd" "fhgkvsd" ; then
	echo "E: could not stop kvs!" >&2
	return 1
    fi
}

function start_orch ()
{
    if ! start_proc "orchestrator" "start-orch" ; then
	echo "E: could not start orchestrator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_orch ()
{
    echo "  * orchestrator"
    if ! stop_proc "orchestrator" "start-orch" ; then
	echo "E: could not stop orchestrator" >&2
	return 1
    fi
}

function start_agg ()
{
    if ! start_proc "aggregator" "start-agg" ; then
	echo "E: could not start aggregator, giving up!" >&2
	return 1
    else
	return 0
    fi
}

function stop_agg ()
{
    echo "  * aggregator"
    if ! stop_proc "aggregator" "start-agg" ; then
	echo "E: could not stop aggregator" >&2
	return 1
    fi
}

function node_loop ()
{
    if [ ! -r "$SDPA_NODEFILE" ] ; then
	echo "Cannot read nodefile: $SDPA_NODEFILE" >&2
	return 1
    fi

    body="$1"

    node_max=$( uniq $SDPA_NODEFILE | wc -l )
    nodes=$( echo $( seq 1 $node_max ) )
    bunch_size=16
    count=0
    pids=""
    for node_num in $nodes; do
	count=$(( count + 1 ))
	node_name=$( uniq $SDPA_NODEFILE | tail -n +$node_num | head -n 1 )

	echo "    * executing $@ on $node_name" >&2
	rank=$(( $node_num - 1 ))
	$body $node_name $rank &
	if [ $count -ge $bunch_size ] ; then
	    wait
	    count=0
	fi
    done
    wait
}

function start_nre ()
{
    echo "  * nres" >&2
    node_loop start_nre_on_node
}

function start_nre_on_node ()
{
    node=$1
    rank=$2

    rm -f "$SDPA_LOG_DIR/nre.$node.log"
    rm -f "$SDPA_LOG_DIR/pc.$node.log"
    echo start-nre -r $rank | ssh -x "$node" >/dev/null 2>&1
    if [ $? -ne 0 ] ; then
	echo "nre did not startup on node $node: $output" >&2
	return 1
    else
	return 0
    fi
}

function stop_nre_on_node ()
{
    node=$1
    rank=$2
    echo stop-nre -r $rank | ssh -x $node >/dev/null 2>&1
}

function stop_nre ()
{
    echo "  * nres" >&2
    node_loop stop_nre_on_node
}

function start_gpi ()
{
    if ! start_proc "sdpa-gpi" "start-gpi" "-f" ; then
	echo "E: could not start GPI, giving up!" >&2
	return 1
    else
	sleep 5
	return 0
    fi
}

function stop_gpi ()
{
    echo "  * gpi"
    if stop_proc "sdpa-gpi" "start-gpi" ; then
	ipc-cleanup >/dev/null 2>&1
    else
	echo "E: could not stop gpi" >&2
	return 1
    fi
}


function start ()
{
    status >/dev/null 2>&1
    if [ $? -eq 0 ] ; then
	echo "E: still running!" >&2
	return 1
    else
	cleanup
	echo "starting everything..." >&2
	for c in start_kvs start_gpi start_orch	start_agg start_nre ; do
	    $c
	    if [ $? -ne 0 ] ; then
		echo 'stopping...' >&2
		stop
	    fi
	done
    fi
}

function stop ()
{
    # shut everything down
    echo "stopping everything..." >&2
    stop_nre
    stop_agg
    stop_orch
    stop_gpi
    stop_kvs
}

function status ()
{
    # check system status
    echo "system status:" >&2
    dead_counter=0
    for name in fhgkvsd orchestrator aggregator sdpa-gpi ; do
	pid_file="$state_dir/$name.pid"
	pid=$( cat "$pid_file" 2>/dev/null)
	echo -n "  $name " >&2
	if [ -z "$pid" ] ; then
	    pid=$( pidof "$name" )
	fi

	if is_proc_alive "$name" "$pid" ; then
	    echo "alive with pid $pid" >&2
	else
	    echo "dead"
	    dead_counter=$(( dead_counter + 1 ))
	fi
    done
    return $dead_counter
}

function submit ()
{
    # check system health
    #    if not running:
    #       abort/ask
    #    else
    #       submit
    net="$1"
    if [ ! -r "$net" ] ; then
	echo "E: submit: cannot read file: $net" >&2
	return 42
    fi

    echo -n "checking system status..." >&2
    status >/dev/null 2>&1
    if [ $? -ne 0 ] ; then
	echo "dead" >&2
	read -t 15 -n 1 -p "Do you want me to start it? [Y/n] " do_start
	case "$do_start" in
	    n|N)
		return 1
		;;
	    *)
		echo
		if ! start ; then
		    echo "Could not start, please check the logs" >&2
		    return 3
		else
		    sleep 5
		fi
		;;
	esac
    else
	echo "ok" >&2
    fi

    echo "submitting file: $net" >&2
    jobid=$( sdpac submit "$net" 2>&1 )
    if [ $? -ne 0 ] ; then
	echo "Submission failed: $jobid"
	return 4
    else
	echo "  + job ($jobid)"
	echo "$jobid" > "$state_dir/current_job"
	sdpac wait "$jobid"
	s=$( sdpac status "${jobid}" )
	echo "$jobid -> $s" >&2
	if echo "$s" | grep -q -i 'finish' ; then
	    echo "Done." >&2
	    sdpac results "$jobid" -i "results.$jobid"
	fi
	sdpac delete "${jobid}"
	if [ $? -eq 0 ] ; then
	    echo "  - job ($jobid)"
	fi
    fi
}

if ! setup ; then
    exit $?
fi

case "$1" in
    start)
	start
	;;
    stop)
	stop
	;;
    restart)
	stop
	start
	;;
    status)
	status
	;;
    cleanup)
	if status >/dev/null 2>&1 ; then
	    echo "E: still running!" >&2
	    exit 1
	else
	    cleanup
	fi
	;;
    submit)
	if [ -z "$2" ] ; then
	    echo "E: submit requires a parameter" >&2
	    exit 1
	else
	    submit "$2"
	fi
	;;
    help)
	help
	;;
    '')
	help
	;;
    *)
	echo "E: unknown command: $1, try '$0 help'" >&2
	exit 1
	;;
esac
