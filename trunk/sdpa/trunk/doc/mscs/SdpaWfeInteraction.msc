msc {
  hscale = "1.0";

  U, O, Go, A, Ga, N, Gn;

  |||;
  U->O [ label="submitJob(description)" ];
  O=>Go [ label="Workflow wf(gwes::parse_workflow(description))" ];
  --- [ label = "if the syntax is ok, schedule the job" ];
  O=>O [ label = "create Job and assign jobid" ];
  O=>O [ label = "wf.setId(jobid)" ];
  O->U [ label = "submitJobAck(jobid)" ];
  --- [ label = "hand the workflow over to the WFE" ];
  O=>Go [ label="submitWorkflow(wf)" ];
  Go=>O [ label="submitActivity(act)" ];
  O=>O [ label="false = handle_local(act)" ];
  O=>Go [ label="Workflow swf = gwes::transform_activity_to_workflow(act)" ];
  O=>Go [ label="Description desc = gwes::serialize(swf)" ];
  O->A [ label="submitJob(desc)" ];

  ...;
  A=>Ga [ label="Workflow wf = gwes::parse_workflow(desc)" ];
  --- [ label = "the syntax must be ok on this level!" ];
  A=>Ga [ label="submitWorkflow(wf)" ];
  Ga=>A [ label="submitActivity(act)" ];
  A=>A [ label="false = handle_local(act)" ];
  A=>Ga [ label="Workflow swf = gwes::transform_activity_to_workflow(act)" ];
  A=>Ga [ label="Description desc = gwes::serialize(swf)" ];
  A->N [ label="submitJob(desc)" ];

  ...;
  N=>Gn [ label="Workflow wf = gwes::parse_workflow(desc)" ];
  --- [ label = "there are two possibilities for this workflow: atomic or complex" ];
  N=>N [ label = "atomic = measure_complexity(wf), directly execute it (schedule to local execution worker)" ];
  N=>N [ label = "result = execute(wf)" ];
  --- [ label = "when the job is finished, we have to inform the aggregator" ];
  N->A [ label = "jobFinished(wf.id(), output)" ];
  ...;
  N=>N [ label = "complex = measure_complexity(wf), pass it to the WFE to handle it" ];
  N=>Gn [ label = "submitWorkflow(wf)" ];
  Gn=>N [ label="submitActivity(act)" ];
  N=>N [ label="true = handle_local(act)" ];
  N=>N [ label = "result = execute(act)" ];
  N=>Gn [ label = "activityDispatched(act.id())" ];
  --- [ label = "when the activity is finished, we have to inform the WFE" ];
  N=>Gn [ label = "activityFinished(act.id(), result)" ];
  --- [ label = "somewhen later the WFE will inform us that the whole workflow is done." ];
  Gn=>N [ label = "workflowFinished(wf.id())" ];
  N->A [ label = "jobFinished(wf.id(), wf.results())" ];
  --- [ label = "wait on an acknowledge from the upper level, and resend jobFinished messages (maybe even persist to disk)" ];
  N=>N [ label = "waitlist.insert(wf.id(), wf.results())" ];
  ...;
  A->N [ label = "jobFinishedAck(wf.id())" ];
  N=>N [ label = "waitlist.remove(wf.id())" ];
  --- [ label = "the aggregator can inform the WFE that an activity is finished" ];
  A=>Ga [ label = "activityFinished(act.id() = wf.id(), results), we got an activity in the first-place" ];
  --- [ label = "somewhen later the WFE will inform us that the whole workflow is done." ];
  Ga=>A [ label = "workflowFinished(wf.id())" ];
  A->O [ label = "jobFinished(wf.id(), wf.results()), this is the parent-workflow!" ];
  A=>A [ label = "waitlist.insert(wf.id(), wf.results())" ];
  ...;
  O->A [ label = "jobFinishedAck(wf.id())" ];
  A=>A [ label = "waitlist.remove(wf.id())" ];
  O=>Go [ label = "activityFinished(wf.id())" ];
  Go=>O [ label = "workflowFinished(wf.id())" ];
  --- [ label = "now we have reached a state in which the execution has ended." ];
  O=>O [ label = "waitlist.insert(wf.id(), wf.results()), keep only the results, forget everything else" ];
  U->O [ label = "retrieveResults(wf.id())" ];
  O->U [ label = "jobResults(wf.id(), results)" ];
  U->O [ label = "deleteJob(wf.id())" ];
  O=>O [ label = "remove everything related to the job" ];
  O->U [ label = "deleteJobAck(wf.id())" ];
}
