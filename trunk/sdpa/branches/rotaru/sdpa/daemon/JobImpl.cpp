/*
 * =====================================================================================
 *
 *       Filename:  JobImpl.cpp
 *
 *    Description:  Job implementation
 *
 *        Version:  1.0
 *        Created:
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Dr. Tiberiu Rotaru, tiberiu.rotaru@itwm.fraunhofer.de
 *        Company:  Fraunhofer ITWM
 *
 * =====================================================================================
 */
#include "JobImpl.hpp"

#include <sdpa/events/JobResultsReplyEvent.hpp>
#include <sdpa/events/JobStatusReplyEvent.hpp>

#include <sdpa/events/JobResultsReplyEvent.hpp>
#include <sdpa/events/JobStatusReplyEvent.hpp>
#include <sdpa/events/DeleteJobAckEvent.hpp>
#include <sdpa/events/CancelJobEvent.hpp>

#include <seda/Stage.hpp>
#include <seda/StageRegistry.hpp>

#include <sdpa/util/Properties.hpp>
#include <sdpa/daemon/GenericDaemon.hpp>

using namespace std;
using namespace sdpa::events;

namespace sdpa { namespace daemon {
    JobImpl::JobImpl(const sdpa::job_id_t &id,
                     const sdpa::job_desc_t &desc,
                     const sdpa::daemon::IComm* pHandler,
                     const sdpa::job_id_t &parent)
        : id_(id), desc_(desc),
          parent_(parent),
          b_marked_for_del_(false),
          b_local_(false),
          SDPA_INIT_LOGGER( string("Job ")+ id.str() ),
          pComm(const_cast<IComm*>(pHandler))
    {}

    JobImpl::~JobImpl() throw () { }

    const sdpa::job_id_t & JobImpl::id() const {
        return id_;
    }

    const sdpa::job_id_t & JobImpl::parent() const {
        return parent_;
    }

    const sdpa::job_desc_t & JobImpl::description() const {
        return desc_;
    }


    bool JobImpl::is_marked_for_deletion() {
    	return b_marked_for_del_;
    }

    bool JobImpl::mark_for_deletion() {
    	return b_marked_for_del_ = true;
    }

    bool JobImpl::is_local() {
      	return b_local_;
    }

    void JobImpl::set_local(bool b_val) {
    	b_local_ = b_val;
    }

    void JobImpl::action_run_job()
    {
    	SDPA_LOG_DEBUG("Process 'action_run_job'");
    }

    // transition from Pending to Cancelled
	void JobImpl::action_cancel_job_from_pending(const sdpa::events::CancelJobEvent& evt)
	{
		SDPA_LOG_DEBUG("Process 'action_cancel_job_from_pending'");

		// the message comes from GWES, should identify the worker to which the activity was assigned
		// and send him a CancelJob
		// put the job into Cancelling state
		// until you receive a CancelJobAck from the worker
		if(evt.from() == evt.to() ) // the event was  generated by GWES
		{
			try {
				// clearly, I'm in the Pending state here
				// inform immediately GWES that the corresponding activity was cancelled
				gwes::activity_id_t actId = evt.job_id();
				gwes::workflow_id_t wfId  = parent().str();

				pComm->gwes()->activityCanceled( wfId, actId );

			} catch(sdpa::util::PropertyLookupFailed& ) {
				SDPA_LOG_DEBUG("The job was not assigned to a worker!");
			} catch(...) {
				SDPA_LOG_ERROR("Unexpected exception occurred!");
			} //handle here NoSuchWorkflow,NoSuchActivity exceptions
		}
		else //the master sent a Cancel message -> forward it to the workflow engine
		{
			if( !pComm->master().empty() )
			{
				// clearly, I'm into the Pending state here
				// return back to the master a CancelJobAckEvent
				CancelJobAckEvent::Ptr pCancelAckEvt(new CancelJobAckEvent( pComm->name(), pComm->master(), evt.job_id()) );
				pComm->sendEvent( pComm->to_master_stage(), pCancelAckEvt );

				// delete the job
				if( GenericDaemon* pDaemon = dynamic_cast<GenericDaemon*>(pComm))
					pDaemon->jobManager()->deleteJob(evt.job_id());
			}
		}
	}

	// transition from Cancelling to Cancelled
    void JobImpl::action_cancel_job(const sdpa::events::CancelJobEvent& evt)
    {
    	// cancel the job
    	SDPA_LOG_DEBUG("Process 'action_cancel_job'");

    	/*else // the message comes from GWES, should identify the worker to which the activity was assigned
		 * and send him a CancelJob
		 * put the job into Cancelling state
		 * until you receive a CancelJobAck from the worker*/
    	if( evt.from() ==  evt.to() )
		{
    		try
    		{
				sdpa::worker_id_t worker_id = get("worker");// Clearly, the job can be into the submitted or acknowledged queue

				// else, forward the cancel to the worker
				SDPA_LOG_DEBUG("Send CancelJobEvent to the worker "<<worker_id);

				CancelJobEvent::Ptr pCancelEvt( new CancelJobEvent( pComm->name(), worker_id, evt.job_id()));
				pComm->sendEvent(pComm->to_slave_stage(), pCancelEvt);
			} catch(sdpa::util::PropertyLookupFailed& ) {
				SDPA_LOG_WARN("The job was not assigned to a worker!");
			} catch(...) {
				SDPA_LOG_ERROR("Unexpected exception occurred!");
			}
		}
		else // /the upper level sent a Cancel message -> inform Gwes
		{
			try {
				gwes::workflow_id_t workflowId = evt.job_id();
				pComm->gwes()->cancelWorkflow(workflowId);
			}
			catch(gwes::Gwes2Sdpa::NoSuchWorkflow)
			{
				SDPA_LOG_ERROR("No such workflow exception occured!");
			}
			catch(...) {
				SDPA_LOG_ERROR("Unexpected exception occurred!");
			}
		}
    }

    void JobImpl::action_cancel_job_ack(const sdpa::events::CancelJobAckEvent& /* evt */)
    {
    	// Notify WFE that the job e.job_id() was canceled (send a CancelJobAckEvent event to the stage WFE)

    	SDPA_LOG_DEBUG("Process 'action_cancel_job_ack'");
    }

    void JobImpl::action_delete_job(const sdpa::events::DeleteJobEvent& e)
    {
    	b_marked_for_del_ = true;

    	DeleteJobAckEvent::Ptr pDelJobReply(new DeleteJobAckEvent(e.to(), e.from(), id()) );
    	//send ack to master
    	pComm->sendEvent(pComm->to_master_stage(), pDelJobReply);

    	SDPA_LOG_DEBUG("Process 'action_delete_job'");
    }

    void JobImpl::action_query_job_status(const sdpa::events::QueryJobStatusEvent& e)
    {
    	SDPA_LOG_DEBUG("Process 'action_query_job_status'");

    	JobStatusReplyEvent::status_t status = getStatus();

    	// Post a JobStatusReplyEvent to e.from()
		JobStatusReplyEvent::Ptr pStatReply(new JobStatusReplyEvent(e.to(), e.from(), id(), status));

		// send status reply to master
		pComm->sendEvent(pComm->to_master_stage(), pStatReply);

    	SDPA_LOG_DEBUG("Posted an event of type StatusReplyEvent");
    }

    void JobImpl::action_job_finished(const sdpa::events::JobFinishedEvent& /* evt */)
    {
    	// inform WFE (send a JobFinishedEvent event to the stage WFE)
    	// obsolete: post a JobFinishedAckEvent to e.from()
    	SDPA_LOG_DEBUG("Process 'action_job_finished'");
    }

    void JobImpl::action_job_failed(const sdpa::events::JobFailedEvent& /* evt */)
    {
    	// inform WFE (send a JobFailedEvent event to the stage WFE)
    	// obsolete: post a JobFailedAckEvent to e.from()
    	SDPA_LOG_DEBUG("Process 'action_job_failed'");
    }

    void  JobImpl::action_retrieve_job_results(const sdpa::events::RetrieveJobResultsEvent& e)
    {
    	// fill it here with real results
    	JobResultsReplyEvent::result_t results("");

    	const JobResultsReplyEvent::Ptr pResReply(new JobResultsReplyEvent(e.to(), e.from(), id(), results));

    	// attach to this event the results!

    	// reply the results to master
    	pComm->sendEvent(pComm->to_master_stage(), pResReply);

    	// Post a JobResultsReplyEvent to e.from()
    	SDPA_LOG_DEBUG("Process 'action_retrieve_results'");
    }
}}
