%{
  // Finite state machine of the SDPA protocol
  //
%}

%package sdpa::fsm
%class JobFSM
%header JobFSM.hpp

%start SMC_JobFSM::Pending
%map SMC_JobFSM

%%
Pending
{
    RunJob(event: sdpa::events::RunJobEvent&)
        Running
        {
        	GetNextActiveSubJobsListFromWFE(event.job_id());  //assign unique global IDs!
            ScheduleJobs();
        }

    CancelJob(event: sdpa::events::CancelJobEvent&)
        Cancelled
        {
            DoCancelJob(event.job_id());
            PostCancelJobAckEventForMaster(event);
        }

    QueryJobStatus(event: sdpa::events::QueryJobStatusEvent&)
        Pending
        {
            PostJobStatusAnswerEventForMaster(event);
        }
}

Running
{
    JobFinished(event: sdpa::events::JobFinishedEvent&)
      	[ ctxt.IsSubJob(event.job_id())]
      	Running
        {
        	GetNextActiveSubJobsListFromWFE(event.job_id()); //assign unique global IDs!
            ScheduleJobs();  //if the list is empty, trigger JobFinishedEvent for self!
        }
      
    JobFinished(event: sdpa::events::JobFinishedEvent&)
    	Finished
        {
            PostJobFinishedEventForMaster(event); //for the upper level
        }

  	JobFailed(event: sdpa::events::JobFailedEvent&)
  	    [ ctxt.IsSubJob(event.job_id())]
    	Failed
        {
            InformWFEJobFailed(event.job_id()); //either re-schedule it or ask WFE what to do, or declare the parent job failed
        }
        
    JobFailed(event: sdpa::events::JobFailedEvent&)
    	Failed
        {
            HandleJobFailure(event.job_id());
            PostJobFailedEventForMaster(event);  
        }

    CancelJob(event: sdpa::events::CancelJobEvent&)
        Cancelling
        {
            DoCancelSubJobs(event.job_id());
            // Attention!: some SubJobs may already have finished, 
            // while other subjobs are still running or even not assigned!
        }

    QueryJobStatus(event: sdpa::events::QueryJobStatusEvent&)
        Running
        {
            PostJobStatusAnswerEventForMaster(event);
        }
}

Cancelling
{
    CancelJobAck(event: sdpa::events::CancelJobAckEvent&)
    [ctxt.IsSubJob(event.job_id()) && ctxt.IncGetCancelAckCounter() && ctxt.GetCancelAckCounter()<ctxt.GetNumberSubJobs() ]
    	Cancelling
    	{}
    	
    CancelJobAck(event: sdpa::events::CancelJobAckEvent&)
    [ctxt.IsSubJob(event.job_id()) && ctxt.GetCancelAckCounter() == ctxt.GetNumberSubJobs() ]
    // Attention!: some of SubJobs may already have finished! Consider only the jobs scheduled 
    //Ignore those that are finished or failed
    	Cancelled
    	{
    		 PostCancelJobAckEventForMaster(event);
    	}
    
	QueryJobStatus(event: sdpa::events::QueryJobStatusEvent&)
        Cancelling
        {
        	PostJobStatusAnswerEventForMaster(event); 
        }
}

Finished
{
    QueryJobStatus(event: sdpa::events::QueryJobStatusEvent&)
        Finished
        {
        	PostJobStatusAnswerEventForMaster(event); 
        }
}

Failed
{
    QueryJobStatus(event: sdpa::events::QueryJobStatusEvent&)
        Failed
        {
        	PostJobStatusAnswerEventForMaster(event); 
        }
}

Cancelled
{
    QueryJobStatus(event: sdpa::events::QueryJobStatusEvent&)
        Cancelled
        {
        	PostJobStatusAnswerEventForMaster(event); 
        }
}

%%
