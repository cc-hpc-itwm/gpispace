// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "sdpa-msg.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format_inl.h>

namespace sdpa {
namespace messages {

namespace {

const ::google::protobuf::Descriptor* SDPAMessage_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Error_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Token_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SubmitJob_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SubmitJobAck_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CancelJob_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CancelJobAck_descriptor_ = NULL;
const ::google::protobuf::Descriptor* JobStatusRequest_descriptor_ = NULL;
const ::google::protobuf::Descriptor* JobStatusReply_descriptor_ = NULL;
const ::google::protobuf::Descriptor* JobFinished_descriptor_ = NULL;
const ::google::protobuf::Descriptor* JobFinishedAck_descriptor_ = NULL;
const ::google::protobuf::Descriptor* JobFailed_descriptor_ = NULL;
const ::google::protobuf::Descriptor* JobFailedAck_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LifeSignal_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ConfigRequest_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ConfigReply_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* JobState_descriptor_ = NULL;

}  // namespace


void proto_BuildDescriptors_sdpa_2dmsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;
  ::google::protobuf::DescriptorPool* pool =
    ::google::protobuf::DescriptorPool::internal_generated_pool();

  const ::google::protobuf::FileDescriptor* file = pool->InternalBuildGeneratedFile(
    "\n\016sdpa-msg.proto\022\rsdpa.messages\"\316\005\n\013SDPA"
    "Message\022#\n\005error\030\001 \001(\0132\024.sdpa.messages.E"
    "rror\022,\n\nsubmit_job\030\002 \001(\0132\030.sdpa.messages"
    ".SubmitJob\0223\n\016submit_job_ack\030\003 \001(\0132\033.sdp"
    "a.messages.SubmitJobAck\022,\n\ncancel_job\030\004 "
    "\001(\0132\030.sdpa.messages.CancelJob\0223\n\016cancel_"
    "job_ack\030\005 \001(\0132\033.sdpa.messages.CancelJobA"
    "ck\022;\n\022job_status_request\030\006 \001(\0132\037.sdpa.me"
    "ssages.JobStatusRequest\0221\n\njob_status\030\007 "
    "\001(\0132\035.sdpa.messages.JobStatusReply\0220\n\014jo"
    "b_finished\030\010 \001(\0132\032.sdpa.messages.JobFini"
    "shed\0227\n\020job_finished_ack\030\t \001(\0132\035.sdpa.me"
    "ssages.JobFinishedAck\022,\n\njob_failed\030\n \001("
    "\0132\030.sdpa.messages.JobFailed\0223\n\016job_faile"
    "d_ack\030\013 \001(\0132\033.sdpa.messages.JobFailedAck"
    "\022.\n\013life_signal\030\014 \001(\0132\031.sdpa.messages.Li"
    "feSignal\0224\n\016config_request\030\r \001(\0132\034.sdpa."
    "messages.ConfigRequest\0220\n\014config_reply\030\016"
    " \001(\0132\032.sdpa.messages.ConfigReply\"P\n\005Erro"
    "r\022,\n\nerror_code\030\001 \002(\0162\030.sdpa.messages.Er"
    "rorCode\022\031\n\021error_description\030\002 \002(\t\"%\n\005To"
    "ken\022\r\n\005place\030\001 \002(\014\022\r\n\005token\030\002 \002(\014\"B\n\tSub"
    "mitJob\022\020\n\010workflow\030\001 \002(\014\022#\n\005input\030\002 \003(\0132"
    "\024.sdpa.messages.Token\"\036\n\014SubmitJobAck\022\016\n"
    "\006job_id\030\001 \002(\014\"+\n\tCancelJob\022\016\n\006job_id\030\001 \002"
    "(\014\022\016\n\006reason\030\002 \001(\t\"\036\n\014CancelJobAck\022\016\n\006jo"
    "b_id\030\001 \002(\014\"\"\n\020JobStatusRequest\022\016\n\006job_id"
    "\030\001 \002(\014\"H\n\016JobStatusReply\022\016\n\006job_id\030\001 \002(\014"
    "\022&\n\005state\030\002 \002(\0162\027.sdpa.messages.JobState"
    "\"\035\n\013JobFinished\022\016\n\006job_id\030\001 \002(\014\" \n\016JobFi"
    "nishedAck\022\016\n\006job_id\030\001 \002(\014\"\033\n\tJobFailed\022\016"
    "\n\006job_id\030\001 \002(\014\"\036\n\014JobFailedAck\022\016\n\006job_id"
    "\030\001 \002(\014\"5\n\nLifeSignal\022\021\n\ttimestamp\030\001 \002(\006\022"
    "\024\n\014component_id\030\002 \002(\014\"%\n\rConfigRequest\022\024"
    "\n\014component_id\030\001 \002(\014\"#\n\013ConfigReply\022\024\n\014c"
    "omponent_id\030\001 \002(\014*\023\n\tErrorCode\022\006\n\002OK\020\000*j"
    "\n\010JobState\022\013\n\007UNKNOWN\020\000\022\013\n\007PENDING\020\001\022\013\n\007"
    "RUNNING\020\002\022\014\n\010FINISHED\020\003\022\n\n\006FAILED\020\004\022\r\n\tC"
    "ANCELLED\020\005\022\016\n\nCANCELLING\020\006B\002H\001", 1550);
  SDPAMessage_descriptor_ = file->message_type(0);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SDPAMessage_descriptor_, &SDPAMessage::default_instance());
  Error_descriptor_ = file->message_type(1);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Error_descriptor_, &Error::default_instance());
  Token_descriptor_ = file->message_type(2);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Token_descriptor_, &Token::default_instance());
  SubmitJob_descriptor_ = file->message_type(3);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubmitJob_descriptor_, &SubmitJob::default_instance());
  SubmitJobAck_descriptor_ = file->message_type(4);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubmitJobAck_descriptor_, &SubmitJobAck::default_instance());
  CancelJob_descriptor_ = file->message_type(5);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CancelJob_descriptor_, &CancelJob::default_instance());
  CancelJobAck_descriptor_ = file->message_type(6);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CancelJobAck_descriptor_, &CancelJobAck::default_instance());
  JobStatusRequest_descriptor_ = file->message_type(7);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JobStatusRequest_descriptor_, &JobStatusRequest::default_instance());
  JobStatusReply_descriptor_ = file->message_type(8);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JobStatusReply_descriptor_, &JobStatusReply::default_instance());
  JobFinished_descriptor_ = file->message_type(9);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JobFinished_descriptor_, &JobFinished::default_instance());
  JobFinishedAck_descriptor_ = file->message_type(10);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JobFinishedAck_descriptor_, &JobFinishedAck::default_instance());
  JobFailed_descriptor_ = file->message_type(11);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JobFailed_descriptor_, &JobFailed::default_instance());
  JobFailedAck_descriptor_ = file->message_type(12);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JobFailedAck_descriptor_, &JobFailedAck::default_instance());
  LifeSignal_descriptor_ = file->message_type(13);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LifeSignal_descriptor_, &LifeSignal::default_instance());
  ConfigRequest_descriptor_ = file->message_type(14);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConfigRequest_descriptor_, &ConfigRequest::default_instance());
  ConfigReply_descriptor_ = file->message_type(15);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConfigReply_descriptor_, &ConfigReply::default_instance());
  ErrorCode_descriptor_ = file->enum_type(0);
  JobState_descriptor_ = file->enum_type(1);
}

// Force BuildDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_sdpa_2dmsg_2eproto {
  StaticDescriptorInitializer_sdpa_2dmsg_2eproto() {
    proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  }
} static_descriptor_initializer_sdpa_2dmsg_2eproto_;

const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor() {
  if (ErrorCode_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return ErrorCode_descriptor_;
}
bool ErrorCode_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* JobState_descriptor() {
  if (JobState_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return JobState_descriptor_;
}
bool JobState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const SDPAMessage SDPAMessage::default_instance_;















const int SDPAMessage::_offsets_[14] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, error_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, submit_job_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, submit_job_ack_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, cancel_job_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, cancel_job_ack_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, job_status_request_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, job_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, job_finished_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, job_finished_ack_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, job_failed_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, job_failed_ack_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, life_signal_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, config_request_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SDPAMessage, config_reply_),
};

SDPAMessage::SDPAMessage()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    error_(NULL),
    submit_job_(NULL),
    submit_job_ack_(NULL),
    cancel_job_(NULL),
    cancel_job_ack_(NULL),
    job_status_request_(NULL),
    job_status_(NULL),
    job_finished_(NULL),
    job_finished_ack_(NULL),
    job_failed_(NULL),
    job_failed_ack_(NULL),
    life_signal_(NULL),
    config_request_(NULL),
    config_reply_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
    error_ = const_cast< ::sdpa::messages::Error*>(&::sdpa::messages::Error::default_instance());
    submit_job_ = const_cast< ::sdpa::messages::SubmitJob*>(&::sdpa::messages::SubmitJob::default_instance());
    submit_job_ack_ = const_cast< ::sdpa::messages::SubmitJobAck*>(&::sdpa::messages::SubmitJobAck::default_instance());
    cancel_job_ = const_cast< ::sdpa::messages::CancelJob*>(&::sdpa::messages::CancelJob::default_instance());
    cancel_job_ack_ = const_cast< ::sdpa::messages::CancelJobAck*>(&::sdpa::messages::CancelJobAck::default_instance());
    job_status_request_ = const_cast< ::sdpa::messages::JobStatusRequest*>(&::sdpa::messages::JobStatusRequest::default_instance());
    job_status_ = const_cast< ::sdpa::messages::JobStatusReply*>(&::sdpa::messages::JobStatusReply::default_instance());
    job_finished_ = const_cast< ::sdpa::messages::JobFinished*>(&::sdpa::messages::JobFinished::default_instance());
    job_finished_ack_ = const_cast< ::sdpa::messages::JobFinishedAck*>(&::sdpa::messages::JobFinishedAck::default_instance());
    job_failed_ = const_cast< ::sdpa::messages::JobFailed*>(&::sdpa::messages::JobFailed::default_instance());
    job_failed_ack_ = const_cast< ::sdpa::messages::JobFailedAck*>(&::sdpa::messages::JobFailedAck::default_instance());
    life_signal_ = const_cast< ::sdpa::messages::LifeSignal*>(&::sdpa::messages::LifeSignal::default_instance());
    config_request_ = const_cast< ::sdpa::messages::ConfigRequest*>(&::sdpa::messages::ConfigRequest::default_instance());
    config_reply_ = const_cast< ::sdpa::messages::ConfigReply*>(&::sdpa::messages::ConfigReply::default_instance());
  }
}

SDPAMessage::SDPAMessage(const SDPAMessage& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    error_(NULL),
    submit_job_(NULL),
    submit_job_ack_(NULL),
    cancel_job_(NULL),
    cancel_job_ack_(NULL),
    job_status_request_(NULL),
    job_status_(NULL),
    job_finished_(NULL),
    job_finished_ack_(NULL),
    job_failed_(NULL),
    job_failed_ack_(NULL),
    life_signal_(NULL),
    config_request_(NULL),
    config_reply_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

SDPAMessage::~SDPAMessage() {
  if (this != &default_instance_) {
    delete error_;
    delete submit_job_;
    delete submit_job_ack_;
    delete cancel_job_;
    delete cancel_job_ack_;
    delete job_status_request_;
    delete job_status_;
    delete job_finished_;
    delete job_finished_ack_;
    delete job_failed_;
    delete job_failed_ack_;
    delete life_signal_;
    delete config_request_;
    delete config_reply_;
  }
}

const ::google::protobuf::Descriptor* SDPAMessage::descriptor() {
  if (SDPAMessage_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return SDPAMessage_descriptor_;
}

SDPAMessage* SDPAMessage::New() const {
  return new SDPAMessage;
}

void SDPAMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (error_ != NULL) error_->::sdpa::messages::Error::Clear();
    }
    if (_has_bit(1)) {
      if (submit_job_ != NULL) submit_job_->::sdpa::messages::SubmitJob::Clear();
    }
    if (_has_bit(2)) {
      if (submit_job_ack_ != NULL) submit_job_ack_->::sdpa::messages::SubmitJobAck::Clear();
    }
    if (_has_bit(3)) {
      if (cancel_job_ != NULL) cancel_job_->::sdpa::messages::CancelJob::Clear();
    }
    if (_has_bit(4)) {
      if (cancel_job_ack_ != NULL) cancel_job_ack_->::sdpa::messages::CancelJobAck::Clear();
    }
    if (_has_bit(5)) {
      if (job_status_request_ != NULL) job_status_request_->::sdpa::messages::JobStatusRequest::Clear();
    }
    if (_has_bit(6)) {
      if (job_status_ != NULL) job_status_->::sdpa::messages::JobStatusReply::Clear();
    }
    if (_has_bit(7)) {
      if (job_finished_ != NULL) job_finished_->::sdpa::messages::JobFinished::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (_has_bit(8)) {
      if (job_finished_ack_ != NULL) job_finished_ack_->::sdpa::messages::JobFinishedAck::Clear();
    }
    if (_has_bit(9)) {
      if (job_failed_ != NULL) job_failed_->::sdpa::messages::JobFailed::Clear();
    }
    if (_has_bit(10)) {
      if (job_failed_ack_ != NULL) job_failed_ack_->::sdpa::messages::JobFailedAck::Clear();
    }
    if (_has_bit(11)) {
      if (life_signal_ != NULL) life_signal_->::sdpa::messages::LifeSignal::Clear();
    }
    if (_has_bit(12)) {
      if (config_request_ != NULL) config_request_->::sdpa::messages::ConfigRequest::Clear();
    }
    if (_has_bit(13)) {
      if (config_reply_ != NULL) config_reply_->::sdpa::messages::ConfigReply::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SDPAMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional .sdpa.messages.Error error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_error()));
        if (input->ExpectTag(18)) goto parse_submit_job;
        break;
      }
      
      // optional .sdpa.messages.SubmitJob submit_job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_submit_job:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_submit_job()));
        if (input->ExpectTag(26)) goto parse_submit_job_ack;
        break;
      }
      
      // optional .sdpa.messages.SubmitJobAck submit_job_ack = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_submit_job_ack:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_submit_job_ack()));
        if (input->ExpectTag(34)) goto parse_cancel_job;
        break;
      }
      
      // optional .sdpa.messages.CancelJob cancel_job = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_cancel_job:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_cancel_job()));
        if (input->ExpectTag(42)) goto parse_cancel_job_ack;
        break;
      }
      
      // optional .sdpa.messages.CancelJobAck cancel_job_ack = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_cancel_job_ack:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_cancel_job_ack()));
        if (input->ExpectTag(50)) goto parse_job_status_request;
        break;
      }
      
      // optional .sdpa.messages.JobStatusRequest job_status_request = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_job_status_request:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_job_status_request()));
        if (input->ExpectTag(58)) goto parse_job_status;
        break;
      }
      
      // optional .sdpa.messages.JobStatusReply job_status = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_job_status:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_job_status()));
        if (input->ExpectTag(66)) goto parse_job_finished;
        break;
      }
      
      // optional .sdpa.messages.JobFinished job_finished = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_job_finished:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_job_finished()));
        if (input->ExpectTag(74)) goto parse_job_finished_ack;
        break;
      }
      
      // optional .sdpa.messages.JobFinishedAck job_finished_ack = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_job_finished_ack:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_job_finished_ack()));
        if (input->ExpectTag(82)) goto parse_job_failed;
        break;
      }
      
      // optional .sdpa.messages.JobFailed job_failed = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_job_failed:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_job_failed()));
        if (input->ExpectTag(90)) goto parse_job_failed_ack;
        break;
      }
      
      // optional .sdpa.messages.JobFailedAck job_failed_ack = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_job_failed_ack:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_job_failed_ack()));
        if (input->ExpectTag(98)) goto parse_life_signal;
        break;
      }
      
      // optional .sdpa.messages.LifeSignal life_signal = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_life_signal:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_life_signal()));
        if (input->ExpectTag(106)) goto parse_config_request;
        break;
      }
      
      // optional .sdpa.messages.ConfigRequest config_request = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_config_request:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_config_request()));
        if (input->ExpectTag(114)) goto parse_config_reply;
        break;
      }
      
      // optional .sdpa.messages.ConfigReply config_reply = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_config_reply:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_config_reply()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool SDPAMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // optional .sdpa.messages.Error error = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->error(), output));
  }
  
  // optional .sdpa.messages.SubmitJob submit_job = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->submit_job(), output));
  }
  
  // optional .sdpa.messages.SubmitJobAck submit_job_ack = 3;
  if (_has_bit(2)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->submit_job_ack(), output));
  }
  
  // optional .sdpa.messages.CancelJob cancel_job = 4;
  if (_has_bit(3)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(4, this->cancel_job(), output));
  }
  
  // optional .sdpa.messages.CancelJobAck cancel_job_ack = 5;
  if (_has_bit(4)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(5, this->cancel_job_ack(), output));
  }
  
  // optional .sdpa.messages.JobStatusRequest job_status_request = 6;
  if (_has_bit(5)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(6, this->job_status_request(), output));
  }
  
  // optional .sdpa.messages.JobStatusReply job_status = 7;
  if (_has_bit(6)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(7, this->job_status(), output));
  }
  
  // optional .sdpa.messages.JobFinished job_finished = 8;
  if (_has_bit(7)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(8, this->job_finished(), output));
  }
  
  // optional .sdpa.messages.JobFinishedAck job_finished_ack = 9;
  if (_has_bit(8)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(9, this->job_finished_ack(), output));
  }
  
  // optional .sdpa.messages.JobFailed job_failed = 10;
  if (_has_bit(9)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(10, this->job_failed(), output));
  }
  
  // optional .sdpa.messages.JobFailedAck job_failed_ack = 11;
  if (_has_bit(10)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(11, this->job_failed_ack(), output));
  }
  
  // optional .sdpa.messages.LifeSignal life_signal = 12;
  if (_has_bit(11)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(12, this->life_signal(), output));
  }
  
  // optional .sdpa.messages.ConfigRequest config_request = 13;
  if (_has_bit(12)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(13, this->config_request(), output));
  }
  
  // optional .sdpa.messages.ConfigReply config_reply = 14;
  if (_has_bit(13)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(14, this->config_reply(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int SDPAMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .sdpa.messages.Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->error());
    }
    
    // optional .sdpa.messages.SubmitJob submit_job = 2;
    if (has_submit_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->submit_job());
    }
    
    // optional .sdpa.messages.SubmitJobAck submit_job_ack = 3;
    if (has_submit_job_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->submit_job_ack());
    }
    
    // optional .sdpa.messages.CancelJob cancel_job = 4;
    if (has_cancel_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->cancel_job());
    }
    
    // optional .sdpa.messages.CancelJobAck cancel_job_ack = 5;
    if (has_cancel_job_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->cancel_job_ack());
    }
    
    // optional .sdpa.messages.JobStatusRequest job_status_request = 6;
    if (has_job_status_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->job_status_request());
    }
    
    // optional .sdpa.messages.JobStatusReply job_status = 7;
    if (has_job_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->job_status());
    }
    
    // optional .sdpa.messages.JobFinished job_finished = 8;
    if (has_job_finished()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->job_finished());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .sdpa.messages.JobFinishedAck job_finished_ack = 9;
    if (has_job_finished_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->job_finished_ack());
    }
    
    // optional .sdpa.messages.JobFailed job_failed = 10;
    if (has_job_failed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->job_failed());
    }
    
    // optional .sdpa.messages.JobFailedAck job_failed_ack = 11;
    if (has_job_failed_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->job_failed_ack());
    }
    
    // optional .sdpa.messages.LifeSignal life_signal = 12;
    if (has_life_signal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->life_signal());
    }
    
    // optional .sdpa.messages.ConfigRequest config_request = 13;
    if (has_config_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->config_request());
    }
    
    // optional .sdpa.messages.ConfigReply config_reply = 14;
    if (has_config_reply()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->config_reply());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void SDPAMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SDPAMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SDPAMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void SDPAMessage::MergeFrom(const SDPAMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_error()->::sdpa::messages::Error::MergeFrom(from.error());
    }
    if (from._has_bit(1)) {
      mutable_submit_job()->::sdpa::messages::SubmitJob::MergeFrom(from.submit_job());
    }
    if (from._has_bit(2)) {
      mutable_submit_job_ack()->::sdpa::messages::SubmitJobAck::MergeFrom(from.submit_job_ack());
    }
    if (from._has_bit(3)) {
      mutable_cancel_job()->::sdpa::messages::CancelJob::MergeFrom(from.cancel_job());
    }
    if (from._has_bit(4)) {
      mutable_cancel_job_ack()->::sdpa::messages::CancelJobAck::MergeFrom(from.cancel_job_ack());
    }
    if (from._has_bit(5)) {
      mutable_job_status_request()->::sdpa::messages::JobStatusRequest::MergeFrom(from.job_status_request());
    }
    if (from._has_bit(6)) {
      mutable_job_status()->::sdpa::messages::JobStatusReply::MergeFrom(from.job_status());
    }
    if (from._has_bit(7)) {
      mutable_job_finished()->::sdpa::messages::JobFinished::MergeFrom(from.job_finished());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      mutable_job_finished_ack()->::sdpa::messages::JobFinishedAck::MergeFrom(from.job_finished_ack());
    }
    if (from._has_bit(9)) {
      mutable_job_failed()->::sdpa::messages::JobFailed::MergeFrom(from.job_failed());
    }
    if (from._has_bit(10)) {
      mutable_job_failed_ack()->::sdpa::messages::JobFailedAck::MergeFrom(from.job_failed_ack());
    }
    if (from._has_bit(11)) {
      mutable_life_signal()->::sdpa::messages::LifeSignal::MergeFrom(from.life_signal());
    }
    if (from._has_bit(12)) {
      mutable_config_request()->::sdpa::messages::ConfigRequest::MergeFrom(from.config_request());
    }
    if (from._has_bit(13)) {
      mutable_config_reply()->::sdpa::messages::ConfigReply::MergeFrom(from.config_reply());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SDPAMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SDPAMessage::CopyFrom(const SDPAMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SDPAMessage::IsInitialized() const {
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  if (has_submit_job()) {
    if (!this->submit_job().IsInitialized()) return false;
  }
  if (has_submit_job_ack()) {
    if (!this->submit_job_ack().IsInitialized()) return false;
  }
  if (has_cancel_job()) {
    if (!this->cancel_job().IsInitialized()) return false;
  }
  if (has_cancel_job_ack()) {
    if (!this->cancel_job_ack().IsInitialized()) return false;
  }
  if (has_job_status_request()) {
    if (!this->job_status_request().IsInitialized()) return false;
  }
  if (has_job_status()) {
    if (!this->job_status().IsInitialized()) return false;
  }
  if (has_job_finished()) {
    if (!this->job_finished().IsInitialized()) return false;
  }
  if (has_job_finished_ack()) {
    if (!this->job_finished_ack().IsInitialized()) return false;
  }
  if (has_job_failed()) {
    if (!this->job_failed().IsInitialized()) return false;
  }
  if (has_job_failed_ack()) {
    if (!this->job_failed_ack().IsInitialized()) return false;
  }
  if (has_life_signal()) {
    if (!this->life_signal().IsInitialized()) return false;
  }
  if (has_config_request()) {
    if (!this->config_request().IsInitialized()) return false;
  }
  if (has_config_reply()) {
    if (!this->config_reply().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* SDPAMessage::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
SDPAMessage::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* SDPAMessage::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const Error Error::default_instance_;


const ::std::string Error::_default_error_description_;
const int Error::_offsets_[2] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, error_code_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, error_description_),
};

Error::Error()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    error_code_(0),
    error_description_(const_cast< ::std::string*>(&_default_error_description_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

Error::Error(const Error& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    error_code_(0),
    error_description_(const_cast< ::std::string*>(&_default_error_description_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

Error::~Error() {
  if (error_description_ != &_default_error_description_) {
    delete error_description_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Error::descriptor() {
  if (Error_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return Error_descriptor_;
}

Error* Error::New() const {
  return new Error;
}

void Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0;
    if (_has_bit(1)) {
      if (error_description_ != &_default_error_description_) {
        error_description_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .sdpa.messages.ErrorCode error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (sdpa::messages::ErrorCode_IsValid(value)) {
          set_error_code(static_cast< sdpa::messages::ErrorCode >(value));
        } else {
          mutable_unknown_fields()->AddField(1)->add_varint(value);
        }
        if (input->ExpectTag(18)) goto parse_error_description;
        break;
      }
      
      // required string error_description = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_error_description:
        DO_(::google::protobuf::internal::WireFormat::ReadString(input, mutable_error_description()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required .sdpa.messages.ErrorCode error_code = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteEnum(1, this->error_code(), output));
  }
  
  // required string error_description = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteString(2, this->error_description(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int Error::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .sdpa.messages.ErrorCode error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->error_code());
    }
    
    // required string error_description = 2;
    if (has_error_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::StringSize(this->error_description());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Error::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Error* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Error*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void Error::MergeFrom(const Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_error_code(from.error_code());
    }
    if (from._has_bit(1)) {
      set_error_description(from.error_description());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* Error::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
Error::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* Error::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const Token Token::default_instance_;

const ::std::string Token::_default_place_;
const ::std::string Token::_default_token_;
const int Token::_offsets_[2] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, place_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, token_),
};

Token::Token()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    place_(const_cast< ::std::string*>(&_default_place_)),
    token_(const_cast< ::std::string*>(&_default_token_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

Token::Token(const Token& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    place_(const_cast< ::std::string*>(&_default_place_)),
    token_(const_cast< ::std::string*>(&_default_token_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

Token::~Token() {
  if (place_ != &_default_place_) {
    delete place_;
  }
  if (token_ != &_default_token_) {
    delete token_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Token::descriptor() {
  if (Token_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return Token_descriptor_;
}

Token* Token::New() const {
  return new Token;
}

void Token::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (place_ != &_default_place_) {
        place_->clear();
      }
    }
    if (_has_bit(1)) {
      if (token_ != &_default_token_) {
        token_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Token::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes place = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_place()));
        if (input->ExpectTag(18)) goto parse_token;
        break;
      }
      
      // required bytes token = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_token:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_token()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool Token::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes place = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->place(), output));
  }
  
  // required bytes token = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(2, this->token(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int Token::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes place = 1;
    if (has_place()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->place());
    }
    
    // required bytes token = 2;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->token());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Token::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Token* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Token*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void Token::MergeFrom(const Token& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_place(from.place());
    }
    if (from._has_bit(1)) {
      set_token(from.token());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Token::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Token::CopyFrom(const Token& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Token::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* Token::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
Token::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* Token::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const SubmitJob SubmitJob::default_instance_;

const ::std::string SubmitJob::_default_workflow_;

const int SubmitJob::_offsets_[2] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitJob, workflow_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitJob, input_),
};

SubmitJob::SubmitJob()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    workflow_(const_cast< ::std::string*>(&_default_workflow_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

SubmitJob::SubmitJob(const SubmitJob& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    workflow_(const_cast< ::std::string*>(&_default_workflow_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

SubmitJob::~SubmitJob() {
  if (workflow_ != &_default_workflow_) {
    delete workflow_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* SubmitJob::descriptor() {
  if (SubmitJob_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return SubmitJob_descriptor_;
}

SubmitJob* SubmitJob::New() const {
  return new SubmitJob;
}

void SubmitJob::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (workflow_ != &_default_workflow_) {
        workflow_->clear();
      }
    }
  }
  input_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubmitJob::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes workflow = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_workflow()));
        if (input->ExpectTag(18)) goto parse_input;
        break;
      }
      
      // repeated .sdpa.messages.Token input = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_input:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_input()));
        if (input->ExpectTag(18)) goto parse_input;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool SubmitJob::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes workflow = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->workflow(), output));
  }
  
  // repeated .sdpa.messages.Token input = 2;
  for (int i = 0; i < input_.size(); i++) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->input(i), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int SubmitJob::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes workflow = 1;
    if (has_workflow()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->workflow());
    }
    
  }
  // repeated .sdpa.messages.Token input = 2;
  total_size += 1 * input_size();
  for (int i = 0; i < input_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->input(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void SubmitJob::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubmitJob* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubmitJob*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void SubmitJob::MergeFrom(const SubmitJob& from) {
  GOOGLE_CHECK_NE(&from, this);
  input_.MergeFrom(from.input_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_workflow(from.workflow());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubmitJob::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubmitJob::CopyFrom(const SubmitJob& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubmitJob::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < input_size(); i++) {
    if (!this->input(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* SubmitJob::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
SubmitJob::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* SubmitJob::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const SubmitJobAck SubmitJobAck::default_instance_;

const ::std::string SubmitJobAck::_default_job_id_;
const int SubmitJobAck::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitJobAck, job_id_),
};

SubmitJobAck::SubmitJobAck()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

SubmitJobAck::SubmitJobAck(const SubmitJobAck& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

SubmitJobAck::~SubmitJobAck() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* SubmitJobAck::descriptor() {
  if (SubmitJobAck_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return SubmitJobAck_descriptor_;
}

SubmitJobAck* SubmitJobAck::New() const {
  return new SubmitJobAck;
}

void SubmitJobAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubmitJobAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool SubmitJobAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int SubmitJobAck::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void SubmitJobAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubmitJobAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubmitJobAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void SubmitJobAck::MergeFrom(const SubmitJobAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubmitJobAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubmitJobAck::CopyFrom(const SubmitJobAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubmitJobAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* SubmitJobAck::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
SubmitJobAck::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* SubmitJobAck::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const CancelJob CancelJob::default_instance_;

const ::std::string CancelJob::_default_job_id_;
const ::std::string CancelJob::_default_reason_;
const int CancelJob::_offsets_[2] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelJob, job_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelJob, reason_),
};

CancelJob::CancelJob()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)),
    reason_(const_cast< ::std::string*>(&_default_reason_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

CancelJob::CancelJob(const CancelJob& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)),
    reason_(const_cast< ::std::string*>(&_default_reason_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

CancelJob::~CancelJob() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (reason_ != &_default_reason_) {
    delete reason_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* CancelJob::descriptor() {
  if (CancelJob_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return CancelJob_descriptor_;
}

CancelJob* CancelJob::New() const {
  return new CancelJob;
}

void CancelJob::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
    if (_has_bit(1)) {
      if (reason_ != &_default_reason_) {
        reason_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CancelJob::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectTag(18)) goto parse_reason;
        break;
      }
      
      // optional string reason = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_reason:
        DO_(::google::protobuf::internal::WireFormat::ReadString(input, mutable_reason()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool CancelJob::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  // optional string reason = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteString(2, this->reason(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int CancelJob::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
    // optional string reason = 2;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::StringSize(this->reason());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void CancelJob::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CancelJob* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CancelJob*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void CancelJob::MergeFrom(const CancelJob& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
    if (from._has_bit(1)) {
      set_reason(from.reason());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CancelJob::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CancelJob::CopyFrom(const CancelJob& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelJob::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* CancelJob::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
CancelJob::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* CancelJob::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const CancelJobAck CancelJobAck::default_instance_;

const ::std::string CancelJobAck::_default_job_id_;
const int CancelJobAck::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelJobAck, job_id_),
};

CancelJobAck::CancelJobAck()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

CancelJobAck::CancelJobAck(const CancelJobAck& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

CancelJobAck::~CancelJobAck() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* CancelJobAck::descriptor() {
  if (CancelJobAck_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return CancelJobAck_descriptor_;
}

CancelJobAck* CancelJobAck::New() const {
  return new CancelJobAck;
}

void CancelJobAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CancelJobAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool CancelJobAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int CancelJobAck::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void CancelJobAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CancelJobAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CancelJobAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void CancelJobAck::MergeFrom(const CancelJobAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CancelJobAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CancelJobAck::CopyFrom(const CancelJobAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelJobAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* CancelJobAck::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
CancelJobAck::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* CancelJobAck::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const JobStatusRequest JobStatusRequest::default_instance_;

const ::std::string JobStatusRequest::_default_job_id_;
const int JobStatusRequest::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobStatusRequest, job_id_),
};

JobStatusRequest::JobStatusRequest()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

JobStatusRequest::JobStatusRequest(const JobStatusRequest& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

JobStatusRequest::~JobStatusRequest() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* JobStatusRequest::descriptor() {
  if (JobStatusRequest_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return JobStatusRequest_descriptor_;
}

JobStatusRequest* JobStatusRequest::New() const {
  return new JobStatusRequest;
}

void JobStatusRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JobStatusRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool JobStatusRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int JobStatusRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void JobStatusRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JobStatusRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JobStatusRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void JobStatusRequest::MergeFrom(const JobStatusRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JobStatusRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JobStatusRequest::CopyFrom(const JobStatusRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JobStatusRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* JobStatusRequest::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
JobStatusRequest::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* JobStatusRequest::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const JobStatusReply JobStatusReply::default_instance_;

const ::std::string JobStatusReply::_default_job_id_;

const int JobStatusReply::_offsets_[2] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobStatusReply, job_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobStatusReply, state_),
};

JobStatusReply::JobStatusReply()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)),
    state_(0) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

JobStatusReply::JobStatusReply(const JobStatusReply& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)),
    state_(0) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

JobStatusReply::~JobStatusReply() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* JobStatusReply::descriptor() {
  if (JobStatusReply_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return JobStatusReply_descriptor_;
}

JobStatusReply* JobStatusReply::New() const {
  return new JobStatusReply;
}

void JobStatusReply::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
    state_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JobStatusReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }
      
      // required .sdpa.messages.JobState state = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_state:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (sdpa::messages::JobState_IsValid(value)) {
          set_state(static_cast< sdpa::messages::JobState >(value));
        } else {
          mutable_unknown_fields()->AddField(2)->add_varint(value);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool JobStatusReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  // required .sdpa.messages.JobState state = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteEnum(2, this->state(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int JobStatusReply::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
    // required .sdpa.messages.JobState state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->state());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void JobStatusReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JobStatusReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JobStatusReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void JobStatusReply::MergeFrom(const JobStatusReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
    if (from._has_bit(1)) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JobStatusReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JobStatusReply::CopyFrom(const JobStatusReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JobStatusReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* JobStatusReply::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
JobStatusReply::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* JobStatusReply::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const JobFinished JobFinished::default_instance_;

const ::std::string JobFinished::_default_job_id_;
const int JobFinished::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobFinished, job_id_),
};

JobFinished::JobFinished()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

JobFinished::JobFinished(const JobFinished& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

JobFinished::~JobFinished() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* JobFinished::descriptor() {
  if (JobFinished_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return JobFinished_descriptor_;
}

JobFinished* JobFinished::New() const {
  return new JobFinished;
}

void JobFinished::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JobFinished::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool JobFinished::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int JobFinished::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void JobFinished::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JobFinished* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JobFinished*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void JobFinished::MergeFrom(const JobFinished& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JobFinished::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JobFinished::CopyFrom(const JobFinished& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JobFinished::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* JobFinished::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
JobFinished::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* JobFinished::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const JobFinishedAck JobFinishedAck::default_instance_;

const ::std::string JobFinishedAck::_default_job_id_;
const int JobFinishedAck::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobFinishedAck, job_id_),
};

JobFinishedAck::JobFinishedAck()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

JobFinishedAck::JobFinishedAck(const JobFinishedAck& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

JobFinishedAck::~JobFinishedAck() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* JobFinishedAck::descriptor() {
  if (JobFinishedAck_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return JobFinishedAck_descriptor_;
}

JobFinishedAck* JobFinishedAck::New() const {
  return new JobFinishedAck;
}

void JobFinishedAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JobFinishedAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool JobFinishedAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int JobFinishedAck::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void JobFinishedAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JobFinishedAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JobFinishedAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void JobFinishedAck::MergeFrom(const JobFinishedAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JobFinishedAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JobFinishedAck::CopyFrom(const JobFinishedAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JobFinishedAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* JobFinishedAck::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
JobFinishedAck::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* JobFinishedAck::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const JobFailed JobFailed::default_instance_;

const ::std::string JobFailed::_default_job_id_;
const int JobFailed::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobFailed, job_id_),
};

JobFailed::JobFailed()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

JobFailed::JobFailed(const JobFailed& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

JobFailed::~JobFailed() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* JobFailed::descriptor() {
  if (JobFailed_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return JobFailed_descriptor_;
}

JobFailed* JobFailed::New() const {
  return new JobFailed;
}

void JobFailed::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JobFailed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool JobFailed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int JobFailed::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void JobFailed::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JobFailed* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JobFailed*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void JobFailed::MergeFrom(const JobFailed& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JobFailed::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JobFailed::CopyFrom(const JobFailed& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JobFailed::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* JobFailed::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
JobFailed::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* JobFailed::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const JobFailedAck JobFailedAck::default_instance_;

const ::std::string JobFailedAck::_default_job_id_;
const int JobFailedAck::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobFailedAck, job_id_),
};

JobFailedAck::JobFailedAck()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

JobFailedAck::JobFailedAck(const JobFailedAck& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    job_id_(const_cast< ::std::string*>(&_default_job_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

JobFailedAck::~JobFailedAck() {
  if (job_id_ != &_default_job_id_) {
    delete job_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* JobFailedAck::descriptor() {
  if (JobFailedAck_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return JobFailedAck_descriptor_;
}

JobFailedAck* JobFailedAck::New() const {
  return new JobFailedAck;
}

void JobFailedAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (job_id_ != &_default_job_id_) {
        job_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JobFailedAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes job_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_job_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool JobFailedAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes job_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->job_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int JobFailedAck::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes job_id = 1;
    if (has_job_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->job_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void JobFailedAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JobFailedAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JobFailedAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void JobFailedAck::MergeFrom(const JobFailedAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_job_id(from.job_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JobFailedAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JobFailedAck::CopyFrom(const JobFailedAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JobFailedAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* JobFailedAck::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
JobFailedAck::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* JobFailedAck::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const LifeSignal LifeSignal::default_instance_;


const ::std::string LifeSignal::_default_component_id_;
const int LifeSignal::_offsets_[2] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LifeSignal, timestamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LifeSignal, component_id_),
};

LifeSignal::LifeSignal()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    timestamp_(GOOGLE_ULONGLONG(0)),
    component_id_(const_cast< ::std::string*>(&_default_component_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

LifeSignal::LifeSignal(const LifeSignal& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    timestamp_(GOOGLE_ULONGLONG(0)),
    component_id_(const_cast< ::std::string*>(&_default_component_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

LifeSignal::~LifeSignal() {
  if (component_id_ != &_default_component_id_) {
    delete component_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* LifeSignal::descriptor() {
  if (LifeSignal_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return LifeSignal_descriptor_;
}

LifeSignal* LifeSignal::New() const {
  return new LifeSignal;
}

void LifeSignal::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = GOOGLE_ULONGLONG(0);
    if (_has_bit(1)) {
      if (component_id_ != &_default_component_id_) {
        component_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LifeSignal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required fixed64 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadFixed64(
              input, &timestamp_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_component_id;
        break;
      }
      
      // required bytes component_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_component_id:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_component_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool LifeSignal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required fixed64 timestamp = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteFixed64(1, this->timestamp(), output));
  }
  
  // required bytes component_id = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(2, this->component_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int LifeSignal::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed64 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }
    
    // required bytes component_id = 2;
    if (has_component_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->component_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void LifeSignal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LifeSignal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LifeSignal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void LifeSignal::MergeFrom(const LifeSignal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_timestamp(from.timestamp());
    }
    if (from._has_bit(1)) {
      set_component_id(from.component_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LifeSignal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LifeSignal::CopyFrom(const LifeSignal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LifeSignal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* LifeSignal::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
LifeSignal::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* LifeSignal::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const ConfigRequest ConfigRequest::default_instance_;

const ::std::string ConfigRequest::_default_component_id_;
const int ConfigRequest::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConfigRequest, component_id_),
};

ConfigRequest::ConfigRequest()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    component_id_(const_cast< ::std::string*>(&_default_component_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

ConfigRequest::ConfigRequest(const ConfigRequest& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    component_id_(const_cast< ::std::string*>(&_default_component_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

ConfigRequest::~ConfigRequest() {
  if (component_id_ != &_default_component_id_) {
    delete component_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* ConfigRequest::descriptor() {
  if (ConfigRequest_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return ConfigRequest_descriptor_;
}

ConfigRequest* ConfigRequest::New() const {
  return new ConfigRequest;
}

void ConfigRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (component_id_ != &_default_component_id_) {
        component_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConfigRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes component_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_component_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool ConfigRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes component_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->component_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int ConfigRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes component_id = 1;
    if (has_component_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->component_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void ConfigRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConfigRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConfigRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void ConfigRequest::MergeFrom(const ConfigRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_component_id(from.component_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConfigRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConfigRequest::CopyFrom(const ConfigRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* ConfigRequest::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
ConfigRequest::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* ConfigRequest::GetReflection() {
  return &_reflection_;
}

// ===================================================================

const ConfigReply ConfigReply::default_instance_;

const ::std::string ConfigReply::_default_component_id_;
const int ConfigReply::_offsets_[1] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConfigReply, component_id_),
};

ConfigReply::ConfigReply()
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    component_id_(const_cast< ::std::string*>(&_default_component_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (this == &default_instance_) {
  }
}

ConfigReply::ConfigReply(const ConfigReply& from)
  : _reflection_(descriptor(),
                 this, &default_instance_,
                 _offsets_, _has_bits_, NULL),
    _cached_size_(0),
    component_id_(const_cast< ::std::string*>(&_default_component_id_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

ConfigReply::~ConfigReply() {
  if (component_id_ != &_default_component_id_) {
    delete component_id_;
  }
  if (this != &default_instance_) {
  }
}

const ::google::protobuf::Descriptor* ConfigReply::descriptor() {
  if (ConfigReply_descriptor_ == NULL) proto_BuildDescriptors_sdpa_2dmsg_2eproto();
  return ConfigReply_descriptor_;
}

ConfigReply* ConfigReply::New() const {
  return new ConfigReply;
}

void ConfigReply::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (component_id_ != &_default_component_id_) {
        component_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConfigReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes component_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_component_id()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool ConfigReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes component_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->component_id(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int ConfigReply::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes component_id = 1;
    if (has_component_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->component_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void ConfigReply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConfigReply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConfigReply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(
      descriptor(), *from.GetReflection(), &_reflection_);
  } else {
    MergeFrom(*source);
  }
}

void ConfigReply::MergeFrom(const ConfigReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_component_id(from.component_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConfigReply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConfigReply::CopyFrom(const ConfigReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* ConfigReply::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Message::Reflection*
ConfigReply::GetReflection() const {
  return &_reflection_;
}

::google::protobuf::Message::Reflection* ConfigReply::GetReflection() {
  return &_reflection_;
}

}  // namespace messages
}  // namespace sdpa
