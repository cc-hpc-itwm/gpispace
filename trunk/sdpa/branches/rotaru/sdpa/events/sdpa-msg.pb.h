// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_sdpa_2dmsg_2eproto__INCLUDED
#define PROTOBUF_sdpa_2dmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace sdpa {
namespace events {

class SDPAMessage;
class Error;
class Token;
class SubmitJob;
class SubmitJobAck;
class CancelJob;
class CancelJobAck;
class JobStatusRequest;
class JobStatusReply;
class JobFinished;
class JobFinishedAck;
class JobFailed;
class JobFailedAck;
class LifeSignal;
class ConfigRequest;
class ConfigReply;

enum ErrorCode {
  OK = 0,
};
const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = OK;
const ErrorCode ErrorCode_MAX = OK;

enum JobState {
  UNKNOWN = 0,
  PENDING = 1,
  RUNNING = 2,
  FINISHED = 3,
  FAILED = 4,
  CANCELLED = 5,
  CANCELLING = 6,
};
const ::google::protobuf::EnumDescriptor* JobState_descriptor();
bool JobState_IsValid(int value);
const JobState JobState_MIN = UNKNOWN;
const JobState JobState_MAX = CANCELLING;

// ===================================================================

class SDPAMessage : public ::google::protobuf::Message {
 public:
  SDPAMessage();
  virtual ~SDPAMessage();
  
  SDPAMessage(const SDPAMessage& from);
  
  inline SDPAMessage& operator=(const SDPAMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const SDPAMessage& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  SDPAMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SDPAMessage& from);
  void MergeFrom(const SDPAMessage& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .sdpa.events.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  inline const ::sdpa::events::Error& error() const;
  inline ::sdpa::events::Error* mutable_error();
  
  // optional .sdpa.events.SubmitJob submit_job = 2;
  inline bool has_submit_job() const;
  inline void clear_submit_job();
  inline const ::sdpa::events::SubmitJob& submit_job() const;
  inline ::sdpa::events::SubmitJob* mutable_submit_job();
  
  // optional .sdpa.events.SubmitJobAck submit_job_ack = 3;
  inline bool has_submit_job_ack() const;
  inline void clear_submit_job_ack();
  inline const ::sdpa::events::SubmitJobAck& submit_job_ack() const;
  inline ::sdpa::events::SubmitJobAck* mutable_submit_job_ack();
  
  // optional .sdpa.events.CancelJob cancel_job = 4;
  inline bool has_cancel_job() const;
  inline void clear_cancel_job();
  inline const ::sdpa::events::CancelJob& cancel_job() const;
  inline ::sdpa::events::CancelJob* mutable_cancel_job();
  
  // optional .sdpa.events.CancelJobAck cancel_job_ack = 5;
  inline bool has_cancel_job_ack() const;
  inline void clear_cancel_job_ack();
  inline const ::sdpa::events::CancelJobAck& cancel_job_ack() const;
  inline ::sdpa::events::CancelJobAck* mutable_cancel_job_ack();
  
  // optional .sdpa.events.JobStatusRequest job_status_request = 6;
  inline bool has_job_status_request() const;
  inline void clear_job_status_request();
  inline const ::sdpa::events::JobStatusRequest& job_status_request() const;
  inline ::sdpa::events::JobStatusRequest* mutable_job_status_request();
  
  // optional .sdpa.events.JobStatusReply job_status = 7;
  inline bool has_job_status() const;
  inline void clear_job_status();
  inline const ::sdpa::events::JobStatusReply& job_status() const;
  inline ::sdpa::events::JobStatusReply* mutable_job_status();
  
  // optional .sdpa.events.JobFinished job_finished = 8;
  inline bool has_job_finished() const;
  inline void clear_job_finished();
  inline const ::sdpa::events::JobFinished& job_finished() const;
  inline ::sdpa::events::JobFinished* mutable_job_finished();
  
  // optional .sdpa.events.JobFinishedAck job_finished_ack = 9;
  inline bool has_job_finished_ack() const;
  inline void clear_job_finished_ack();
  inline const ::sdpa::events::JobFinishedAck& job_finished_ack() const;
  inline ::sdpa::events::JobFinishedAck* mutable_job_finished_ack();
  
  // optional .sdpa.events.JobFailed job_failed = 10;
  inline bool has_job_failed() const;
  inline void clear_job_failed();
  inline const ::sdpa::events::JobFailed& job_failed() const;
  inline ::sdpa::events::JobFailed* mutable_job_failed();
  
  // optional .sdpa.events.JobFailedAck job_failed_ack = 11;
  inline bool has_job_failed_ack() const;
  inline void clear_job_failed_ack();
  inline const ::sdpa::events::JobFailedAck& job_failed_ack() const;
  inline ::sdpa::events::JobFailedAck* mutable_job_failed_ack();
  
  // optional .sdpa.events.LifeSignal life_signal = 12;
  inline bool has_life_signal() const;
  inline void clear_life_signal();
  inline const ::sdpa::events::LifeSignal& life_signal() const;
  inline ::sdpa::events::LifeSignal* mutable_life_signal();
  
  // optional .sdpa.events.ConfigRequest config_request = 13;
  inline bool has_config_request() const;
  inline void clear_config_request();
  inline const ::sdpa::events::ConfigRequest& config_request() const;
  inline ::sdpa::events::ConfigRequest* mutable_config_request();
  
  // optional .sdpa.events.ConfigReply config_reply = 14;
  inline bool has_config_reply() const;
  inline void clear_config_reply();
  inline const ::sdpa::events::ConfigReply& config_reply() const;
  inline ::sdpa::events::ConfigReply* mutable_config_reply();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::sdpa::events::Error* error_;
  ::sdpa::events::SubmitJob* submit_job_;
  ::sdpa::events::SubmitJobAck* submit_job_ack_;
  ::sdpa::events::CancelJob* cancel_job_;
  ::sdpa::events::CancelJobAck* cancel_job_ack_;
  ::sdpa::events::JobStatusRequest* job_status_request_;
  ::sdpa::events::JobStatusReply* job_status_;
  ::sdpa::events::JobFinished* job_finished_;
  ::sdpa::events::JobFinishedAck* job_finished_ack_;
  ::sdpa::events::JobFailed* job_failed_;
  ::sdpa::events::JobFailedAck* job_failed_ack_;
  ::sdpa::events::LifeSignal* life_signal_;
  ::sdpa::events::ConfigRequest* config_request_;
  ::sdpa::events::ConfigReply* config_reply_;
  
  static const SDPAMessage default_instance_;
  static const int _offsets_[14];
  
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const Error& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .sdpa.events.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  inline sdpa::events::ErrorCode error_code() const;
  inline void set_error_code(sdpa::events::ErrorCode value);
  
  // required string error_description = 2;
  inline bool has_error_description() const;
  inline void clear_error_description();
  inline const ::std::string& error_description() const;
  inline void set_error_description(const ::std::string& value);
  inline void set_error_description(const char* value);
  inline ::std::string* mutable_error_description();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  int error_code_;
  ::std::string* error_description_;
  static const ::std::string _default_error_description_;
  
  static const Error default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class Token : public ::google::protobuf::Message {
 public:
  Token();
  virtual ~Token();
  
  Token(const Token& from);
  
  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const Token& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  Token* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes place = 1;
  inline bool has_place() const;
  inline void clear_place();
  inline const ::std::string& place() const;
  inline void set_place(const ::std::string& value);
  inline void set_place(const char* value);
  inline ::std::string* mutable_place();
  
  // required bytes token = 2;
  inline bool has_token() const;
  inline void clear_token();
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline ::std::string* mutable_token();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* place_;
  static const ::std::string _default_place_;
  ::std::string* token_;
  static const ::std::string _default_token_;
  
  static const Token default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class SubmitJob : public ::google::protobuf::Message {
 public:
  SubmitJob();
  virtual ~SubmitJob();
  
  SubmitJob(const SubmitJob& from);
  
  inline SubmitJob& operator=(const SubmitJob& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const SubmitJob& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  SubmitJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitJob& from);
  void MergeFrom(const SubmitJob& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes workflow = 1;
  inline bool has_workflow() const;
  inline void clear_workflow();
  inline const ::std::string& workflow() const;
  inline void set_workflow(const ::std::string& value);
  inline void set_workflow(const char* value);
  inline ::std::string* mutable_workflow();
  
  // repeated .sdpa.events.Token input = 2;
  inline int input_size() const;
  inline void clear_input();
  inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >* mutable_input();
  inline const ::sdpa::events::Token& input(int index) const;
  inline ::sdpa::events::Token* mutable_input(int index);
  inline ::sdpa::events::Token* add_input();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* workflow_;
  static const ::std::string _default_workflow_;
  ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token > input_;
  
  static const SubmitJob default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class SubmitJobAck : public ::google::protobuf::Message {
 public:
  SubmitJobAck();
  virtual ~SubmitJobAck();
  
  SubmitJobAck(const SubmitJobAck& from);
  
  inline SubmitJobAck& operator=(const SubmitJobAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const SubmitJobAck& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  SubmitJobAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitJobAck& from);
  void MergeFrom(const SubmitJobAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  
  static const SubmitJobAck default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class CancelJob : public ::google::protobuf::Message {
 public:
  CancelJob();
  virtual ~CancelJob();
  
  CancelJob(const CancelJob& from);
  
  inline CancelJob& operator=(const CancelJob& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const CancelJob& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  CancelJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelJob& from);
  void MergeFrom(const CancelJob& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
  // optional string reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline ::std::string* mutable_reason();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  
  static const CancelJob default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class CancelJobAck : public ::google::protobuf::Message {
 public:
  CancelJobAck();
  virtual ~CancelJobAck();
  
  CancelJobAck(const CancelJobAck& from);
  
  inline CancelJobAck& operator=(const CancelJobAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const CancelJobAck& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  CancelJobAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelJobAck& from);
  void MergeFrom(const CancelJobAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  
  static const CancelJobAck default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class JobStatusRequest : public ::google::protobuf::Message {
 public:
  JobStatusRequest();
  virtual ~JobStatusRequest();
  
  JobStatusRequest(const JobStatusRequest& from);
  
  inline JobStatusRequest& operator=(const JobStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const JobStatusRequest& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  JobStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobStatusRequest& from);
  void MergeFrom(const JobStatusRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  
  static const JobStatusRequest default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class JobStatusReply : public ::google::protobuf::Message {
 public:
  JobStatusReply();
  virtual ~JobStatusReply();
  
  JobStatusReply(const JobStatusReply& from);
  
  inline JobStatusReply& operator=(const JobStatusReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const JobStatusReply& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  JobStatusReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobStatusReply& from);
  void MergeFrom(const JobStatusReply& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
  // required .sdpa.events.JobState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  inline sdpa::events::JobState state() const;
  inline void set_state(sdpa::events::JobState value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  int state_;
  
  static const JobStatusReply default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class JobFinished : public ::google::protobuf::Message {
 public:
  JobFinished();
  virtual ~JobFinished();
  
  JobFinished(const JobFinished& from);
  
  inline JobFinished& operator=(const JobFinished& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const JobFinished& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  JobFinished* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFinished& from);
  void MergeFrom(const JobFinished& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  
  static const JobFinished default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class JobFinishedAck : public ::google::protobuf::Message {
 public:
  JobFinishedAck();
  virtual ~JobFinishedAck();
  
  JobFinishedAck(const JobFinishedAck& from);
  
  inline JobFinishedAck& operator=(const JobFinishedAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const JobFinishedAck& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  JobFinishedAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFinishedAck& from);
  void MergeFrom(const JobFinishedAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  
  static const JobFinishedAck default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class JobFailed : public ::google::protobuf::Message {
 public:
  JobFailed();
  virtual ~JobFailed();
  
  JobFailed(const JobFailed& from);
  
  inline JobFailed& operator=(const JobFailed& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const JobFailed& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  JobFailed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFailed& from);
  void MergeFrom(const JobFailed& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  
  static const JobFailed default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class JobFailedAck : public ::google::protobuf::Message {
 public:
  JobFailedAck();
  virtual ~JobFailedAck();
  
  JobFailedAck(const JobFailedAck& from);
  
  inline JobFailedAck& operator=(const JobFailedAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const JobFailedAck& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  JobFailedAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobFailedAck& from);
  void MergeFrom(const JobFailedAck& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline ::std::string* mutable_job_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* job_id_;
  static const ::std::string _default_job_id_;
  
  static const JobFailedAck default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LifeSignal : public ::google::protobuf::Message {
 public:
  LifeSignal();
  virtual ~LifeSignal();
  
  LifeSignal(const LifeSignal& from);
  
  inline LifeSignal& operator=(const LifeSignal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LifeSignal& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LifeSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LifeSignal& from);
  void MergeFrom(const LifeSignal& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // required bytes component_id = 2;
  inline bool has_component_id() const;
  inline void clear_component_id();
  inline const ::std::string& component_id() const;
  inline void set_component_id(const ::std::string& value);
  inline void set_component_id(const char* value);
  inline ::std::string* mutable_component_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 timestamp_;
  ::std::string* component_id_;
  static const ::std::string _default_component_id_;
  
  static const LifeSignal default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class ConfigRequest : public ::google::protobuf::Message {
 public:
  ConfigRequest();
  virtual ~ConfigRequest();
  
  ConfigRequest(const ConfigRequest& from);
  
  inline ConfigRequest& operator=(const ConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const ConfigRequest& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  ConfigRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigRequest& from);
  void MergeFrom(const ConfigRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes component_id = 1;
  inline bool has_component_id() const;
  inline void clear_component_id();
  inline const ::std::string& component_id() const;
  inline void set_component_id(const ::std::string& value);
  inline void set_component_id(const char* value);
  inline ::std::string* mutable_component_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* component_id_;
  static const ::std::string _default_component_id_;
  
  static const ConfigRequest default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class ConfigReply : public ::google::protobuf::Message {
 public:
  ConfigReply();
  virtual ~ConfigReply();
  
  ConfigReply(const ConfigReply& from);
  
  inline ConfigReply& operator=(const ConfigReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const ConfigReply& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  ConfigReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigReply& from);
  void MergeFrom(const ConfigReply& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes component_id = 1;
  inline bool has_component_id() const;
  inline void clear_component_id();
  inline const ::std::string& component_id() const;
  inline void set_component_id(const ::std::string& value);
  inline void set_component_id(const char* value);
  inline ::std::string* mutable_component_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* component_id_;
  static const ::std::string _default_component_id_;
  
  static const ConfigReply default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// ===================================================================


// ===================================================================


// ===================================================================

// SDPAMessage

// optional .sdpa.events.Error error = 1;
inline bool SDPAMessage::has_error() const {
  return _has_bit(0);
}
inline void SDPAMessage::clear_error() {
  if (error_ != NULL) error_->::sdpa::events::Error::Clear();
  _clear_bit(0);
}
inline const ::sdpa::events::Error& SDPAMessage::error() const {
  return error_ != NULL ? *error_ : *default_instance_.error_;
}
inline ::sdpa::events::Error* SDPAMessage::mutable_error() {
  _set_bit(0);
  if (error_ == NULL) error_ = new ::sdpa::events::Error;
  return error_;
}

// optional .sdpa.events.SubmitJob submit_job = 2;
inline bool SDPAMessage::has_submit_job() const {
  return _has_bit(1);
}
inline void SDPAMessage::clear_submit_job() {
  if (submit_job_ != NULL) submit_job_->::sdpa::events::SubmitJob::Clear();
  _clear_bit(1);
}
inline const ::sdpa::events::SubmitJob& SDPAMessage::submit_job() const {
  return submit_job_ != NULL ? *submit_job_ : *default_instance_.submit_job_;
}
inline ::sdpa::events::SubmitJob* SDPAMessage::mutable_submit_job() {
  _set_bit(1);
  if (submit_job_ == NULL) submit_job_ = new ::sdpa::events::SubmitJob;
  return submit_job_;
}

// optional .sdpa.events.SubmitJobAck submit_job_ack = 3;
inline bool SDPAMessage::has_submit_job_ack() const {
  return _has_bit(2);
}
inline void SDPAMessage::clear_submit_job_ack() {
  if (submit_job_ack_ != NULL) submit_job_ack_->::sdpa::events::SubmitJobAck::Clear();
  _clear_bit(2);
}
inline const ::sdpa::events::SubmitJobAck& SDPAMessage::submit_job_ack() const {
  return submit_job_ack_ != NULL ? *submit_job_ack_ : *default_instance_.submit_job_ack_;
}
inline ::sdpa::events::SubmitJobAck* SDPAMessage::mutable_submit_job_ack() {
  _set_bit(2);
  if (submit_job_ack_ == NULL) submit_job_ack_ = new ::sdpa::events::SubmitJobAck;
  return submit_job_ack_;
}

// optional .sdpa.events.CancelJob cancel_job = 4;
inline bool SDPAMessage::has_cancel_job() const {
  return _has_bit(3);
}
inline void SDPAMessage::clear_cancel_job() {
  if (cancel_job_ != NULL) cancel_job_->::sdpa::events::CancelJob::Clear();
  _clear_bit(3);
}
inline const ::sdpa::events::CancelJob& SDPAMessage::cancel_job() const {
  return cancel_job_ != NULL ? *cancel_job_ : *default_instance_.cancel_job_;
}
inline ::sdpa::events::CancelJob* SDPAMessage::mutable_cancel_job() {
  _set_bit(3);
  if (cancel_job_ == NULL) cancel_job_ = new ::sdpa::events::CancelJob;
  return cancel_job_;
}

// optional .sdpa.events.CancelJobAck cancel_job_ack = 5;
inline bool SDPAMessage::has_cancel_job_ack() const {
  return _has_bit(4);
}
inline void SDPAMessage::clear_cancel_job_ack() {
  if (cancel_job_ack_ != NULL) cancel_job_ack_->::sdpa::events::CancelJobAck::Clear();
  _clear_bit(4);
}
inline const ::sdpa::events::CancelJobAck& SDPAMessage::cancel_job_ack() const {
  return cancel_job_ack_ != NULL ? *cancel_job_ack_ : *default_instance_.cancel_job_ack_;
}
inline ::sdpa::events::CancelJobAck* SDPAMessage::mutable_cancel_job_ack() {
  _set_bit(4);
  if (cancel_job_ack_ == NULL) cancel_job_ack_ = new ::sdpa::events::CancelJobAck;
  return cancel_job_ack_;
}

// optional .sdpa.events.JobStatusRequest job_status_request = 6;
inline bool SDPAMessage::has_job_status_request() const {
  return _has_bit(5);
}
inline void SDPAMessage::clear_job_status_request() {
  if (job_status_request_ != NULL) job_status_request_->::sdpa::events::JobStatusRequest::Clear();
  _clear_bit(5);
}
inline const ::sdpa::events::JobStatusRequest& SDPAMessage::job_status_request() const {
  return job_status_request_ != NULL ? *job_status_request_ : *default_instance_.job_status_request_;
}
inline ::sdpa::events::JobStatusRequest* SDPAMessage::mutable_job_status_request() {
  _set_bit(5);
  if (job_status_request_ == NULL) job_status_request_ = new ::sdpa::events::JobStatusRequest;
  return job_status_request_;
}

// optional .sdpa.events.JobStatusReply job_status = 7;
inline bool SDPAMessage::has_job_status() const {
  return _has_bit(6);
}
inline void SDPAMessage::clear_job_status() {
  if (job_status_ != NULL) job_status_->::sdpa::events::JobStatusReply::Clear();
  _clear_bit(6);
}
inline const ::sdpa::events::JobStatusReply& SDPAMessage::job_status() const {
  return job_status_ != NULL ? *job_status_ : *default_instance_.job_status_;
}
inline ::sdpa::events::JobStatusReply* SDPAMessage::mutable_job_status() {
  _set_bit(6);
  if (job_status_ == NULL) job_status_ = new ::sdpa::events::JobStatusReply;
  return job_status_;
}

// optional .sdpa.events.JobFinished job_finished = 8;
inline bool SDPAMessage::has_job_finished() const {
  return _has_bit(7);
}
inline void SDPAMessage::clear_job_finished() {
  if (job_finished_ != NULL) job_finished_->::sdpa::events::JobFinished::Clear();
  _clear_bit(7);
}
inline const ::sdpa::events::JobFinished& SDPAMessage::job_finished() const {
  return job_finished_ != NULL ? *job_finished_ : *default_instance_.job_finished_;
}
inline ::sdpa::events::JobFinished* SDPAMessage::mutable_job_finished() {
  _set_bit(7);
  if (job_finished_ == NULL) job_finished_ = new ::sdpa::events::JobFinished;
  return job_finished_;
}

// optional .sdpa.events.JobFinishedAck job_finished_ack = 9;
inline bool SDPAMessage::has_job_finished_ack() const {
  return _has_bit(8);
}
inline void SDPAMessage::clear_job_finished_ack() {
  if (job_finished_ack_ != NULL) job_finished_ack_->::sdpa::events::JobFinishedAck::Clear();
  _clear_bit(8);
}
inline const ::sdpa::events::JobFinishedAck& SDPAMessage::job_finished_ack() const {
  return job_finished_ack_ != NULL ? *job_finished_ack_ : *default_instance_.job_finished_ack_;
}
inline ::sdpa::events::JobFinishedAck* SDPAMessage::mutable_job_finished_ack() {
  _set_bit(8);
  if (job_finished_ack_ == NULL) job_finished_ack_ = new ::sdpa::events::JobFinishedAck;
  return job_finished_ack_;
}

// optional .sdpa.events.JobFailed job_failed = 10;
inline bool SDPAMessage::has_job_failed() const {
  return _has_bit(9);
}
inline void SDPAMessage::clear_job_failed() {
  if (job_failed_ != NULL) job_failed_->::sdpa::events::JobFailed::Clear();
  _clear_bit(9);
}
inline const ::sdpa::events::JobFailed& SDPAMessage::job_failed() const {
  return job_failed_ != NULL ? *job_failed_ : *default_instance_.job_failed_;
}
inline ::sdpa::events::JobFailed* SDPAMessage::mutable_job_failed() {
  _set_bit(9);
  if (job_failed_ == NULL) job_failed_ = new ::sdpa::events::JobFailed;
  return job_failed_;
}

// optional .sdpa.events.JobFailedAck job_failed_ack = 11;
inline bool SDPAMessage::has_job_failed_ack() const {
  return _has_bit(10);
}
inline void SDPAMessage::clear_job_failed_ack() {
  if (job_failed_ack_ != NULL) job_failed_ack_->::sdpa::events::JobFailedAck::Clear();
  _clear_bit(10);
}
inline const ::sdpa::events::JobFailedAck& SDPAMessage::job_failed_ack() const {
  return job_failed_ack_ != NULL ? *job_failed_ack_ : *default_instance_.job_failed_ack_;
}
inline ::sdpa::events::JobFailedAck* SDPAMessage::mutable_job_failed_ack() {
  _set_bit(10);
  if (job_failed_ack_ == NULL) job_failed_ack_ = new ::sdpa::events::JobFailedAck;
  return job_failed_ack_;
}

// optional .sdpa.events.LifeSignal life_signal = 12;
inline bool SDPAMessage::has_life_signal() const {
  return _has_bit(11);
}
inline void SDPAMessage::clear_life_signal() {
  if (life_signal_ != NULL) life_signal_->::sdpa::events::LifeSignal::Clear();
  _clear_bit(11);
}
inline const ::sdpa::events::LifeSignal& SDPAMessage::life_signal() const {
  return life_signal_ != NULL ? *life_signal_ : *default_instance_.life_signal_;
}
inline ::sdpa::events::LifeSignal* SDPAMessage::mutable_life_signal() {
  _set_bit(11);
  if (life_signal_ == NULL) life_signal_ = new ::sdpa::events::LifeSignal;
  return life_signal_;
}

// optional .sdpa.events.ConfigRequest config_request = 13;
inline bool SDPAMessage::has_config_request() const {
  return _has_bit(12);
}
inline void SDPAMessage::clear_config_request() {
  if (config_request_ != NULL) config_request_->::sdpa::events::ConfigRequest::Clear();
  _clear_bit(12);
}
inline const ::sdpa::events::ConfigRequest& SDPAMessage::config_request() const {
  return config_request_ != NULL ? *config_request_ : *default_instance_.config_request_;
}
inline ::sdpa::events::ConfigRequest* SDPAMessage::mutable_config_request() {
  _set_bit(12);
  if (config_request_ == NULL) config_request_ = new ::sdpa::events::ConfigRequest;
  return config_request_;
}

// optional .sdpa.events.ConfigReply config_reply = 14;
inline bool SDPAMessage::has_config_reply() const {
  return _has_bit(13);
}
inline void SDPAMessage::clear_config_reply() {
  if (config_reply_ != NULL) config_reply_->::sdpa::events::ConfigReply::Clear();
  _clear_bit(13);
}
inline const ::sdpa::events::ConfigReply& SDPAMessage::config_reply() const {
  return config_reply_ != NULL ? *config_reply_ : *default_instance_.config_reply_;
}
inline ::sdpa::events::ConfigReply* SDPAMessage::mutable_config_reply() {
  _set_bit(13);
  if (config_reply_ == NULL) config_reply_ = new ::sdpa::events::ConfigReply;
  return config_reply_;
}

// -------------------------------------------------------------------

// Error

// required .sdpa.events.ErrorCode error_code = 1;
inline bool Error::has_error_code() const {
  return _has_bit(0);
}
inline void Error::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline sdpa::events::ErrorCode Error::error_code() const {
  return static_cast< sdpa::events::ErrorCode >(error_code_);
}
inline void Error::set_error_code(sdpa::events::ErrorCode value) {
  GOOGLE_DCHECK(sdpa::events::ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// required string error_description = 2;
inline bool Error::has_error_description() const {
  return _has_bit(1);
}
inline void Error::clear_error_description() {
  if (error_description_ != &_default_error_description_) {
    error_description_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Error::error_description() const {
  return *error_description_;
}
inline void Error::set_error_description(const ::std::string& value) {
  _set_bit(1);
  if (error_description_ == &_default_error_description_) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void Error::set_error_description(const char* value) {
  _set_bit(1);
  if (error_description_ == &_default_error_description_) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline ::std::string* Error::mutable_error_description() {
  _set_bit(1);
  if (error_description_ == &_default_error_description_) {
    error_description_ = new ::std::string;
  }
  return error_description_;
}

// -------------------------------------------------------------------

// Token

// required bytes place = 1;
inline bool Token::has_place() const {
  return _has_bit(0);
}
inline void Token::clear_place() {
  if (place_ != &_default_place_) {
    place_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Token::place() const {
  return *place_;
}
inline void Token::set_place(const ::std::string& value) {
  _set_bit(0);
  if (place_ == &_default_place_) {
    place_ = new ::std::string;
  }
  place_->assign(value);
}
inline void Token::set_place(const char* value) {
  _set_bit(0);
  if (place_ == &_default_place_) {
    place_ = new ::std::string;
  }
  place_->assign(value);
}
inline ::std::string* Token::mutable_place() {
  _set_bit(0);
  if (place_ == &_default_place_) {
    place_ = new ::std::string;
  }
  return place_;
}

// required bytes token = 2;
inline bool Token::has_token() const {
  return _has_bit(1);
}
inline void Token::clear_token() {
  if (token_ != &_default_token_) {
    token_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Token::token() const {
  return *token_;
}
inline void Token::set_token(const ::std::string& value) {
  _set_bit(1);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Token::set_token(const char* value) {
  _set_bit(1);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline ::std::string* Token::mutable_token() {
  _set_bit(1);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  return token_;
}

// -------------------------------------------------------------------

// SubmitJob

// required bytes workflow = 1;
inline bool SubmitJob::has_workflow() const {
  return _has_bit(0);
}
inline void SubmitJob::clear_workflow() {
  if (workflow_ != &_default_workflow_) {
    workflow_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SubmitJob::workflow() const {
  return *workflow_;
}
inline void SubmitJob::set_workflow(const ::std::string& value) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(value);
}
inline void SubmitJob::set_workflow(const char* value) {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  workflow_->assign(value);
}
inline ::std::string* SubmitJob::mutable_workflow() {
  _set_bit(0);
  if (workflow_ == &_default_workflow_) {
    workflow_ = new ::std::string;
  }
  return workflow_;
}

// repeated .sdpa.events.Token input = 2;
inline int SubmitJob::input_size() const {
  return input_.size();
}
inline void SubmitJob::clear_input() {
  input_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >&
SubmitJob::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdpa::events::Token >*
SubmitJob::mutable_input() {
  return &input_;
}
inline const ::sdpa::events::Token& SubmitJob::input(int index) const {
  return input_.Get(index);
}
inline ::sdpa::events::Token* SubmitJob::mutable_input(int index) {
  return input_.Mutable(index);
}
inline ::sdpa::events::Token* SubmitJob::add_input() {
  return input_.Add();
}

// -------------------------------------------------------------------

// SubmitJobAck

// required bytes job_id = 1;
inline bool SubmitJobAck::has_job_id() const {
  return _has_bit(0);
}
inline void SubmitJobAck::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SubmitJobAck::job_id() const {
  return *job_id_;
}
inline void SubmitJobAck::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void SubmitJobAck::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* SubmitJobAck::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// -------------------------------------------------------------------

// CancelJob

// required bytes job_id = 1;
inline bool CancelJob::has_job_id() const {
  return _has_bit(0);
}
inline void CancelJob::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CancelJob::job_id() const {
  return *job_id_;
}
inline void CancelJob::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void CancelJob::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* CancelJob::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// optional string reason = 2;
inline bool CancelJob::has_reason() const {
  return _has_bit(1);
}
inline void CancelJob::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CancelJob::reason() const {
  return *reason_;
}
inline void CancelJob::set_reason(const ::std::string& value) {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void CancelJob::set_reason(const char* value) {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline ::std::string* CancelJob::mutable_reason() {
  _set_bit(1);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// -------------------------------------------------------------------

// CancelJobAck

// required bytes job_id = 1;
inline bool CancelJobAck::has_job_id() const {
  return _has_bit(0);
}
inline void CancelJobAck::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CancelJobAck::job_id() const {
  return *job_id_;
}
inline void CancelJobAck::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void CancelJobAck::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* CancelJobAck::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// -------------------------------------------------------------------

// JobStatusRequest

// required bytes job_id = 1;
inline bool JobStatusRequest::has_job_id() const {
  return _has_bit(0);
}
inline void JobStatusRequest::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobStatusRequest::job_id() const {
  return *job_id_;
}
inline void JobStatusRequest::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobStatusRequest::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* JobStatusRequest::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// -------------------------------------------------------------------

// JobStatusReply

// required bytes job_id = 1;
inline bool JobStatusReply::has_job_id() const {
  return _has_bit(0);
}
inline void JobStatusReply::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobStatusReply::job_id() const {
  return *job_id_;
}
inline void JobStatusReply::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobStatusReply::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* JobStatusReply::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// required .sdpa.events.JobState state = 2;
inline bool JobStatusReply::has_state() const {
  return _has_bit(1);
}
inline void JobStatusReply::clear_state() {
  state_ = 0;
  _clear_bit(1);
}
inline sdpa::events::JobState JobStatusReply::state() const {
  return static_cast< sdpa::events::JobState >(state_);
}
inline void JobStatusReply::set_state(sdpa::events::JobState value) {
  GOOGLE_DCHECK(sdpa::events::JobState_IsValid(value));
  _set_bit(1);
  state_ = value;
}

// -------------------------------------------------------------------

// JobFinished

// required bytes job_id = 1;
inline bool JobFinished::has_job_id() const {
  return _has_bit(0);
}
inline void JobFinished::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFinished::job_id() const {
  return *job_id_;
}
inline void JobFinished::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobFinished::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* JobFinished::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// -------------------------------------------------------------------

// JobFinishedAck

// required bytes job_id = 1;
inline bool JobFinishedAck::has_job_id() const {
  return _has_bit(0);
}
inline void JobFinishedAck::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFinishedAck::job_id() const {
  return *job_id_;
}
inline void JobFinishedAck::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobFinishedAck::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* JobFinishedAck::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// -------------------------------------------------------------------

// JobFailed

// required bytes job_id = 1;
inline bool JobFailed::has_job_id() const {
  return _has_bit(0);
}
inline void JobFailed::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFailed::job_id() const {
  return *job_id_;
}
inline void JobFailed::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobFailed::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* JobFailed::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// -------------------------------------------------------------------

// JobFailedAck

// required bytes job_id = 1;
inline bool JobFailedAck::has_job_id() const {
  return _has_bit(0);
}
inline void JobFailedAck::clear_job_id() {
  if (job_id_ != &_default_job_id_) {
    job_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& JobFailedAck::job_id() const {
  return *job_id_;
}
inline void JobFailedAck::set_job_id(const ::std::string& value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline void JobFailedAck::set_job_id(const char* value) {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
}
inline ::std::string* JobFailedAck::mutable_job_id() {
  _set_bit(0);
  if (job_id_ == &_default_job_id_) {
    job_id_ = new ::std::string;
  }
  return job_id_;
}

// -------------------------------------------------------------------

// LifeSignal

// required fixed64 timestamp = 1;
inline bool LifeSignal::has_timestamp() const {
  return _has_bit(0);
}
inline void LifeSignal::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 LifeSignal::timestamp() const {
  return timestamp_;
}
inline void LifeSignal::set_timestamp(::google::protobuf::uint64 value) {
  _set_bit(0);
  timestamp_ = value;
}

// required bytes component_id = 2;
inline bool LifeSignal::has_component_id() const {
  return _has_bit(1);
}
inline void LifeSignal::clear_component_id() {
  if (component_id_ != &_default_component_id_) {
    component_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LifeSignal::component_id() const {
  return *component_id_;
}
inline void LifeSignal::set_component_id(const ::std::string& value) {
  _set_bit(1);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void LifeSignal::set_component_id(const char* value) {
  _set_bit(1);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline ::std::string* LifeSignal::mutable_component_id() {
  _set_bit(1);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  return component_id_;
}

// -------------------------------------------------------------------

// ConfigRequest

// required bytes component_id = 1;
inline bool ConfigRequest::has_component_id() const {
  return _has_bit(0);
}
inline void ConfigRequest::clear_component_id() {
  if (component_id_ != &_default_component_id_) {
    component_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ConfigRequest::component_id() const {
  return *component_id_;
}
inline void ConfigRequest::set_component_id(const ::std::string& value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void ConfigRequest::set_component_id(const char* value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline ::std::string* ConfigRequest::mutable_component_id() {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  return component_id_;
}

// -------------------------------------------------------------------

// ConfigReply

// required bytes component_id = 1;
inline bool ConfigReply::has_component_id() const {
  return _has_bit(0);
}
inline void ConfigReply::clear_component_id() {
  if (component_id_ != &_default_component_id_) {
    component_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ConfigReply::component_id() const {
  return *component_id_;
}
inline void ConfigReply::set_component_id(const ::std::string& value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline void ConfigReply::set_component_id(const char* value) {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  component_id_->assign(value);
}
inline ::std::string* ConfigReply::mutable_component_id() {
  _set_bit(0);
  if (component_id_ == &_default_component_id_) {
    component_id_ = new ::std::string;
  }
  return component_id_;
}


}  // namespace events
}  // namespace sdpa
#endif  // PROTOBUF_sdpa_2dmsg_2eproto__INCLUDED
