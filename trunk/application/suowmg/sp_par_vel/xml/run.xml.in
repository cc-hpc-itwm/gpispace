<defun>

  <in name="shot_prepared" type="shot" place="shot_prepared"/>
  <in name="output_slot" type="long" place="output_slot"/>
  <out name="shot_done" type="loaded_package" place="shot_done"/>
  <out name="output" type="output" place="output"/>

  <net>

    <place name="config" type="config" virtual="true"/>
    <place name="shot_prepared" type="shot"/>
    <place name="output_slot" type="long"/>
    <place name="output" type="output"/>

    <place name="shot_done" type="loaded_package"/>

    <transition name="run">
      <defun>
        <in name="shot" type="shot"/>
        <out name="shot_done" type="loaded_package"/>

        <in name="output_slot" type="long"/>
        <out name="output" type="output"/>

        <in name="config" type="config"/>
        <module name="sp_par_vel" function="output run ( config
                                                       , shot
                                                       , output_slot
                                                       , shot_done
                                                       )">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="print.hpp"/>
          <cinclude href="util.hpp"/>
          <cinclude href="comm.hpp"/>
          <cinclude href="process.hpp"/>
          <ld flag="@SDPA_LIBEXEC@/libprocess.so"/>
          <code><![CDATA[
            LOG (INFO, "RUN " << ::print::shot (shot));

            shot_done = shot.loaded_package;

            const ::pnetc::type::assigned_package::assigned_package &
                  assigned_package (shot.loaded_package.assigned_package);

            ::pnetc::type::output::output output;

            output.slot        = output_slot;
            output.shot_num    = shot.num;
            output.trace.left  = assigned_package.package.left.trace;
            output.trace.right = assigned_package.package.right.trace;

            float sx (static_cast<float> (shot.loaded_package.key.sx));
            float sy (static_cast<float> (shot.loaded_package.key.sy));

            const float scalco (static_cast<float>(shot.loaded_package.key.scalco));

            if (scalco > 0)
              {
                sx *= scalco;
                sy *= scalco;
              }
            else if (shot.loaded_package.key.scalco < 0)
              {
                sx /= -scalco;
                sy /= -scalco;
              }

            const float lx (static_cast<float>(config.param.lx));
            const float ly (static_cast<float>(config.param.ly));
            const float dx (static_cast<float>(config.param.dx));
            const float dy (static_cast<float>(config.param.dy));

#define NINT(x) ((int)((x)>0.0?(x)+0.5:(x)-0.5))

            const float Lox = sx - lx * 0.5f;
            const float Loy = sy - ly * 0.5f;
            const int iVox = NINT (Lox / dx);
            const int iVoy = NINT (Loy / dy);

            LOG(INFO, "READ MODELS iVox " << iVox
                  << " iVoy " << iVoy
                  << " Vnx " << config.param.Vnx
                  << " Vny " << config.param.Vny
                  << " Vnz " << config.param.Vnz
                );

// adopted readModel
{
  const int nxf = config.param.nxf;
  const int nyf = config.param.nyf;
  const int nz = config.param.nz;

  const int Vnz = config.param.Vnz;
  const int Vny = config.param.Vny;
  const int Vnx = config.param.Vnx;

  float * cube ((float *) fvmGetShmemPtr());

  if (config.size.vpcube + nxf * Vnz * sizeof (float)
      > config.per.node.mem.shmem
      )
    {
      throw std::runtime_error ("nvec doesn't fit into shmem area");
    }

  float * nvec ((float *)((char *)fvmGetShmemPtr() + config.size.vpcube));

  const long off_nvec (config.size.vpcube);

#define IMAX(a,b) ((a)>(b) ? (a) : (b))

  // Calculate padding (extrapolation)
  const int padx1 = IMAX (0, -iVox);
  const int padx2 = IMAX (0, iVox + nxf - Vnx);
  const int pady1 = IMAX (0, -iVoy);
  const int pady2 = IMAX (0, iVoy + nyf - Vny);

  for (int ix = 0; ix < nxf * nyf * nz; ++ix)
    cube[ix] = -2.0;

  // Loop over y
  for (int iy = iVoy + pady1; iy <= iVoy + nyf - 1 - pady2; iy++)
    {

      // Read from memory
      for (int ix = 0; ix < nxf * Vnz; ix++)
        nvec[ix] = -1.0;

//      mods_fread ( mFILE
//                 , nvec + padx1 * Vnz
//                 , iy * Vnx * Vnz + (iVox + padx1) * Vnz
//                 , (nxf - padx2 - padx1) * Vnz
//                 );

      waitComm ( fvmGetGlobalData
                 ( config.handle.vpfile.data
                 , sizeof(float) * Vnz * (iy * Vnx + (iVox + padx1))
                 , sizeof(float) * Vnz * (nxf - padx2 - padx1)
                 , off_nvec + sizeof (float) * Vnz * padx1
                 , config.handle.vpfile.scratch
                 )
               );

      // Pad in x-direction (trace by trace)
      if (padx1 > 0)
        {
          for (int ix = 0; ix < padx1; ix++)
            {
              for (int iz = 0; iz < nz; iz++)
                {
                  nvec[Vnz * ix + iz] = nvec[Vnz * padx1 + iz];
                }
            }
        }
      if (padx2 > 0)
        {
          for (int ix = nxf - padx2; ix < nxf; ix++)
            {
              for (int iz = 0; iz < nz; iz++)
                {
                  nvec[Vnz * ix + iz] = nvec[Vnz * (nxf - padx2 - 1) + iz];
                }
            }
        }

      // Transpose and place in cube
      for (int ix = 0; ix < nxf; ix++)
        {
          for (int iz = 0; iz < nz; iz++)
            {
              cube[(iz * nyf + iy - iVoy) * nxf + ix] = nvec[Vnz * ix + iz];
            }
        }
    }

  if (pady1 > 0)
    {
      for (int iz = 0; iz < nz; iz++)
        {
          for (int iy = 0; iy < pady1; iy++)
            {
              for (int ix = 0; ix < nxf; ix++)
                {
                  cube[(iz * nyf + iy) * nxf + ix]
                    = cube[(iz * nyf + pady1) * nxf + ix];
                }
            }
        }
    }

  if (pady2 > 0)
    {
      for (int iz = 0; iz < nz; iz++)
        {
          for (int iy = nyf - pady2; iy < nyf; iy++)
            {
              for (int ix = 0; ix < nxf; ix++)
                {
                  cube[(iz * nyf + iy) * nxf + ix]
                    = cube[(iz * nyf + nyf - pady2 - 1) * nxf + ix];
                }
            }
        }
    }
}

LOG(INFO,"DONE READ MODEL");

            comm::get (config, assigned_package, config.size.vpcube);

            const long size_input ( ::util::size (assigned_package)
                                  * config.size.trace
                                  );

            if (size_input + config.size.vpcube + config.size.output_per_shot
               > config.per.node.mem.shmem
               )
              {
                throw std::runtime_error ("shot to large for shmem area");
              }

            char * buf ( static_cast<char *>(fvmGetShmemPtr())
                       + config.size.vpcube
                       );

            std::ostringstream cmd;

            cmd << config.suowmg;
            cmd << " nx=" << config.param.Vnx;
            cmd << " ny=" << config.param.Vny;
            cmd << " nz=" << config.param.Vnz;
            cmd << " dx=" << config.param.dx;
            cmd << " dy=" << config.param.dy;
            cmd << " dz=" << config.param.dz;
            cmd << " zmax=" << config.param.zmax;
            cmd << " lx=" << config.param.lx;
            cmd << " ly=" << config.param.ly;
            cmd << " f1=" << config.param.f1;
            cmd << " f2=" << config.param.f2;
            cmd << " f3=" << config.param.f3;
            cmd << " f4=" << config.param.f4;
            cmd << " pad=" << config.param.pad;
            cmd << " latSamplesPerWave=" << config.param.latSamplesPerWave;
            cmd << " vertSamplesPerWave=" << config.param.vertSamplesPerWave;
            cmd << " medium=" << config.param.medium;
            cmd << " propagator=" << config.param.propagator;
            cmd << " vPFile=" << config.param.vPFile;
            cmd << " eFile=" << config.param.eFile;
            cmd << " dFile=" << config.param.dFile;
            cmd << " shmem_size=" << fvmGetShmemSize();
            cmd << " shmem_name=" << "/" << fvmGetShmemName();

            process::circular_buffer buf_stderr;

            process::execute_return_type ret
              ( process::execute
                ( cmd.str()
                , process::const_buffer (buf, size_input)
                , process::buffer (buf + size_input, config.size.output_per_shot)
                , buf_stderr
                , process::file_const_buffer_list ()
                , process::file_buffer_list ()
                )
              );

            if (ret.bytes_read_stdout != config.size.output_per_shot)
              {
                throw std::runtime_error ("wrong size returned");
              }

            comm::put (config, output, size_input + config.size.vpcube);

            if (ret.bytes_read_stderr > 0)
            {
              LOG (INFO, "STDERR [" << ret.bytes_read_stderr << "]: "
                       << std::string (buf_stderr.begin(), buf_stderr.end())
                  );
            }

            return output;
          ]]></code>
        </module>
      </defun>
      <connect-in port="shot" place="shot_prepared"/>
      <connect-out port="shot_done" place="shot_done"/>
      <connect-in port="output_slot" place="output_slot"/>
      <connect-out port="output" place="output"/>
      <connect-read port="config" place="config"/>
    </transition>
  </net>

</defun>
