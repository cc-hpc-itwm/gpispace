<defun>

  <in name="output" type="output" place="output"/>
  <out name="output_finished" type="output" place="output_finished"/>
  <out name="output_slot" type="long" place="output_slot"/>

  <net>

    <place name="config" type="config" virtual="true"/>
    <place name="output" type="output"/>
    <place name="output_finished" type="output"/>
    <place name="output_slot" type="long"/>

    <transition name="write">
      <defun>
        <in name="config" type="config"/>
        <in name="output" type="output"/>
        <out name="output" type="output"/>
        <module name="sp_par_vel" function="write (config, output)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="print.hpp"/>
          <cinclude href="comm.hpp"/>
          <cinclude href="SegYBHeader.h"/>
          <cinclude href="SegYEBCHeader.h"/>
          <cinclude href="fstream"/>
          <cinclude href="stdexcept"/>
          <cinclude href="errno.h"/>
          <cinclude href="string.h"/>
          <code><![CDATA[
            LOG (INFO, "WRITE " << ::print::output (output));

            comm::get (config, output);

            char * buf ((char *)fvmGetShmemPtr());

            FILE * outp (fopen (config.file.output.name.c_str(), "rb+"));

            if (outp == NULL)
              {
                throw std::runtime_error ("could not open " + config.file.output.name);
             }

            if (fseek ( outp
                      , output.shot_num * config.size.output_per_shot
                      , SEEK_SET
                      ) == -1
               )
              {
                const int ec (errno);

                throw std::runtime_error ("fseek failed: " + std::string(strerror(ec)));
              }

            fwrite (buf, config.size.output_per_shot, 1, outp);

            fclose (outp);
          ]]></code>
        </module>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="output" place="output"/>
      <connect-out port="output" place="output_written"/>
    </transition>

    <place name="output_written" type="output"/>

    <transition name="give_back_output_slot">
      <defun>
        <in name="output" type="output"/>
        <out name="output" type="output"/>
        <out name="slot" type="long"/>
        <expression>
          ${slot} := ${output.slot};
        </expression>
      </defun>
      <connect-in port="output" place="output_written"/>
      <connect-out port="output" place="output_finished"/>
      <connect-out port="slot" place="output_slot"/>
    </transition>

  </net>

</defun>
