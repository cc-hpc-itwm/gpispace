<defun>

  <in name="shot_prepared" type="shot" place="shot_prepared"/>
  <in name="output_slot" type="long" place="output_slot"/>
  <out name="shot_done" type="loaded_package" place="shot_done"/>
  <out name="output" type="output" place="output"/>

  <net>

    <place name="config" type="config" virtual="true"/>
    <place name="shot_prepared" type="shot"/>
    <place name="output_slot" type="long"/>
    <place name="output" type="output"/>

    <place name="shot_done" type="loaded_package"/>

    <transition name="run">
      <defun>
        <in name="shot" type="shot"/>
        <out name="shot_done" type="loaded_package"/>

        <in name="output_slot" type="long"/>
        <out name="output" type="output"/>

        <in name="config" type="config"/>
        <module name="sp_par" function="output run ( config
                                                   , shot
                                                   , output_slot
                                                   , shot_done
                                                   )">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="print.hpp"/>
          <cinclude href="util.hpp"/>
          <cinclude href="comm.hpp"/>
          <cinclude href="process/process.hpp"/>
          <ld flag="-lprocess"/>
          <code><![CDATA[
            LOG (INFO, "RUN " << ::print::shot (shot));

            shot_done = shot.loaded_package;

            const ::pnetc::type::assigned_package::assigned_package &
                  assigned_package (shot.loaded_package.assigned_package);

            ::pnetc::type::output::output output;

            output.slot        = output_slot;
            output.shot_num    = shot.num;
            output.trace.left  = assigned_package.package.left.trace;
            output.trace.right = assigned_package.package.right.trace;

            comm::get (config, assigned_package);

            const long size_input ( ::util::size (assigned_package)
                                  * config.size.trace
                                  );

            if (size_input + config.size.output_per_shot > config.per.node.mem.shmem)
              {
                throw std::runtime_error ("shot to large for shmem area");
              }

            char * buf ((char *)fvmGetShmemPtr());

            std::ostringstream cmd;

            cmd << config.suowmg;
            cmd << " nx=" << config.param.Vnx;
            cmd << " ny=" << config.param.Vny;
            cmd << " nz=" << config.param.Vnz;
            cmd << " dx=" << config.param.dx;
            cmd << " dy=" << config.param.dy;
            cmd << " dz=" << config.param.dz;
            cmd << " zmax=" << config.param.zmax;
            cmd << " lx=" << config.param.lx;
            cmd << " ly=" << config.param.ly;
            cmd << " f1=" << config.param.f1;
            cmd << " f2=" << config.param.f2;
            cmd << " f3=" << config.param.f3;
            cmd << " f4=" << config.param.f4;
            cmd << " pad=" << config.param.pad;
            cmd << " latSamplesPerWave=" << config.param.latSamplesPerWave;
            cmd << " vertSamplesPerWave=" << config.param.vertSamplesPerWave;
            cmd << " medium=" << config.param.medium;
            cmd << " propagator=" << config.param.propagator;
            cmd << " vPFile=" << config.param.vPFile;
            cmd << " eFile=" << config.param.eFile;
            cmd << " dFile=" << config.param.dFile;
	    cmd << " nthread=" << config.param.nThread;

            process::circular_buffer buf_stderr;

            process::execute_return_type ret
              ( process::execute
                ( cmd.str()
                , process::const_buffer (buf, size_input)
                , process::buffer (buf + size_input, config.size.output_per_shot)
                , buf_stderr
                , process::file_const_buffer_list ()
                , process::file_buffer_list ()
                )
              );

            if (ret.bytes_read_stdout != config.size.output_per_shot)
              {
                throw std::runtime_error ("wrong size returned");
              }

            comm::put (config, output, size_input);

            if (ret.bytes_read_stderr > 0)
            {
              LOG (INFO, "STDERR [" << ret.bytes_read_stderr << "]: "
                       << std::string (buf_stderr.begin(), buf_stderr.end())
                  );
            }

            return output;
          ]]></code>
        </module>
      </defun>
      <connect-in port="shot" place="shot_prepared"/>
      <connect-out port="shot_done" place="shot_done"/>
      <connect-in port="output_slot" place="output_slot"/>
      <connect-out port="output" place="output"/>
      <connect-read port="config" place="config"/>
    </transition>
  </net>

</defun>
