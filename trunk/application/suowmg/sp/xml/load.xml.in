<defun>

  <in name="assigned_package" type="assigned_package" place="assigned_package"/>
  <out name="loaded_package" type="loaded_package" place="loaded_package"/>

  <net>

    <place name="config" type="config" virtual="true"/>
    <place name="assigned_package" type="assigned_package"/>
    <place name="loaded_package" type="loaded_package"/>

    <transition name="load">
      <defun>
        <in name="assigned_package" type="assigned_package"/>
        <in name="config" type="config"/>
        <out name="list" type="list_of_loaded_packages"/>
        <module name="sp" function="list load (config, assigned_package)">
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="do_load.hpp"/>
          <cinclude href="print.hpp"/>
          <cinclude href="comm.hpp"/>
          <cinclude href="util.hpp"/>
          <cinclude href="process/process.hpp"/>
          <cinclude href="tracebunch.hpp"/>
          <cinclude href="deque"/>
          <link href="-ldo_load"/>
          <code><![CDATA[
            LOG (INFO, "LOAD " << ::print::assigned_package (assigned_package));

            const long part ( assigned_package.package.left.trace
                            / config.per.bunch.trace
                            );
            const long size ( ::util::size (assigned_package)
                            * config.size.trace
                            );

            LOG (TRACE, "do_load: part " << part
                     << ", part_size "  << config.size.bunch
                     << ", size " << size
                     << ", num " << ::util::size (assigned_package)
                );

            void * buf (fvmGetShmemPtr());

            do_load ( config.file.input.name
                    , config.file.input.type
                    , part
                    , config.size.bunch
                    , size
                    , ::util::size (assigned_package)
                    , buf
                    );

            comm::put (config, assigned_package);

            typedef std::deque< ::pnetc::type::loaded_package::loaded_package> vec_t;

            vec_t v;

            const unsigned int nt
              ((config.size.trace - sizeof(SegYHeader)) / sizeof(float));
            const unsigned int N (::util::size (assigned_package));

            seislib::TraceBunch tb ((char *)buf, N, nt);

            ::pnetc::type::loaded_package::loaded_package loaded_package;

            unsigned int pos (0);
            long size_rest (assigned_package.intervals.size.front());

            loaded_package.key.sx = tb[pos].getSegYHeader()->sx;
            loaded_package.key.sy = tb[pos].getSegYHeader()->sy;

            loaded_package.assigned_package = assigned_package;
            loaded_package.assigned_package.package.right.trace
              = loaded_package.assigned_package.package.left.trace + 1;

            loaded_package.assigned_package.intervals.size.front()
              = config.size.trace;
            size_rest -= config.size.trace;

            while (pos < N)
            {
              ++pos;

              if (!(pos < N))
                {
                  loaded_package.assigned_package.intervals.size.front()
                    += size_rest;

                  loaded_package.assigned_package.package.right.extendable
                    = assigned_package.package.right.extendable;

                  LOG (TRACE, "found (last) shot "
                      << ::print::loaded_package (loaded_package)
                      );

                  v.push_back (loaded_package);
                }
              else if (  !(tb[pos].getSegYHeader()->sx == loaded_package.key.sx)
                      || !(tb[pos].getSegYHeader()->sy == loaded_package.key.sy)
                      )
                {
                  // found new shot
                  loaded_package.assigned_package.package.right.extendable
                    = false;

                  LOG (TRACE, "found shot "
                      << ::print::loaded_package (loaded_package)
                      );

                  v.push_back (loaded_package);

                  loaded_package.key.sx = tb[pos].getSegYHeader()->sx;
                  loaded_package.key.sy = tb[pos].getSegYHeader()->sy;

                  loaded_package.assigned_package.package.left.trace
                    = loaded_package.assigned_package.package.right.trace;
                  loaded_package.assigned_package.package.right.trace
                    = loaded_package.assigned_package.package.left.trace + 1;
                  loaded_package.assigned_package.package.left.extendable
                    = false;

                  loaded_package.assigned_package.intervals.offset.front()
                    += loaded_package.assigned_package.intervals.size.front();
                  loaded_package.assigned_package.intervals.size.front()
                     = config.size.trace;
                  size_rest -= config.size.trace;
                }
              else
                {
                  // still the same shot
                  loaded_package.assigned_package.package.right.trace
                    += 1;
                  loaded_package.assigned_package.intervals.size.front()
                    += config.size.trace;
                  size_rest -= config.size.trace;
                }
            }

            ::pnetc::type::list_of_loaded_packages::list_of_loaded_packages list;

            list.size = v.size();
            list.list = ::bytearray::encoder<vec_t> (v).bytearray();

            return list;
          ]]></code>
        </module>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="assigned_package" place="assigned_package"/>
      <connect-out port="list" place="list_of_loaded_packages"/>
    </transition>

    <place name="list_of_loaded_packages" type="list_of_loaded_packages"/>

    <transition name="clear_empty_list">
      <defun>
        <in name="list" type="list_of_loaded_packages"/>
        <expression/>
      </defun>
      <condition>
        ${list.size} :le: 0L
      </condition>
      <connect-in port="list" place="list_of_loaded_packages"/>
    </transition>

    <transition name="take_element">
      <defun>
        <in name="list" type="list_of_loaded_packages"/>
        <out name="list" type="list_of_loaded_packages"/>
        <out name="package" type="loaded_package"/>
        <module name="sp" function="package take (list)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="print.hpp"/>
          <cinclude href="deque"/>
          <cinclude href="stdexcept"/>
          <code><![CDATA[
            LOG (INFO, "take element from list with " << list.size << " elements");

            typedef std::deque< ::pnetc::type::loaded_package::loaded_package> vec_t;

            ::bytearray::decoder<vec_t> decoder (list.list);

            vec_t v (decoder.value());

            const ::pnetc::type::loaded_package::loaded_package
              loaded_package (v.front());

            LOG (TRACE, "extracted package " << ::print::loaded_package (loaded_package));

            v.pop_front();

            list.size = v.size();
            list.list = ::bytearray::encoder<vec_t> (v).bytearray();

            return loaded_package;
          ]]>
          </code>
        </module>
      </defun>
      <condition>
        ${list.size} :gt: 0L
      </condition>
      <connect-in port="list" place="list_of_loaded_packages"/>
      <connect-out port="list" place="list_of_loaded_packages"/>
      <connect-out port="package" place="loaded_package"/>
    </transition>

  </net>

</defun>
