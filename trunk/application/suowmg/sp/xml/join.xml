<defun>

  <in name="loaded_package" type="loaded_package" place="pre_loaded_package"/>
  <out name="shot_prepared" type="loaded_package" place="shot_prepared"/>

  <net>

    <template name="select">
      <in name="x" type="T"/>
      <out name="x" type="T"/>
      <expression/>
    </template>

    <specialize name="select_loaded_package" use="select">
      <type-map replace="T" with="loaded_package"/>
    </specialize>

    <place name="pre_loaded_package" type="loaded_package"/>
    <place name="loaded_package" type="loaded_package" capacity="1"/>

    <transition name="select_loaded_package">
      <use name="select_loaded_package"/>
      <connect-in port="x" place="pre_loaded_package"/>
      <connect-out port="x" place="loaded_package"/>
    </transition>

    <transition name="prepared">
      <defun>
        <in name="package" type="loaded_package"/>
        <out name="package" type="loaded_package"/>
        <expression/>
      </defun>
      <condition>
        ${package.assigned_package.package.left.extendable} :eq: false
      </condition>
      <condition>
        ${package.assigned_package.package.right.extendable} :eq: false
      </condition>
      <connect-in port="package" place="loaded_package"/>
      <connect-out port="package" place="shot_prepared"/>
    </transition>

    <transition name="not_yet_prepared">
      <defun>
        <in name="package" type="loaded_package"/>
        <out name="package" type="loaded_package"/>
        <expression/>
      </defun>
      <condition>
        (${package.assigned_package.package.left.extendable} :eq: true)
        ||
        (${package.assigned_package.package.right.extendable} :eq: true)
      </condition>
      <connect-in port="package" place="loaded_package"/>
      <connect-out port="package" place="pre_still_extendable"/>
    </transition>

    <place name="pre_still_extendable" type="loaded_package"/>
    <place name="still_extendable" type="loaded_package" capacity="1"/>
    <place name="still_extendables" type="loaded_package"/>

    <transition name="select_still_extendable">
      <use name="select_loaded_package"/>
      <connect-in port="x" place="pre_still_extendable"/>
      <connect-out port="x" place="still_extendable"/>
    </transition>

    <defun name="join2">
      <in name="x" type="loaded_package"/>
      <in name="y" type="loaded_package"/>
      <out name="x" type="loaded_package"/>
      <out name="y" type="loaded_package"/>
      <expression>
        ${x.assigned_package.package.right.extendable} := false;
        ${y.assigned_package.package.left.extendable} := false;
      </expression>
      <condition>
        ${x.assigned_package.package.right.trace}
        :eq:
        ${y.assigned_package.package.left.trace}
      </condition>
      <condition>
        (${x.key.sx} :ne: ${y.key.sx}) :or: (${x.key.sy} :ne: ${y.key.sy})
      </condition>
    </defun>

    <transition name="joinL2" priority="1">
      <use name="join2"/>
      <connect-in port="x" place="still_extendable"/>
      <connect-in port="y" place="still_extendables"/>
      <connect-out port="x" place="pre_loaded_package"/>
      <connect-out port="y" place="pre_pre_loaded_package"/>
    </transition>

    <transition name="joinR2" priority="1">
      <use name="join2"/>
      <connect-in port="x" place="still_extendables"/>
      <connect-in port="y" place="still_extendable"/>
      <connect-out port="x" place="pre_loaded_package"/>
      <connect-out port="y" place="pre_pre_loaded_package"/>
    </transition>

    <place name="pre_pre_loaded_package" type="loaded_package"/>

    <transition name="select_pre_loaded_package">
      <use name="select_loaded_package"/>
      <connect-in port="x" place="pre_pre_loaded_package"/>
      <connect-out port="x" place="loaded_package"/>
    </transition>

    <defun name="join1">
      <in name="x" type="loaded_package"/>
      <in name="y" type="loaded_package"/>
      <out name="s" type="loaded_package"/>
      <expression>
        ${s} := ${x};
        ${s.assigned_package.intervals.size}
          := stack_join ( ${y.assigned_package.intervals.size}
                        , ${x.assigned_package.intervals.size}
                        );
        ${s.assigned_package.intervals.offset}
          := stack_join ( ${y.assigned_package.intervals.offset}
                        , ${x.assigned_package.intervals.offset}
                        );
        ${s.assigned_package.package.right}
          := ${y.assigned_package.package.right};
      </expression>
      <condition>
        ${x.assigned_package.package.right.trace}
        :eq:
        ${y.assigned_package.package.left.trace}
      </condition>
      <condition>
        ${x.key.sx} :eq: ${y.key.sx}
      </condition>
      <condition>
        ${x.key.sy} :eq: ${y.key.sy}
      </condition>
    </defun>

    <transition name="joinL1" priority="1">
      <use name="join1"/>
      <connect-in port="x" place="still_extendable"/>
      <connect-in port="y" place="still_extendables"/>
      <connect-out port="s" place="pre_loaded_package"/>
    </transition>

    <transition name="joinR1" priority="1">
      <use name="join1"/>
      <connect-in port="x" place="still_extendables"/>
      <connect-in port="y" place="still_extendable"/>
      <connect-out port="s" place="pre_loaded_package"/>
    </transition>

    <transition name="no_join">
      <use name="select_loaded_package"/>
      <connect-in port="x" place="still_extendable"/>
      <connect-out port="x" place="still_extendables"/>
    </transition>

    <place name="shot_prepared" type="loaded_package"/>
  </net>

</defun>
