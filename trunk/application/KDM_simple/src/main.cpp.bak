#define VERSION "1.1"

#include <MigVol.hpp>
#include <MigSubVol.hpp>
#include <TravTimeTab.hpp>
#include <TraceBunch.hpp>
#include <sdpa_routines.hpp>
#include <sdpa_init.hpp>

//#include <stdlib.h>

#include "structures/migrationjob.h"
#include "filehandler/checkreadmigrationjob.h"
#include "filehandler/migrationfilehandler.h"
//#include "utils/loggingclass.h"
#include <unistd.h>
#include <string.h>
#include <libgen.h>
#include <iostream>
#include <stdlib.h>

#include LOGGERINCLUDE

LOGGER;

// /* Print welcome message */
// void welcome()
// {
//   MESSAGE("\n\n");
//   MESSAGE("*************************************************");
//   MESSAGE("* SDPA: 3D Kirchhoff Migration Version %s      *", VERSION);
//   MESSAGE("*                                               *");
//   MESSAGE("* (C) 2010 by Daniel Gr√ºnewald, Dirk Merten and *");
//   MESSAGE("*             Norman Ettrich                    *");
//   MESSAGE("*                                               *");
//   MESSAGE("*             Fraunhofer ITWM                   *");
//   MESSAGE("*                                               *");
//   MESSAGE("* Contact:    daniel.gruenewald@itwm.fhg.de     *");
//   MESSAGE("*************************************************\n\n\f");
// }
// 
// /* Print error message to stdout */
// void errormessage(char* binary_name, const int mode = 0)
// {
//   switch (mode) 
//     {
//     case 0 :
//       std::cerr << binary_name << " : invalid option\n";
//       std::cerr << "Try `" << binary_name << " -h' for more information.\n";
//       break;
//       
//     case 1 :
//       std::cerr << binary_name << " : no configuration file specified\n";
//       std::cerr << "Try `" << binary_name << " -h' for more information.\n\n";
//       break;
//     }
// }
// 
// /* Print usage description to stdout */
// void helpmessage(char* binary_name)
// {
//   MESSAGE("Usage: %s [-options]",binary_name);
//   MESSAGE(" ");
//   MESSAGE("-h                      print this help message");
//   MESSAGE("-f 'CfgFile'            read parameters from File CfgFile");  
//   MESSAGE("Optional Parameters:");
//   MESSAGE(" ");
//   MESSAGE("-s MemSize              allocate memory of size MemSize (in GByte)");  
//   MESSAGE("                        on each node for VM");  
//   MESSAGE("-p Port                 user port VMPort for node communication");  
//   MESSAGE("-x                      skip tests of nodes and network");  
// }
// 
// 
// /* Exit program */
// void fatalexit()
// {
//   int errcode = 1;
//   exit(errcode);
// }


int main(int argc, char *argv[])
{
  welcome();

  char* CfgFileName = NULL;

  bool PV4D_VM_WORKER = false;
  bool VMEXPERT =  false;
  unsigned long MemSize = 0;
  unsigned int VMport = 0;

  MigrationJob Job;     

  // Read command line
  opterr = 0;  // suppress any error message about unknown options
  optind = 0;  // start with the search at the beginning

  int c;
  int argval;
  char* pointer;
  int i;
  while ((c = getopt(argc, argv, "+hf:s:m:t:p:x")) != -1)
    {
      switch (c) {
	  case 'h':
	      helpmessage (basename(argv[0]));
	      fatalexit();
	      break;
	  case 'f':
	  {
	      if ( CfgFileName == NULL)
		  CfgFileName = new char[199];
	      i = 0;
	      pointer = (char*) optarg;
	      while ( (*pointer != (char)0) && (i < 199-1) )
	      {
		  CfgFileName[i] = *pointer;
		  i++;
		  pointer++;
	      }
	      CfgFileName[i] = (char)0;
	      break;
	  }
	  case 't':
	      PV4D_VM_WORKER = true;
	      break;
	  case 'm':
	  {
	      MESSAGE("Option -m is deprecated. Machine file determined automatically.");
	      break;
	  }
	  case 's':
	  {
	      MemSize = (unsigned long) (atof(optarg));
	      if (MemSize*1024 < 1024*1024)
		  MemSize = (MemSize*1024) * 1024*1024;
	      break;
	  }
	  case 'p':
	  {
	      VMport = (unsigned int) (atof(optarg));
	      break;
	  }
	  case 'x':
	  {
	      VMEXPERT = true;
	      break;
	  }
	  default:
	      break;
      }
    }
  optind = 0; // Set back to first parameter so that vm can read it.

  // Initialization on head node
  if ( !PV4D_VM_WORKER )
    {
      if (CfgFileName == NULL) // Check for configuration file
	{
	  USERERRORLOG("Configuration File has not been given.\n");
	  helpmessage (basename(argv[0]));
	  exit(1);
	}

      // Read the configuration file
      CheckReadMigrationJob JobReader;
      if (JobReader.ReadConfigFileXML(CfgFileName, Job) != 0)
	{
	  exit(-1);
	}

      char JobFile[2*199 + 16];
      sprintf(JobFile, "%s/%s_mig.xml", Job.MigDirName, Job.JobName); 
	
      if (JobReader.WriteConfigFileXML(JobFile, Job) == -1)
	fatalexit();
   }


  int ierr = 0;


  switch(Job.GatherMode)
  {
    case ALL:
    {
      std::cout << "Migrator Constructor ...\n" << std::flush;
      std::cout << "done\n";
      break;
    }
    case COMMON_OFFSET:
    {
      MESSAGE("Starting with Job.GatherMode = %i", Job.GatherMode);
      
//       //MigrationFileHandler MFHandler;
//       //MFHandler.TouchOffsetGather(Job, Job.MigFileName, Job.N0OffVol, Job.NOffVol, Job.NtotOffVol, Job.MigFileMode);
// 
//       // Initialize migration subvolume      
// 
//       point3D<float> X0(Job.MigVol.first_x_coord.v,
// 			Job.MigVol.first_y_coord.v,
//                         Job.MigVol.first_z_coord);
//       point3D<int>   Nx(Job.MigVol.nx_xlines,
// 			Job.MigVol.ny_inlines,
//                         Job.MigVol.nz);
//       point3D<float> dx(Job.MigVol.dx_between_xlines,
// 			Job.MigVol.dy_between_inlines,
//                         Job.MigVol.dz);
//       MigVol3D MigVol(X0,Nx,dx);
//       
//       float * pMigVolMem = new float[Nx[0]*Nx[1]*Nx[2]];
//  
//       MigVol.InitVol(pMigVolMem);
//       MigVol.clear();
// 
//       cout<<"MigVol.x0="<<MigVol.getx0()<<endl;
//       cout<<"MigVol.y0="<<MigVol.gety0()<<endl;
// 
//        MigSubVol3D MigSubVol1(MigVol,1,3);
//        MigSubVol3D MigSubVol2(MigVol,2,3);
//        MigSubVol3D MigSubVol3(MigVol,3,3);
// 
// //       MigSubVol3D MigSubVol11(MigSubVol1,1,5);
// //       MigSubVol3D MigSubVol12(MigSubVol1,2,5);
// //       MigSubVol3D MigSubVol13(MigSubVol1,3,5);
// //       MigSubVol3D MigSubVol14(MigSubVol1,4,5);
// //       MigSubVol3D MigSubVol15(MigSubVol1,5,5);
// // 
// //       cout<<"11: ix0="<<MigSubVol11.getix0()<<endl;
// //       cout<<"12: ix0="<<MigSubVol12.getix0()<<endl;
// //       cout<<"13: ix0="<<MigSubVol13.getix0()<<endl;
// //       cout<<"14: ix0="<<MigSubVol14.getix0()<<endl;
// //       cout<<"15: ix0="<<MigSubVol15.getix0()<<endl;
// 
//       // initialize trace
// 
//       TraceFileHandler TFHandler(Job.TraceFileName,Job.TraceFileMode,ierr);
// 
//       TraceMem Trace;
// 
//       Trace.Init(TFHandler,Job);
// 
//       // initialize travel time table
// 
//       TravTimeTab TT(Job);
// 
//       // load trace 
// 
//       TT.LoadTT(Trace,MigSubVol1,Job);
//       //cout<<"TT loaded:"<<endl;
//       
// //       const int ix0=MigSubVol1.getix0();
// //       const int N_x=MigSubVol1.getNx();
// //       const int iy0=MigSubVol1.getiy0();
// //       const int N_y=MigSubVol1.getNy();
// //       const int N_z=MigSubVol1.getNz();
// // 
// //       float * T = new float[N_z];
// // 
// //       for(int ix=ix0;ix<ix0+N_x;ix++)
// //       {
// //         TT.Init_ix(ix);
// //         for(int iy=iy0;iy<iy0+N_y;iy++)
// //         {
// //           TT.Init_iy(iy);
// //           TT.Init_iz(N_z);
// //           TT.GetTT(T,N_z);
// //           cout<<"ix="<<ix<<" iy="<<iy<<" :"<<endl;
// //           for(int iz=0;iz<N_z;iz++)
// //           {
// //             cout<<"iz="<<iz<<" T[iz]="<<T[iz]<<endl;
// //           } 
// //           cout<<endl;
// //         }
// //       }
// // 
// //       delete[] T;
// 
//       MigTrace2SubVol(Job,Trace,TT,MigSubVol1);      
// 
//       float * pMigSubVolMem=MigSubVol1.getMemPtr();
//  
//        const int ix0=MigSubVol1.getix0();
//        const int N_x=MigSubVol1.getNx();
//        const int iy0=MigSubVol1.getiy0();
//        const int N_y=MigSubVol1.getNy();
//        const int N_z=MigSubVol1.getNz();
//  
//        float * pMigSubVolMemSave=new float[N_x*N_y*N_z];
//  
//        int idx = 0;
//  
//        for(int ix=ix0;ix<ix0+N_x;ix++)
//        {
//          for(int iy=iy0;iy<iy0+N_y;iy++)
//          {
//            for(int iz=0;iz<N_z;iz++)
//            {
//              pMigSubVolMemSave[idx]=pMigSubVolMem[idx];
//              idx++;
//            } 
//          }
//        }
// 
//       // second approach
// 
//       cout<<"Now, I am beginning the second approach!"<<endl;
// 
//       
//       
// 
//       MigVol.clear();
// 
//       //TraceBunch Bunch(Trace);
//       int oid=1;
//       TraceBunch Bunch(oid,1,1,400);
// 
//       Bunch.LoadFromDisk_CO(Job);
// 
//       MigBunch2SubVol(Job,Bunch,MigSubVol1);
//       MigBunch2SubVol(Job,Bunch,MigSubVol2);
//       MigBunch2SubVol(Job,Bunch,MigSubVol2);      
// 
//        pMigSubVolMem=MigSubVol1.getMemPtr();
//  
//        idx=0;
//        
//        int mismatch=0;
//        int mismatchcnt=0;
//        for(int ix=ix0;ix<ix0+N_x;ix++)
//        {
//          for(int iy=iy0;iy<iy0+N_y;iy++)
//          {
//            for(int iz=0;iz<N_z;iz++)
//            {
//              if(pMigSubVolMem[idx]!=pMigSubVolMemSave[idx])
//              {
//                mismatch=1;
//                mismatchcnt++;
//                //cout<<"diff="<<pMigSubVolMem[idx]-pMigSubVolMemSave[idx]<<endl;
//              }
//              idx++;
//            } 
//          }
//        }
//  
//        if(mismatch==1)
//        {
//          cout<<"!!! Mismatch !!!"<<endl;
//          cout<<mismatchcnt<<"/"<<N_x*N_y*N_z<<" items wrong!\n";
//        }
//        else
//          cout<<"!!! Everything Ok !!!"<<endl;
//  
//        cout<<"pMigVolMem="<<pMigVolMem<<endl;
//        cout<<"pMigVolSubMem="<<pMigSubVolMem<<endl;
// 
//       delete[] pMigSubVolMemSave;
// 
//       delete[] pMigVolMem;

      // Complete Migration of the test data set

      // define the migration volume

      point3D<float> X0(Job.MigVol.first_x_coord.v,
			Job.MigVol.first_y_coord.v,
                        Job.MigVol.first_z_coord);
      point3D<int>   Nx(Job.MigVol.nx_xlines,
			Job.MigVol.ny_inlines,
                        Job.MigVol.nz);
      point3D<float> dx(Job.MigVol.dx_between_xlines,
			Job.MigVol.dy_between_inlines,
                        Job.MigVol.dz);
      MigVol3D MigVol(X0,Nx,dx);
      
      float * pMigVolMem = new float[Nx[0]*Nx[1]*Nx[2]];

      // init the volume  

      MigVol.InitVol(pMigVolMem);

      // create subvolumina
      MigSubVol3D MigSubVol1(MigVol,1,3);
      MigSubVol3D MigSubVol2(MigVol,2,3);
      MigSubVol3D MigSubVol3(MigVol,3,3);

      // touch an offset gather
      MigrationFileHandler MFHandler;
      MFHandler.TouchOffsetGather(Job,Job.MigFileName,Job.N0OffVol,
                                  Job.NOffVol,Job.NtotOffVol,Job.MigFileMode); 

      char * pBunchData=new char[getSizeofTD(Job)];
      
      // loop over the offset classes
      for(int oid=1;oid<=Job.n_offset;oid++)
      {
        // clear the volume
        MigVol.clear();

        int noft=0;
        for(int pid=1;pid<=Npid_in_oid(oid,Job);pid++)
        {
          std::cout<<"Number of bunches in pid        ="<<Nbid_in_pid(oid,pid,Job)<<std::endl;
          for(int bid=1;bid<=Nbid_in_pid(oid,pid,Job);bid++)
          {
            std::cout<<"Number of traces in bid         ="<<NTrace_in_bid(oid,pid,bid,Job)<<std::endl;
            noft+=NTrace_in_bid(oid,pid,bid,Job); 

            // load entire offset class from disk
            //char * BunchData = new char[30*((99*5+9)*sizeof(float)+sizeof(int))];
            TraceBunch Bunch(pBunchData,oid,pid,bid,Job);

            /* Do not forget to uncomment prepare Data in
               TraceData.LoadFromDisk !!! */
            bool retval=Bunch.LoadFromDisk_CO(Job);

            //Bunch[2]->Dump();
            //std::cout<<Bunch.getTrace(0)->getsx().v<<std::endl;
            //Bunch.getTrace(0)->Dump();

            if(retval)
            {
              char * BunchData2=Bunch.getDataPtr();

              //TraceBunch Bunch2(BunchData2,oid,pid,bid,Job);
              TraceBunch Bunch2(BunchData2,oid,pid,bid,Job);
              //std::cout<<Bunch2.getTrace(0)->getsx().v<<std::endl;
              //Bunch2.getTrace(0)->Dump();
              //Bunch.LoadFromDisk_CO(Job);

              // migrate bunch to subvolumina
              MigBunch2SubVol(Job,Bunch2,MigSubVol1);
              MigBunch2SubVol(Job,Bunch2,MigSubVol2);
              MigBunch2SubVol(Job,Bunch2,MigSubVol3);
            }
          } 
        }

        // write offset class to disk
        grid3D G(X0,Nx,dx);
        MFHandler.WriteOffsetClass(Job.MigFileName,G,MigVol.getMemPtr(),
				   0,Nx[0],0,Nx[1],oid-1,1,Job.NtotOffVol,Job.MigFileMode);
        std::cout<<"Number of traces in offset class="<<NTrace_in_oid(oid,Job)<<std::endl;
        std::cout<<"Sum of traces in computation    ="<<noft<<std::endl<<std::endl;
      }       

      delete[] pBunchData;
      delete[] pMigVolMem;

      break; 
    }
    case COMMON_CDP:
    {
      std::cout << "Migrator Constructor ...\n" << std::flush;
      std::cout << "done\n";
      break;
    }
    default:
      std::cerr << "GatherMode " << Job.GatherMode << " not known.\n" << std::flush;
  }
      
  std::cout << "Computation finished ...\n" << std::flush;
  return EXIT_SUCCESS;
}

//   const point3D<float> x0(0.,0.,0.); 
//   const point3D<int>    N(10,10,10); 
//   const point3D<float> dx(12.5,12.5,12.5);
// 
//   MigVol3D Vol(x0,N,dx); 
// 
//   float * pMigVolMem = Vol.getMemPtr();
// 
//   pMigVolMem = new float(10*10*10);
// 
//   Vol.clear();
// 
//   int idx=0;
//   for(int ix=0;ix<Vol.getNx();ix++)
//   {
//     for(int iy=0;iy<Vol.getNy();iy++)
//     {
//       for(int iz=0;iz<Vol.getNz();iz++)
//       {
// 	std::cout<<pMigVolMem[idx]<<std::endl;
// 	idx++;
//       }
//     }
//   }
//  
//   return 0;
// 
// }