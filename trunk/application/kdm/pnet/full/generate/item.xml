<defun>

  <in name="config" type="config" place="config"/>
  <out name="volume_state" type="volume_state" place="volume_state"/>
  <out name="volume_with_store" type="volume_with_store" place="volume_with_store"/>
  <out name="bunch_with_store" type="bunch_with_store" place="bunch_with_store"/>

  <net>

    <place name="config" type="config"/>
    <place name="volume_state" type="volume_state"/>
    <place name="volume_with_store" type="volume_with_store"/>
    <place name="bunch_with_store" type="bunch_with_store"/>

    <struct name="state">
      <field name="offset" type="n_of_m"/>
      <field name="volume" type="n_of_m"/>
      <field name="copy" type="n_of_m"/>
      <field name="bunch" type="n_of_m"/>
      <field name="bunch_stores" type="long"/>
      <field name="volume_stores" type="long"/>
    </struct>

    <transition name="init">
      <defun>
        <in name="config" type="config"/>
        <out name="state" type="state"/>
        <expression>
          ${state.offset.id} := 0L;
          ${state.offset.max} := ${config.offsets};

          ${state.volume.id} := 0L;
          ${state.volume.max} := ${config.per.offset.volumes};

          ${state.copy.id} := 0L;
          ${state.copy.max} := ${config.per.volume.copies};

          ${state.bunch.id} := 0L;
          ${state.bunch.max} := ${config.per.offset.bunches};

          ${state.bunch_stores} := ${config.size.store.bunch};
          ${state.volume_stores} := ${config.size.store.volume};
        </expression>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-out port="state" place="state_offset"/>
    </transition>

    <place name="state_offset" type="state"/>

    <transition name="break_offset">
      <defun>
        <in name="state" type="state"/>
        <expression></expression>
        <condition>${state.offset.id} :ge: ${state.offset.max}</condition>
      </defun>
      <connect-in port="state" place="state_offset"/>
    </transition>

    <transition name="step_offset">
      <defun>
        <in name="state" type="state"/>
        <out name="volume" type="state"/>
        <out name="bunch" type="state"/>
        <expression>
          ${volume} := ${state};
          ${volume.volume.id} := 0L;

          ${bunch} := ${state};
          ${bunch.bunch.id} := 0L;
        </expression>
        <condition>${state.offset.id} :lt: ${state.offset.max}</condition>
      </defun>
      <connect-in port="state" place="state_offset"/>
      <connect-out port="volume" place="state_volume"/>
      <connect-out port="bunch" place="state_bunch"/>
    </transition>

    <place name="state_bunch" type="state"/>

    <transition name="break_bunch">
      <defun>
        <in name="state" type="state"/>
        <expression></expression>
        <condition>${state.bunch.id} :ge: ${state.bunch.max}</condition>
      </defun>
      <connect-in port="state" place="state_bunch"/>
    </transition>

    <place name="assoc" type="map" virtual="true"/>
    <place name="store_bunch" type="store_bunch" virtual="true"/>

    <transition name="step_bunch">
      <defun>
        <in name="state" type="state"/>
        <in name="assoc" type="map"/>
        <in name="store" type="store_bunch"/>
        <out name="state" type="state"/>
        <out name="bunch" type="bunch_with_store"/>
        <expression>
          ${bunch.bunch.id} := ${state.bunch.id};
          ${bunch.bunch.offset.id} := ${state.offset.id};
          ${bunch.store} := ${store};

          ${state.bunch.id} := ${state.bunch.id} + 1
        </expression>
        <condition>
          ${state.bunch.id} :lt: ${state.bunch.max}
        </condition>
        <condition>
          map_is_assigned (${assoc}, ${store.id})
        </condition>
        <condition>
          ${state.offset.id} :eq: map_get_assignment (${assoc}, ${store.id})
        </condition>
      </defun>
      <connect-in port="state" place="state_bunch"/>
      <connect-read port="assoc" place="assoc"/>
      <connect-in port="store" place="store_bunch"/>
      <connect-out port="state" place="state_bunch"/>
      <connect-out port="bunch" place="bunch_with_store"/>
    </transition>

    <place name="state_volume" type="state"/>

    <transition name="break_volume">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <expression>
          ${state.offset.id} := ${state.offset.id} + 1
        </expression>
        <condition>${state.volume.id} :ge: ${state.volume.max}</condition>
      </defun>
      <connect-in port="state" place="state_volume"/>
      <connect-out port="state" place="state_offset"/>
    </transition>

    <transition name="step_volume">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <out name="volume" type="volume_state"/>
        <expression>
          ${volume.volume.id} := ${state.volume.id};
          ${volume.volume.offset.id} := ${state.offset.id};
          ${volume.copies} := ${state.copy.max};

          ${volume.bunches.seen.id} := {};
          ${volume.bunches.left} := ${state.bunch.max};

          ${state.copy.id} := 0L;
        </expression>
        <condition>${state.volume.id} :lt: ${state.volume.max}</condition>
      </defun>
      <connect-in port="state" place="state_volume"/>
      <connect-out port="state" place="state_copy"/>
      <connect-out port="volume" place="volume_state"/>
    </transition>

    <place name="state_copy" type="state"/>

    <transition name="break_copy">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <expression>
          ${state.volume.id} := ${state.volume.id} + 1
        </expression>
        <condition>${state.copy.id} :ge: ${state.copy.max}</condition>
      </defun>
      <connect-in port="state" place="state_copy"/>
      <connect-out port="state" place="state_volume"/>
    </transition>

    <place name="store_volume" type="store_volume" virtual="true"/>

    <struct name="state_assign">
      <field name="volume_with_store" type="volume_with_store"/>
      <field name="bunch_store_to_assign" type="n_of_m"/>
    </struct>

    <place name="state_assign" type="state_assign"/>

    <transition name="step_copy">
      <defun>
        <in name="state" type="state"/>
        <in name="store" type="store_volume"/>
        <out name="state" type="state"/>
        <out name="state_assign" type="state_assign"/>
        <expression>
          ${state_assign.volume_with_store.volume.id}
            := ${state.volume.id};
          ${state_assign.volume_with_store.volume.offset.id}
            := ${state.offset.id};
          ${state_assign.volume_with_store.store}
            := ${store};

          ${b} := ${state.bunch_stores};
          ${v} := ${state.volume_stores};

          ${state_assign.bunch_store_to_assign.id}
            := long (ceil ((${store.id} + 0L) * ${b} / ${v}));
          ${state_assign.bunch_store_to_assign.max}
            := long (ceil ((${store.id} + 1L) * ${b} / ${v}));

          ${state.copy.id} := ${state.copy.id} + 1
        </expression>
        <condition>${state.copy.id} :lt: ${state.copy.max}</condition>
      </defun>
      <connect-in port="state" place="state_copy"/>
      <connect-out port="state" place="state_copy"/>
      <connect-in port="store" place="store_volume"/>
      <connect-out port="state_assign" place="state_assign"/>
    </transition>

    <transition name="break_assign">
      <defun>
        <in name="state" type="state_assign"/>
        <out name="volume" type="volume_with_store"/>
        <expression>
          ${volume} := ${state.volume_with_store}
        </expression>
        <condition>
          ${state.bunch_store_to_assign.id}
          :ge:
          ${state.bunch_store_to_assign.max}
        </condition>
      </defun>
      <connect-in port="state" place="state_assign"/>
      <connect-out port="volume" place="volume_with_store"/>
    </transition>

    <transition name="step_assign">
      <defun>
        <in name="state" type="state_assign"/>
        <out name="state" type="state_assign"/>
        <in name="assoc" type="map"/>
        <out name="assoc" type="map"/>
        <expression>
          ${assoc} := map_assign ( ${assoc}
                                 , ${state.bunch_store_to_assign.id}
                                 , ${state.volume_with_store.volume.offset.id}
                                 );

          ${state.bunch_store_to_assign.id}
            := ${state.bunch_store_to_assign.id} + 1;
        </expression>
        <condition>
          ${state.bunch_store_to_assign.id}
          :lt:
          ${state.bunch_store_to_assign.max}
        </condition>
      </defun>
      <connect-in port="state" place="state_assign"/>
      <connect-out port="state" place="state_assign"/>
      <connect-in port="assoc" place="assoc"/>
      <connect-out port="assoc" place="assoc"/>
    </transition>

  </net>
</defun>
