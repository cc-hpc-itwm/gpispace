<defun name="kdm">

  <include-structs href="types.xml"/>

  <in name="file_config" type="string" place="file_config"/>
  <in name="memsizeGPI" type="long" place="memsizeGPI"/>

  <out name="done" type="control" place="done"/>

  <net>

    <place name="file_config" type="string">
      <token>
        <value>
          "/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_TestKDMDaniel_new_fineTT_fineSL.xml"
        </value>
      </token>
    </place>

<!--
          "/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_Model.xml"
          "/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_C3NA.rahn.xml"
-->

    <place name="memsizeGPI" type="long">
      <token>
        <value>
          5*2^30
        </value>
      </token>
    </place>

    <place name="done" type="control"/>
    <place name="config_initialized" type="config"/>

    <place name="store_bunch" type="store_bunch"/>
    <place name="store_volume" type="store_volume"/>

    <place name="bunch_store_assoc_offset" type="map"/>

    <place name="volumes_left" type="long"/>

    <!-- ****************************************************************** -->

    <transition name="init" inline="true">
      <include-function href="init.xml"/>
      <connect-in port="file_config" place="file_config"/>
      <connect-in port="memsizeGPI" place="memsizeGPI"/>
      <connect-out port="config" place="config_initialized"/>
      <connect-out port="assoc" place="bunch_store_assoc_offset"/>
      <connect-out port="volumes_left" place="volumes_left"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="config_generate_store" type="config"/>
    <place name="config_generate_item" type="config"/>
    <place name="config_loadTT" type="config"/>
    <place name="config" type="config"/>

    <include-template href="4.xml"/>
    <specialize name="dist_config" use="quad">
      <type-map replace="T" with="config"/>
    </specialize>

    <transition name="dist_config" inline="true">
      <use name="dist_config"/>
      <connect-in port="in" place="config_initialized"/>
      <connect-out port="one" place="config"/>
      <connect-out port="two" place="config_generate_store"/>
      <connect-out port="three" place="config_generate_item"/>
      <connect-out port="four" place="config_loadTT"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="loadTT" inline="true">
      <include-function href="loadTT.xml"/>
      <connect-in port="config" place="config_loadTT"/>
      <connect-out port="config" place="config_process"/>
    </transition>

    <place name="config_process" type="config"/>

    <!-- ****************************************************************** -->

    <transition name="generate_store" inline="true">
      <include-function href="generate/store.xml"/>
      <connect-in port="config" place="config_generate_store"/>
      <connect-out port="store_bunch" place="store_bunch"/>
      <connect-out port="store_volume" place="store_volume"/>
      <connect-out port="number_store_volume" place="number_store_volume"/>
      <connect-out port="number_store_bunch" place="number_store_bunch"/>
    </transition>

    <place name="number_store_volume" type="long"/>
    <place name="number_store_bunch" type="long"/>

    <transition name="generate_item" inline="true">
      <include-function href="generate/item.xml"/>
      <place-map virtual="store_bunch" real="store_bunch"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <place-map virtual="assoc" real="bunch_store_assoc_offset"/>
      <connect-in port="config" place="config_generate_item"/>
      <connect-out port="volume_state" place="volume_state"/>
      <connect-out port="volume_with_store" place="volume_with_store"/>
      <connect-out port="bunch_with_store" place="bunch_with_store"/>
    </transition>

    <place name="volume_state" type="volume_state"/>
    <place name="volume_with_store" type="volume_with_store"/>
    <place name="bunch_with_store" type="bunch_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="load_bunch" inline="true">
      <include-function href="load/bunch.xml"/>
      <connect-read port="config" place="config"/>
      <connect-in port="bunch_with_store" place="bunch_with_store"/>
      <connect-out port="bunch_loaded" place="bunch_loaded"/>
    </transition>

    <place name="bunch_loaded" type="bunch_loaded"/>

    <!-- ****************************************************************** -->

    <transition name="initialize_volume">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_with_store"/>
        <out name="volume" type="volume_with_store"/>
        <module name="kdmfull" function="initialize_volume (config, volume)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_with_store"/>
      <connect-out port="volume" place="volume_initialized"/>
    </transition>

    <place name="volume_initialized" type="volume_with_store"/>

    <transition name="start_volume">
      <defun>
        <in name="volume" type="volume_with_store"/>
        <out name="started" type="volume_in_progress"/>
        <expression>
          ${started.volume} := ${volume};

          ${started.assigned.bunch.id} := @@;
          ${started.assigned.store.id} := @@;
        </expression>
      </defun>
      <connect-in port="volume" place="volume_initialized"/>
      <connect-out port="started" place="volume_in_progress"/>
    </transition>

    <place name="volume_in_progress" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="assign" priority="1">
      <defun>

        <in name="config" type="config"/>
        <in name="bunch" type="bunch_loaded"/>

        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <expression>
          ${volume.assigned.bunch.id}
            := stack_push ( ${volume.assigned.bunch.id}
                          , ${bunch.bunch.bunch.id}
                          );
          ${volume.assigned.store.id}
            := stack_push ( ${volume.assigned.store.id}
                          , ${bunch.bunch.store.id}
                          );

          ${state.bunches.seen.id}
            := bitset_insert ( ${state.bunches.seen.id}
                             , ${bunch.bunch.bunch.id}
                             )
        </expression>

        <condition>
          ${state.volume} :eq: ${volume.volume.volume}
        </condition>
        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          !bitset_is_element (${state.bunches.seen.id}, ${bunch.bunch.bunch.id})
        </condition>
        <condition>
          stack_size (${volume.assigned.bunch.id}) :lt: ${config.assign.most}
        </condition>
      </defun>

      <connect-read port="config" place="config"/>
      <connect-read port="bunch" place="bunch_loaded"/>

      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="volume_state"/>

      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_in_progress"/>
    </transition>

    <transition name="fully_assigned">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <condition>
          stack_size (${volume.assigned.bunch.id}) :ge: ${config.assign.most}
        </condition>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>
    </transition>

    <transition name="take_anyway">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <condition>
          stack_size (${volume.assigned.bunch.id}) :gt: 0
        </condition>
      </defun>
      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>
    </transition>

    <place name="volume_to_process" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="process">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <module name="kdmfull" function="process (config, volume)"/>
      </defun>
      <connect-read port="config" place="config_process"/>
      <connect-in port="volume" place="volume_to_process"/>
      <connect-out port="volume" place="volume_processed"/>
    </transition>

    <place name="volume_processed" type="volume_in_progress"/>

    <include-template href="dup.xml"/>
    <specialize name="dup_volume_in_progress" use="dup">
      <type-map replace="T" with="volume_in_progress"/>
    </specialize>

    <transition name="dist_volume_processed" inline="true">
      <use name="dup_volume_in_progress"/>
      <connect-in port="in" place="volume_processed"/>
      <connect-out port="one" place="update_volume_state"/>
      <connect-out port="two" place="update_bunch_state"/>
    </transition>

    <place name="update_volume_state" type="volume_in_progress"/>
    <place name="update_bunch_state" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="update_volume_state">
      <defun>
        <in name="processed" type="volume_in_progress"/>
        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>
        <expression>
          ${state.bunches.left}
            := ${state.bunches.left}
             - stack_size (${processed.assigned.bunch.id})
        </expression>
        <condition>${state.volume} :eq: ${processed.volume.volume}</condition>
      </defun>
      <connect-in port="processed" place="update_volume_state"/>
      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="volume_state"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="unassign">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <expression>
          ${bunch.wait} := ${bunch.wait} - 1;

          ${volume.assigned.bunch.id}
            := stack_pop (${volume.assigned.bunch.id});
          ${volume.assigned.store.id}
            := stack_pop (${volume.assigned.store.id});
        </expression>
        <condition>
          !stack_empty (${volume.assigned.bunch.id})
        </condition>
        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          ${bunch.bunch.bunch.id} :eq: stack_top (${volume.assigned.bunch.id})
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="bunch" place="bunch_loaded"/>
      <connect-in port="volume" place="update_bunch_state"/>
      <connect-out port="volume" place="update_bunch_state"/>
    </transition>

    <transition name="unassigned">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <expression></expression>
        <condition>
          stack_empty (${volume.assigned.bunch.id})
        </condition>
      </defun>
      <connect-in port="volume" place="update_bunch_state"/>
      <connect-out port="volume" place="volume_in_progress"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="bunch_done">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="store" type="store_bunch"/>
        <expression>
          ${store} := ${bunch.bunch.store}
        </expression>
        <condition>
          ${bunch.wait} :le: 0
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="store" place="store_bunch"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="volume_done">
      <defun>
        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>
        <expression></expression>
        <condition>
          ${state.bunches.left} :le: 0
        </condition>
      </defun>
      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="volume_done"/>
    </transition>

    <place name="volume_done" type="volume_state"/>

    <transition name="reduce_start">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="sum" type="volume_in_reduction"/>
        <expression>
          ${sum.volume} := ${volume.volume};
          ${sum.left} := ${state.copies} - 1;
        </expression>
        <condition>
          ${state.volume} :eq: ${volume.volume.volume}
        </condition>
      </defun>
      <connect-in port="state" place="volume_done"/>
      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="sum" place="volume_in_reduction"/>
    </transition>

    <place name="volume_in_reduction" type="volume_in_reduction"/>

    <transition name="reduce_pair">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <in name="vol" type="volume_in_progress"/>
        <out name="pair" type="pair_to_reduce"/>
        <expression>
          ${pair.sum} := ${sum};
          ${pair.vol} := ${vol.volume}
        </expression>
        <condition>
          ${sum.volume.volume} :eq: ${vol.volume.volume}
        </condition>
      </defun>
      <connect-in port="vol" place="volume_in_progress"/>
      <connect-in port="sum" place="volume_in_reduction"/>
      <connect-out port="pair" place="pair_to_reduce"/>
    </transition>

    <place name="pair_to_reduce" type="pair_to_reduce"/>

    <transition name="reduce">
      <defun>
        <in name="config" type="config"/>
        <in name="pair" type="pair_to_reduce"/>
        <out name="pair" type="pair_to_reduce"/>
        <module name="kdmfull" function="reduce (pair)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="pair" place="pair_to_reduce"/>
      <connect-out port="pair" place="pair_reduced"/>
    </transition>

    <place name="pair_reduced" type="pair_to_reduce"/>

    <transition name="reduce_unpair">
      <defun>
        <in name="pair" type="pair_to_reduce"/>
        <out name="sum" type="volume_in_reduction"/>
        <out name="vol" type="volume_with_store"/>
        <expression>
          ${sum} := ${pair.sum};
          ${sum.left} := ${sum.left} - 1L;
          ${vol} := ${pair.vol}
        </expression>
      </defun>
      <connect-in port="pair" place="pair_reduced"/>
      <connect-out port="sum" place="volume_in_reduction"/>
      <connect-out port="vol" place="volume_written"/>
    </transition>

    <transition name="reduce_done">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <out name="volume" type="volume_with_store"/>
        <expression>
          ${volume} := ${sum.volume}
        </expression>
        <condition>
          ${sum.left} :le: 0L
        </condition>
      </defun>
      <connect-in port="sum" place="volume_in_reduction"/>
      <connect-out port="volume" place="volume_to_be_written"/>
    </transition>

    <place name="volume_to_be_written" type="volume_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="write">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_with_store"/>
        <out name="volume" type="volume_with_store"/>
        <module name="kdmfull" function="write (config, volume)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_to_be_written"/>
      <connect-out port="volume" place="volume_written"/>
    </transition>

    <place name="volume_written" type="volume_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="give_back_store_volume">
      <defun>
        <in name="volume_with_store" type="volume_with_store"/>
        <out name="volume" type="volume"/>
        <out name="store" type="store_volume"/>
        <expression>
          ${store} := ${volume_with_store.store};
          ${volume} := ${volume_with_store.volume}
        </expression>
      </defun>
      <connect-in port="volume_with_store" place="volume_written"/>
      <connect-out port="store" place="store_volume"/>
      <connect-out port="volume" place="volume_to_be_finalized"/>
    </transition>

    <place name="volume_to_be_finalized" type="volume"/>

    <include-template href="wait.xml"/>
    <specialize name="wait_volume" use="wait">
      <type-map replace="T" with="volume"/>
    </specialize>

    <transition name="wait_volume">
      <use name="wait_volume"/>
      <place-map virtual="wait" real="volumes_left"/>
      <connect-in port="trigger" place="volume_to_be_finalized"/>
      <connect-out port="done" place="volumes_done"/>
    </transition>

    <place name="volumes_done" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="eat_store" inline="true">
      <include-function href="eat/store.xml"/>
      <place-map virtual="store_bunch" real="store_bunch"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <connect-in port="number_store_volume" place="number_store_volume"/>
      <connect-in port="number_store_bunch" place="number_store_bunch"/>
      <connect-in port="trigger" place="volumes_done"/>
      <connect-out port="done" place="done_eat_store"/>
    </transition>

    <place name="done_eat_store" type="control"/>

    <transition name="cleanup">
      <defun>
        <in name="config" type="config"/>
        <in name="assoc" type="map"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="config" place="config_process"/>
      <connect-in port="assoc" place="bunch_store_assoc_offset"/>
      <connect-in port="trigger" place="done_eat_store"/>
      <connect-out port="trigger" place="done_cleanup"/>
    </transition>

    <place name="done_cleanup" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="finalize">
      <defun>
        <in name="config" type="config"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <module name="kdmfull" function="finalize (config)"/>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-in port="trigger" place="done_cleanup"/>
      <connect-out port="trigger" place="done"/>
   </transition>
  </net>
</defun>
