<defun>

  <in name="config" type="config" place="config"/>

  <in name="volume_state" type="volume_state" place="volume_state"/>
  <in name="volume_in_progress" type="volume_in_progress" place="volume_in_progress"/>
  <in name="bunch_loaded" type="bunch_loaded" place="bunch_loaded"/>

  <out name="volume_to_process" type="volume_in_progress" place="volume_to_process"/>
  <out name="volume_state" type="volume_state" place="volume_state"/>
  <out name="credit" type="control" place="credit"/>

  <net>

    <place name="config" type="config"/>
    <place name="volume_state" type="volume_state"/>
    <place name="volume_in_progress" type="volume_in_progress"/>
    <place name="bunch_loaded" type="bunch_loaded"/>

    <place name="volume_to_process" type="volume_in_progress"/>
    <place name="credit" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="assign_more">
      <defun>
        <in name="bunch" type="bunch_loaded"/>

        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <expression>
          ${volume.assigned.bunch.id}
            := stack_push ( ${volume.assigned.bunch.id}
                          , ${bunch.bunch.bunch.id}
                          );
          ${volume.assigned.store.id}
            := stack_push ( ${volume.assigned.store.id}
                          , ${bunch.bunch.store.id}
                          );

          ${state.bunches.seen.id}
            := bitset_insert ( ${state.bunches.seen.id}
                             , ${bunch.bunch.bunch.id}
                             )
        </expression>

        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          !bitset_is_element (${state.bunches.seen.id}, ${bunch.bunch.bunch.id})
        </condition>
      </defun>

      <connect-read port="bunch" place="bunch_loaded"/>

      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="volume_state"/>

      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_in_progress"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="fully_assigned" priority="1">
      <defun>
        <in name="config" type="config"/>

        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <out name="credit" type="control"/>

        <expression>
          ${credit} := []
        </expression>

        <condition>
          stack_size (${volume.assigned.bunch.id}) :ge: ${config.assign.most}
        </condition>

      </defun>

      <connect-read port="config" place="config"/>

      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="volume_state"/>

      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>

      <connect-out port="credit" place="credit"/>
    </transition>

    <transition name="take_anyway">
      <defun>
        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <out name="credit" type="control"/>

        <expression>
          ${credit} := []
        </expression>
      </defun>

      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="volume_state"/>

      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>

      <connect-out port="credit" place="credit"/>
    </transition>

  </net>

</defun>
