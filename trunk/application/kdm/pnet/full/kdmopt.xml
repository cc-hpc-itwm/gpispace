<defun name="kdm">

  <include-structs href="types.xml"/>

  <struct name="pair_bunch_volume">
    <field name="bunch" type="bunch_loaded"/>
    <field name="volume" type="volume_in_progress"/>
  </struct>

  <struct name="pair_volume_in_progress_volume_state">
    <field name="in_progress" type="volume_in_progress"/>
    <field name="state" type="volume_state"/>
  </struct>

  <in name="file_config" type="string" place="file_config"/>
  <in name="file_param" type="string" place="file_param"/>
  <in name="memsizeGPI" type="long" place="memsizeGPI"/>

  <out name="done" type="control" place="done"/>

  <net>

<!--

"/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_C3NA.rahn"
"/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_Model"
"/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_C3NA.rahn"
"/fhgfs/HPC/rahn/kdm/Kirchhoff_C3NA.rahn"

"/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_TestKDMDaniel_new_fineTT_fineSL"
-->

    <properties name="pnetc">
      <properties name="context">
        <property key="file">
"/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_TestKDMDaniel_new_fineTT_fineSL"
        </property>
      </properties>
    </properties>

    <place name="file_config" type="string">
      <token><value>${file} + ".xml"</value></token>
    </place>

    <place name="file_param" type="string">
      <token><value>${file} + ".param.text"</value></token>
    </place>

    <place name="memsizeGPI" type="long">
      <token>
        <value>
          5*2^30
        </value>
      </token>
    </place>

    <place name="done" type="control"/>
    <place name="config_initialized" type="config"/>

    <place name="store_bunch" type="store_bunch"/>
    <place name="store_volume" type="store_volume"/>

    <place name="bunch_store_assoc_offset" type="map"/>

    <place name="volumes_left" type="long"/>

    <!-- ****************************************************************** -->

    <transition name="init_config" inline="true">
      <include-function href="init/config.xml"/>
      <connect-in port="file_config" place="file_config"/>
      <connect-in port="file_param" place="file_param"/>
      <connect-in port="memsizeGPI" place="memsizeGPI"/>
      <connect-out port="config" place="config_initialized"/>
      <connect-out port="assoc" place="bunch_store_assoc_offset"/>
      <connect-out port="volumes_left" place="volumes_left"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="config_generate_store" type="config"/>
    <place name="config_generate_item" type="config"/>
    <place name="config_loadTT" type="config"/>
    <place name="config" type="config"/>

    <include-template href="4.xml"/>
    <specialize name="dist_config" use="quad">
      <type-map replace="T" with="config"/>
    </specialize>

    <transition name="dist_config" inline="true">
      <use name="dist_config"/>
      <connect-in port="in" place="config_initialized"/>
      <connect-out port="one" place="config"/>
      <connect-out port="two" place="config_generate_store"/>
      <connect-out port="three" place="config_generate_item"/>
      <connect-out port="four" place="config_loadTT"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="loadTT" inline="true">
      <include-function href="loadTT.xml"/>
      <connect-in port="config" place="config_loadTT"/>
      <connect-out port="config" place="config_process"/>
    </transition>

    <place name="config_process" type="config"/>

    <!-- ****************************************************************** -->

    <transition name="generate_store" inline="true">
      <include-function href="generate/store.xml"/>
      <connect-in port="config" place="config_generate_store"/>
      <connect-out port="store_bunch" place="store_bunch"/>
      <connect-out port="store_volume" place="store_volume"/>
      <connect-out port="number_store_volume" place="number_store_volume"/>
      <connect-out port="number_store_bunch" place="number_store_bunch"/>
    </transition>

    <place name="number_store_volume" type="long"/>
    <place name="number_store_bunch" type="long"/>

    <transition name="generate_item" inline="true">
      <include-function href="generate/item.xml"/>
      <place-map virtual="store_bunch" real="store_bunch"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <place-map virtual="assoc" real="bunch_store_assoc_offset"/>
      <connect-in port="config" place="config_generate_item"/>
      <connect-out port="volume_state" place="volume_state_pre"/>
      <connect-out port="volume_with_store" place="volume_with_store"/>
      <connect-out port="bunch_with_store" place="bunch_with_store"/>
    </transition>

    <place name="volume_state_pre" type="volume_state"/>
    <place name="volume_state" type="volume_state"/>
    <place name="volume_with_store" type="volume_with_store"/>
    <place name="bunch_with_store" type="bunch_with_store"/>

    <transition name="take_volume_state">
      <defun>
        <in name="volume_state" type="volume_state"/>
        <out name="volume_state" type="volume_state"/>
        <in name="credit_update_volume_state" type="control"/>
        <expression>
        </expression>
      </defun>
      <connect-in port="volume_state" place="volume_state_pre"/>
      <connect-out port="volume_state" place="pre_update_volume_state_state"/>
      <connect-in port="credit_update_volume_state" place="credit_update_volume_state"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="load_bunch" inline="true">
      <include-function href="load/bunch.xml"/>
      <connect-read port="config" place="config"/>
      <connect-in port="bunch_with_store" place="bunch_with_store"/>
      <connect-out port="bunch_loaded" place="bunch_loaded_pre"/>
    </transition>

    <place name="bunch_loaded" type="bunch_loaded"/>
    <place name="bunch_loaded_pre" type="bunch_loaded"/>

    <transition name="take_bunch_loaded">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <in name="credit_match_assign" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="bunch" place="bunch_loaded_pre"/>
      <connect-out port="bunch" place="pre_match_assign_bunch_loaded"/>
      <connect-in port="credit_match_assign" place="credit_match_assign"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="initialize_volume" inline="true">
      <include-function href="init/volume.xml"/>
      <connect-read port="config" place="config"/>
      <connect-in port="volume_with_store" place="volume_with_store"/>
      <connect-out port="volume_in_progress" place="volume_in_progress_pre"/>
    </transition>

    <place name="volume_in_progress" type="volume_in_progress"/>
    <place name="volume_in_progress_pre" type="volume_in_progress"/>

    <transition name="take_volume_in_progress">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <in name="credit_match_assign" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="volume" place="volume_in_progress_pre"/>
      <connect-out port="volume" place="pre_match_assign_volume_in_progress"/>
      <connect-in port="credit_match_assign" place="credit_match_assign"/>
    </transition>

    <!-- ****************************************************************** -->

    <!-- Grünewald Transformation for match_assign -->

    <place name="pre_match_assign_bunch_loaded" type="bunch_loaded"/>
    <place name="pre_match_assign_volume_in_progress" type="volume_in_progress"/>

    <place name="credit_match_assign" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="match_assign_bunch_loaded" priority="1">
      <defun>

        <in name="bunch" type="bunch_loaded"/>
        <in name="volume" type="volume_in_progress"/>

        <out name="pair" type="pair_bunch_volume"/>
        <out name="credit_match_assign" type="control"/>

        <expression>
          ${volume.assigned.bunch.id}
            := stack_push ( ${volume.assigned.bunch.id}
                          , ${bunch.bunch.bunch.id}
                          );
          ${volume.assigned.store.id}
            := stack_push ( ${volume.assigned.store.id}
                          , ${bunch.bunch.store.id}
                          );

          ${bunch.bunch.volumes.seen.id}
            := bitset_insert ( ${bunch.bunch.volumes.seen.id}
                             , ${volume.volume.volume.id}
                             );

          ${pair.bunch} := ${bunch};
          ${pair.volume} := ${volume};

          ${credit_match_assign} := []
        </expression>

        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          !bitset_is_element (${bunch.bunch.volumes.seen.id}, ${volume.volume.volume.id})
        </condition>
      </defun>

      <connect-in port="bunch" place="pre_match_assign_bunch_loaded"/>
      <connect-in port="volume" place="volume_in_progress"/>

      <connect-out port="pair" place="pair_assign"/>
      <connect-out port="credit_match_assign" place="credit_match_assign"/>
    </transition>

    <transition name="match_assign_volume_in_progress" priority="1">
      <defun>

        <in name="bunch" type="bunch_loaded"/>
        <in name="volume" type="volume_in_progress"/>

        <out name="pair" type="pair_bunch_volume"/>
        <out name="credit_match_assign" type="control"/>

        <expression>
          ${volume.assigned.bunch.id}
            := stack_push ( ${volume.assigned.bunch.id}
                          , ${bunch.bunch.bunch.id}
                          );
          ${volume.assigned.store.id}
            := stack_push ( ${volume.assigned.store.id}
                          , ${bunch.bunch.store.id}
                          );

          ${bunch.bunch.volumes.seen.id}
            := bitset_insert ( ${bunch.bunch.volumes.seen.id}
                             , ${volume.volume.volume.id}
                             );

          ${pair.bunch} := ${bunch};
          ${pair.volume} := ${volume};

          ${credit_match_assign} := []
        </expression>

        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          !bitset_is_element (${bunch.bunch.volumes.seen.id}, ${volume.volume.volume.id})
        </condition>
      </defun>

      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-in port="volume" place="pre_match_assign_volume_in_progress"/>

      <connect-out port="pair" place="pair_assign"/>
      <connect-out port="credit_match_assign" place="credit_match_assign"/>
    </transition>

    <transition name="no_match_assign_bunch_loaded">
      <defun>

        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <out name="credit_match_assign" type="control"/>

        <expression>
          ${credit_match_assign} := []
        </expression>
      </defun>

      <connect-in port="bunch" place="pre_match_assign_bunch_loaded"/>
      <connect-out port="bunch" place="bunch_loaded"/>

      <connect-out port="credit_match_assign" place="credit_match_assign"/>
    </transition>

    <transition name="no_match_assign_volume_in_progress">
      <defun>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <out name="credit_match_assign" type="control"/>

        <expression>
          ${credit_match_assign} := []
        </expression>
      </defun>

      <connect-in port="volume" place="pre_match_assign_volume_in_progress"/>
      <connect-out port="volume" place="volume_in_progress"/>
      <connect-out port="credit_match_assign" place="credit_match_assign"/>
    </transition>

    <place name="pair_assign" type="pair_bunch_volume"/>

    <transition name="assign_leave">
      <defun>
        <in name="pair" type="pair_bunch_volume"/>
        <out name="volume" type="volume_in_progress"/>
        <out name="bunch" type="bunch_loaded"/>
        <in name="credit_volume_check_fully_assigned" type="control"/>
        <expression>
          ${bunch} := ${pair.bunch};
          ${volume} := ${pair.volume};
        </expression>
      </defun>
      <connect-in port="pair" place="pair_assign"/>
      <connect-out port="bunch" place="bunch_loaded_pre"/>
      <connect-out port="volume" place="volume_check_fully_assigned"/>
      <connect-in port="credit_volume_check_fully_assigned" place="credit_volume_check_fully_assigned"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="volume_check_fully_assigned" type="volume_in_progress"/>
    <place name="credit_volume_check_fully_assigned" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="fully_assigned">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <out name="credit_volume_check_fully_assigned" type="control"/>
        <expression>
          ${credit_volume_check_fully_assigned} := []
        </expression>
        <condition>
          stack_size (${volume.assigned.bunch.id}) :ge: ${config.assign.most}
        </condition>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_check_fully_assigned"/>
      <connect-out port="volume" place="volume_to_process"/>
      <connect-out port="credit_volume_check_fully_assigned" place="credit_volume_check_fully_assigned"/>
    </transition>

    <transition name="not_fully_assigned">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <out name="credit_volume_check_fully_assigned" type="control"/>
        <expression>
          ${credit_volume_check_fully_assigned} := []
        </expression>
        <condition>
          stack_size (${volume.assigned.bunch.id}) :lt: ${config.assign.most}
        </condition>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_check_fully_assigned"/>
      <connect-out port="volume" place="volume_in_progress_pre"/>
      <connect-out port="credit_volume_check_fully_assigned" place="credit_volume_check_fully_assigned"/>
    </transition>

    <transition name="take_anyway">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <condition>
          stack_size (${volume.assigned.bunch.id}) :gt: 0
        </condition>
      </defun>
      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>
    </transition>

    <place name="volume_to_process" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="process">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <module name="kdmfull" function="process (config, volume)"/>
      </defun>
      <connect-read port="config" place="config_process"/>
      <connect-in port="volume" place="volume_to_process"/>
      <connect-out port="volume" place="volume_processed_pre"/>
    </transition>

    <place name="volume_processed_pre" type="volume_in_progress"/>

    <include-template href="dup.xml"/>
    <specialize name="dup_volume_in_progress" use="dup">
      <type-map replace="T" with="volume_in_progress"/>
    </specialize>

    <place name="update_bunch_state" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <!-- Grünewald Transformation for update_volume_state -->

    <place name="credit_update_volume_state" type="control">
      <token><value>[]</value></token>
    </place>

    <place name="pre_update_volume_state_processed" type="volume_in_progress"/>
    <place name="pre_update_volume_state_state" type="volume_state"/>

    <transition name="match_update_volume_state_processed" priority="1">
      <defun>
        <in name="processed" type="volume_in_progress"/>
        <in name="state" type="volume_state"/>
        <out name="pair" type="pair_volume_in_progress_volume_state"/>
        <out name="credit_update_volume_state" type="control"/>
        <expression>
          ${pair.in_progress} := ${processed};
          ${pair.state} := ${state};
          ${credit_update_volume_state} := []
        </expression>
        <condition>
          ${state.volume} :eq: ${processed.volume.volume}
        </condition>
      </defun>
      <connect-in port="processed" place="pre_update_volume_state_processed"/>
      <connect-in port="state" place="volume_state"/>
      <connect-out port="pair" place="pair_update_volume_state"/>
      <connect-out port="credit_update_volume_state" place="credit_update_volume_state"/>
    </transition>

    <transition name="match_update_volume_state_state" priority="1">
      <defun>
        <in name="processed" type="volume_in_progress"/>
        <in name="state" type="volume_state"/>
        <out name="pair" type="pair_volume_in_progress_volume_state"/>
        <out name="credit_update_volume_state" type="control"/>
        <expression>
          ${pair.in_progress} := ${processed};
          ${pair.state} := ${state};
          ${credit_update_volume_state} := []
        </expression>
        <condition>
          ${state.volume} :eq: ${processed.volume.volume}
        </condition>
      </defun>
      <connect-in port="processed" place="volume_processed"/>
      <connect-in port="state" place="pre_update_volume_state_state"/>
      <connect-out port="pair" place="pair_update_volume_state"/>
      <connect-out port="credit_update_volume_state" place="credit_update_volume_state"/>
    </transition>

    <transition name="no_match_update_volume_state_processed">
      <defun>
        <in name="processed" type="volume_in_progress"/>
        <out name="processed" type="volume_in_progress"/>
        <out name="credit_update_volume_state" type="control"/>
        <expression>
          ${credit_update_volume_state} := []
        </expression>
      </defun>
      <connect-in port="processed" place="pre_update_volume_state_processed"/>
      <connect-out port="processed" place="volume_processed"/>
      <connect-out port="credit_update_volume_state" place="credit_update_volume_state"/>
    </transition>

    <transition name="no_match_update_volume_state_state">
      <defun>
        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>
        <out name="credit_update_volume_state" type="control"/>
        <expression>
          ${credit_update_volume_state} := []
        </expression>
      </defun>
      <connect-in port="state" place="pre_update_volume_state_state"/>
      <connect-out port="state" place="volume_state"/>
      <connect-out port="credit_update_volume_state" place="credit_update_volume_state"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="pair_update_volume_state" type="pair_volume_in_progress_volume_state"/>

    <transition name="update_volume_state">
      <defun>
        <in name="pair" type="pair_volume_in_progress_volume_state"/>
        <out name="processed" type="volume_in_progress"/>
        <out name="state" type="volume_state"/>
        <in name="credit_volume_check_done" type="control"/>
        <expression>
          ${state} := ${pair.state};
          ${processed} := ${pair.in_progress};
          ${state.bunches.left}
            := ${state.bunches.left}
             - stack_size (${processed.assigned.bunch.id});
        </expression>
      </defun>
      <connect-in port="pair" place="pair_update_volume_state"/>
      <connect-out port="processed" place="wait_volume_check_done"/>
      <connect-out port="state" place="volume_check_done"/>
      <connect-in port="credit_volume_check_done" place="credit_volume_check_done"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="volume_processed" type="volume_in_progress"/>

    <transition name="take_volume_processed">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <in name="credit_update_volume_state" type="control"/>
        <expression>
        </expression>
      </defun>
      <connect-in port="volume" place="volume_processed_pre"/>
      <connect-out port="volume" place="pre_update_volume_state_processed"/>
      <connect-in port="credit_update_volume_state" place="credit_update_volume_state"/>
    </transition>

    <place name="volume_check_done" type="volume_state"/>
    <place name="credit_volume_check_done" type="control">
      <token><value>[]</value></token>
    </place>
    <place name="wait_volume_check_done" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="unassign">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <in name="credit_bunch_check_done" type="control"/>
        <in name="credit_volume_check_unassigned" type="control"/>
        <expression>
          ${bunch.wait} := ${bunch.wait} - 1;

          ${volume.assigned.bunch.id}
            := stack_pop (${volume.assigned.bunch.id});
          ${volume.assigned.store.id}
            := stack_pop (${volume.assigned.store.id});
        </expression>
        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          ${bunch.bunch.bunch.id} :eq: stack_top (${volume.assigned.bunch.id})
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="bunch" place="bunch_check_done"/>
      <connect-in port="volume" place="update_bunch_state"/>
      <connect-out port="volume" place="volume_check_unassigned"/>
      <connect-in port="credit_bunch_check_done" place="credit_bunch_check_done"/>
      <connect-in port="credit_volume_check_unassigned" place="credit_volume_check_unassigned"/>
    </transition>

    <place name="volume_check_unassigned" type="volume_in_progress"/>
    <place name="credit_volume_check_unassigned" type="control">
      <token><value>[]</value></token>
    </place>

    <place name="bunch_check_done" type="bunch_loaded"/>
    <place name="credit_bunch_check_done" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="unassigned">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <out name="credit_volume_check_unassigned" type="control"/>
        <in name="credit_volume_reduce_start" type="control"/>
        <expression>
          ${credit_volume_check_unassigned} := []
        </expression>
        <condition>
          stack_empty (${volume.assigned.bunch.id})
        </condition>
      </defun>
      <connect-in port="volume" place="volume_check_unassigned"/>
      <connect-out port="volume" place="volume_reduce_start"/>
      <connect-out port="credit_volume_check_unassigned" place="credit_volume_check_unassigned"/>
      <connect-in port="credit_volume_reduce_start" place="credit_volume_reduce_start"/>
    </transition>

    <transition name="not_unassigned">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <out name="credit_volume_check_unassigned" type="control"/>
        <expression>
          ${credit_volume_check_unassigned} := []
        </expression>
        <condition>
          !stack_empty (${volume.assigned.bunch.id})
        </condition>
      </defun>
      <connect-in port="volume" place="volume_check_unassigned"/>
      <connect-out port="volume" place="update_bunch_state"/>
      <connect-out port="credit_volume_check_unassigned" place="credit_volume_check_unassigned"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="volume_reduce_start" type="volume_in_progress"/>
    <place name="credit_volume_reduce_start" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="reduce_start" priority="1">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <in name="state" type="volume_state"/>
        <out name="sum" type="volume_in_reduction"/>
        <out name="credit_volume_reduce_start" type="control"/>
        <in name="credit_volume_check_reduce_done" type="control"/>
        <expression>
          ${sum.volume} := ${volume.volume};
          ${sum.left} := ${state.copies} - 1;
          ${credit_volume_reduce_start} := []
        </expression>
        <condition>
          ${state.volume} :eq: ${volume.volume.volume}
        </condition>
      </defun>
      <connect-in port="volume" place="volume_reduce_start"/>
      <connect-in port="state" place="volume_done"/>
      <connect-out port="sum" place="volume_check_reduce_done"/>
      <connect-out port="credit_volume_reduce_start" place="credit_volume_reduce_start"/>
      <connect-in port="credit_volume_check_reduce_done" place="credit_volume_check_reduce_done"/>
    </transition>

    <transition name="no_reduce_start">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <in name="credit_reduce_pair" type="control"/>
        <out name="volume" type="volume_in_progress"/>
        <out name="credit_volume_reduce_start" type="control"/>
        <expression>
          ${credit_volume_reduce_start} := []
        </expression>
      </defun>
      <connect-in port="volume" place="volume_reduce_start"/>
      <connect-out port="volume" place="pre_reduce_pair_in_progress"/>
      <connect-out port="credit_volume_reduce_start" place="credit_volume_reduce_start"/>
      <connect-in port="credit_reduce_pair" place="credit_reduce_pair"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="bunch_done">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="store" type="store_bunch"/>
        <out name="credit_bunch_check_done" type="control"/>
        <expression>
          ${store} := ${bunch.bunch.store};
          ${credit_bunch_check_done} := []
        </expression>
        <condition>
          ${bunch.wait} :le: 0
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_check_done"/>
      <connect-out port="store" place="store_bunch"/>
      <connect-out port="credit_bunch_check_done" place="credit_bunch_check_done"/>
    </transition>

    <transition name="bunch_not_done">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <out name="credit_bunch_check_done" type="control"/>
        <expression>
          ${credit_bunch_check_done} := []
        </expression>
        <condition>
          ${bunch.wait} :gt: 0
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_check_done"/>
      <connect-out port="bunch" place="bunch_loaded_pre"/>
      <connect-out port="credit_bunch_check_done" place="credit_bunch_check_done"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="volume_not_done">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="volume_in_progress" type="volume_in_progress"/>
        <out name="volume_in_progress" type="volume_in_progress"/>
        <out name="state" type="volume_state"/>
        <out name="credit_volume_check_done" type="control"/>
        <expression>
          ${credit_volume_check_done} := []
        </expression>
        <condition>
          ${state.bunches.left} :gt: 0
        </condition>
      </defun>
      <connect-in port="state" place="volume_check_done"/>
      <connect-in port="volume_in_progress" place="wait_volume_check_done"/>
      <connect-out port="volume_in_progress" place="update_bunch_state"/>
      <connect-out port="state" place="volume_state_pre"/>
      <connect-out port="credit_volume_check_done" place="credit_volume_check_done"/>
    </transition>

    <transition name="volume_done">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="volume_in_progress" type="volume_in_progress"/>
        <out name="volume_in_progress" type="volume_in_progress"/>
        <out name="state" type="volume_state"/>
        <out name="credit_volume_check_done" type="control"/>
        <expression>
          ${credit_volume_check_done} := []
        </expression>
        <condition>
          ${state.bunches.left} :le: 0
        </condition>
      </defun>
      <connect-in port="state" place="volume_check_done"/>
      <connect-in port="volume_in_progress" place="wait_volume_check_done"/>
      <connect-out port="volume_in_progress" place="update_bunch_state"/>
      <connect-out port="state" place="volume_done"/>
      <connect-out port="credit_volume_check_done" place="credit_volume_check_done"/>
    </transition>

    <place name="volume_done" type="volume_state"/>

    <place name="volume_in_reduction" type="volume_in_reduction"/>

    <!-- ****************************************************************** -->

    <!-- Grünewald Transformation for reduce_pair -->

    <place name="credit_reduce_pair" type="control">
      <token><value>[]</value></token>
    </place>

    <place name="pre_reduce_pair_in_progress" type="volume_in_progress"/>
    <place name="pre_reduce_pair_in_reduction" type="volume_in_reduction"/>

    <transition name="reduce_pair_in_progress" priority="1">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <in name="vol" type="volume_in_progress"/>
        <out name="pair" type="pair_to_reduce"/>
        <out name="credit_reduce_pair" type="control"/>
        <expression>
          ${pair.sum} := ${sum};
          ${pair.vol} := ${vol.volume};
          ${credit_reduce_pair} := []
        </expression>
        <condition>
          ${sum.volume.volume} :eq: ${vol.volume.volume}
        </condition>
      </defun>
      <connect-in port="vol" place="pre_reduce_pair_in_progress"/>
      <connect-in port="sum" place="volume_in_reduction"/>
      <connect-out port="pair" place="pair_to_reduce"/>
      <connect-out port="credit_reduce_pair" place="credit_reduce_pair"/>
    </transition>

    <transition name="reduce_pair_in_reduction" priority="1">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <in name="vol" type="volume_in_progress"/>
        <out name="pair" type="pair_to_reduce"/>
        <out name="credit_reduce_pair" type="control"/>
        <expression>
          ${pair.sum} := ${sum};
          ${pair.vol} := ${vol.volume};
          ${credit_reduce_pair} := []
        </expression>
        <condition>
          ${sum.volume.volume} :eq: ${vol.volume.volume}
        </condition>
      </defun>
      <connect-in port="vol" place="volume_in_progress"/>
      <connect-in port="sum" place="pre_reduce_pair_in_reduction"/>
      <connect-out port="pair" place="pair_to_reduce"/>
      <connect-out port="credit_reduce_pair" place="credit_reduce_pair"/>
    </transition>

    <transition name="no_reduce_pair_in_progress">
      <defun>
        <in name="vol" type="volume_in_progress"/>
        <out name="vol" type="volume_in_progress"/>
        <out name="credit_reduce_pair" type="control"/>
        <expression>
          ${credit_reduce_pair} := []
        </expression>
      </defun>
      <connect-in port="vol" place="pre_reduce_pair_in_progress"/>
      <connect-out port="vol" place="volume_in_progress_pre"/>
      <connect-out port="credit_reduce_pair" place="credit_reduce_pair"/>
    </transition>

    <transition name="no_reduce_pair_in_reduction">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <out name="sum" type="volume_in_reduction"/>
        <out name="credit_reduce_pair" type="control"/>
        <expression>
          ${credit_reduce_pair} := []
        </expression>
      </defun>
      <connect-in port="sum" place="pre_reduce_pair_in_reduction"/>
      <connect-out port="sum" place="volume_in_reduction"/>
      <connect-out port="credit_reduce_pair" place="credit_reduce_pair"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="pair_to_reduce" type="pair_to_reduce"/>

    <transition name="reduce">
      <defun>
        <in name="config" type="config"/>
        <in name="pair" type="pair_to_reduce"/>
        <out name="pair" type="pair_to_reduce"/>
        <module name="kdmfull" function="reduce (pair)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="pair" place="pair_to_reduce"/>
      <connect-out port="pair" place="pair_reduced"/>
    </transition>

    <place name="pair_reduced" type="pair_to_reduce"/>

    <transition name="reduce_unpair">
      <defun>
        <in name="pair" type="pair_to_reduce"/>
        <in name="credit_volume_check_reduce_done" type="control"/>
        <out name="sum" type="volume_in_reduction"/>
        <out name="volume" type="volume_with_store"/>
        <expression>
          ${sum} := ${pair.sum};
          ${sum.left} := ${sum.left} - 1L;
          ${volume} := ${pair.vol}
        </expression>
      </defun>
      <connect-in port="pair" place="pair_reduced"/>
      <connect-in port="credit_volume_check_reduce_done" place="credit_volume_check_reduce_done"/>
      <connect-out port="sum" place="volume_check_reduce_done"/>
      <connect-out port="volume" place="volume_written"/>
    </transition>

    <place name="volume_check_reduce_done" type="volume_in_reduction"/>
    <place name="credit_volume_check_reduce_done" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="reduce_done">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <out name="volume" type="volume_with_store"/>
        <out name="credit_volume_check_reduce_done" type="control"/>
        <expression>
          ${volume} := ${sum.volume};
          ${credit_volume_check_reduce_done} := []
        </expression>
        <condition>
          ${sum.left} :le: 0L
        </condition>
      </defun>
      <connect-in port="sum" place="volume_check_reduce_done"/>
      <connect-out port="volume" place="volume_to_be_written"/>
      <connect-out port="credit_volume_check_reduce_done" place="credit_volume_check_reduce_done"/>
    </transition>

    <transition name="reduce_not_done">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <out name="sum" type="volume_in_reduction"/>
        <out name="credit_volume_check_reduce_done" type="control"/>
        <in name="credit_reduce_pair" type="control"/>
        <expression>
          ${credit_volume_check_reduce_done} := []
        </expression>
        <condition>
          ${sum.left} :gt: 0L
        </condition>
      </defun>
      <connect-in port="sum" place="volume_check_reduce_done"/>
      <connect-out port="sum" place="pre_reduce_pair_in_reduction"/>
      <connect-out port="credit_volume_check_reduce_done" place="credit_volume_check_reduce_done"/>
      <connect-in port="credit_reduce_pair" place="credit_reduce_pair"/>
    </transition>

    <place name="volume_to_be_written" type="volume_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="write">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_with_store"/>
        <out name="volume" type="volume_with_store"/>
        <module name="kdmfull" function="write (config, volume)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_to_be_written"/>
      <connect-out port="volume" place="volume_written"/>
    </transition>

    <place name="volume_written" type="volume_with_store"/>

    <transition name="post_write">
      <defun>
        <in name="volume_written" type="volume_with_store"/>
        <out name="volume" type="volume"/>
        <out name="store" type="store_volume"/>
        <expression>
          ${volume} := ${volume_written.volume};
          ${store} := ${volume_written.store}
        </expression>
      </defun>
      <connect-in port="volume_written" place="volume_written"/>
      <connect-out port="volume" place="volume_to_be_finalized"/>
      <connect-out port="store" place="store_volume"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="volume_to_be_finalized" type="volume"/>

    <include-template href="wait.xml"/>
    <specialize name="wait_volume" use="wait">
      <type-map replace="T" with="volume"/>
    </specialize>

    <transition name="wait_volume">
      <use name="wait_volume"/>
      <place-map virtual="wait" real="volumes_left"/>
      <connect-in port="trigger" place="volume_to_be_finalized"/>
      <connect-out port="done" place="volumes_done"/>
    </transition>

    <place name="volumes_done" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="eat_store" inline="true">
      <include-function href="eat/store.xml"/>
      <place-map virtual="store_bunch" real="store_bunch"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <connect-in port="number_store_volume" place="number_store_volume"/>
      <connect-in port="number_store_bunch" place="number_store_bunch"/>
      <connect-in port="trigger" place="volumes_done"/>
      <connect-out port="done" place="done_eat_store"/>
    </transition>

    <place name="done_eat_store" type="control"/>

    <transition name="cleanup">
      <defun>
        <in name="config" type="config"/>
        <in name="assoc" type="map"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="config" place="config_process"/>
      <connect-in port="assoc" place="bunch_store_assoc_offset"/>
      <connect-in port="trigger" place="done_eat_store"/>
      <connect-out port="trigger" place="done_cleanup"/>
    </transition>

    <place name="done_cleanup" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="finalize">
      <defun>
        <in name="config" type="config"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <module name="kdmfull" function="finalize (config)"/>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-in port="trigger" place="done_cleanup"/>
      <connect-out port="trigger" place="done"/>
   </transition>
  </net>
</defun>
