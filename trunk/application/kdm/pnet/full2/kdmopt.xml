<defun name="kdm">

  <include-structs href="types.xml"/>

  <in name="file_config" type="string" place="file_config"/>
  <in name="file_param" type="string" place="file_param"/>
  <in name="memsizeGPI" type="long" place="memsizeGPI"/>

  <out name="done" type="control" place="done"/>

  <net>

    <properties name="pnetc">
      <properties name="context">
        <property key="file">
"/p/herc/itwm/hpc/soft/sdpa/kdm/Kirchhoff_TestKDMDaniel_new_fineTT_fineSL"
        </property>
      </properties>
    </properties>

    <place name="file_config" type="string">
      <token><value>${file} + ".xml"</value></token>
    </place>

    <place name="file_param" type="string">
      <token><value>${file} + ".param.text"</value></token>
    </place>

    <place name="memsizeGPI" type="long">
      <token>
        <value>
          5*2^30
        </value>
      </token>
    </place>

    <place name="done" type="control"/>
    <place name="config_initialized" type="config"/>

    <place name="store_bunch" type="store_bunch"/>
    <place name="store_volume" type="store_volume"/>

    <place name="bunch_store_assoc_offset" type="map"/>

    <place name="volumes_left" type="long"/>

    <!-- ****************************************************************** -->

    <transition name="init_config" inline="true">
      <include-function href="init/config.xml"/>
      <connect-in port="file_config" place="file_config"/>
      <connect-in port="file_param" place="file_param"/>
      <connect-in port="memsizeGPI" place="memsizeGPI"/>
      <connect-out port="config" place="config_initialized"/>
      <connect-out port="assoc" place="bunch_store_assoc_offset"/>
      <connect-out port="volumes_left" place="volumes_left"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="config_generate_store" type="config"/>
    <place name="config_generate_item" type="config"/>
    <place name="config_loadTT" type="config"/>
    <place name="config" type="config"/>

    <include-template href="4.xml"/>
    <specialize name="dist_config" use="quad">
      <type-map replace="T" with="config"/>
    </specialize>

    <transition name="dist_config" inline="true">
      <use name="dist_config"/>
      <connect-in port="in" place="config_initialized"/>
      <connect-out port="one" place="config"/>
      <connect-out port="two" place="config_generate_store"/>
      <connect-out port="three" place="config_generate_item"/>
      <connect-out port="four" place="config_loadTT"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="loadTT" inline="true">
      <include-function href="loadTT.xml"/>
      <connect-in port="config" place="config_loadTT"/>
      <connect-out port="config" place="config_process"/>
    </transition>

    <place name="config_process" type="config"/>

    <!-- ****************************************************************** -->

    <transition name="generate_store" inline="true">
      <include-function href="generate/store.xml"/>
      <connect-in port="config" place="config_generate_store"/>
      <connect-out port="store_bunch" place="store_bunch"/>
      <connect-out port="store_volume" place="store_volume"/>
      <connect-out port="number_store_volume" place="number_store_volume"/>
      <connect-out port="number_store_bunch" place="number_store_bunch"/>
    </transition>

    <place name="number_store_volume" type="long"/>
    <place name="number_store_bunch" type="long"/>

    <transition name="generate_item" inline="true">
      <include-function href="generate/item.xml"/>
      <place-map virtual="store_bunch" real="store_bunch"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <place-map virtual="assoc" real="bunch_store_assoc_offset"/>
      <connect-in port="config" place="config_generate_item"/>
      <connect-out port="volume_state" place="volume_state"/>
      <connect-out port="volume_with_store" place="volume_with_store"/>
      <connect-out port="bunch_with_store" place="bunch_with_store"/>
    </transition>

    <place name="volume_state" type="volume_state"/>
    <place name="volume_with_store" type="volume_with_store"/>
    <place name="bunch_with_store" type="bunch_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="load_bunch" inline="true">
      <include-function href="load/bunch.xml"/>
      <connect-read port="config" place="config"/>
      <connect-in port="bunch_with_store" place="bunch_with_store"/>
      <connect-out port="bunch_loaded" place="pre_bunch_loaded"/>
    </transition>

    <place name="bunch_loaded" type="bunch_loaded"/>
    <place name="pre_bunch_loaded" type="bunch_loaded"/>

    <transition name="take_bunch_loaded_for_assign">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <in name="credit" type="control"/>
        <expression>
        </expression>
      </defun>
      <connect-in port="bunch" place="pre_bunch_loaded"/>
      <connect-out port="bunch" place="pre_assign_bunch_loaded"/>
      <connect-in port="credit" place="credit_assign"/>
    </transition>


    <!-- ****************************************************************** -->

    <transition name="initialize_volume" inline="true">
      <include-function href="init/volume.xml"/>
      <connect-read port="config" place="config"/>
      <connect-in port="volume_with_store" place="volume_with_store"/>
      <connect-out port="volume_in_progress" place="pre_volume_in_progress"/>
    </transition>

    <place name="volume_in_progress" type="volume_in_progress"/>
    <place name="pre_volume_in_progress" type="volume_in_progress"/>

    <transition name="take_volume_in_progress_for_assign">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <in name="credit" type="control"/>
        <expression>
        </expression>
      </defun>
      <connect-in port="volume" place="pre_volume_in_progress"/>
      <connect-out port="volume" place="pre_assign_volume_in_progress"/>
      <connect-in port="credit" place="credit_assign"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="credit_assign" type="control">
      <token><value>[]</value></token>
    </place>

    <place name="pre_assign_bunch_loaded" type="bunch_loaded"/>
    <place name="pre_assign_volume_in_progress" type="volume_in_progress"/>

    <transition name="assign_bunch_loaded" priority="1">
      <defun>

        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <out name="credit_assign" type="control"/>

        <expression>
          ${volume.assigned.bunch.id} := ${bunch.bunch.bunch.id};
          ${volume.assigned.store.id} := ${bunch.bunch.store.id};

          ${bunch.bunch.volumes.seen.id}
            := bitset_insert ( ${bunch.bunch.volumes.seen.id}
                             , ${volume.volume.volume.id}
                             );

          ${credit_assign} := [];
        </expression>

        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          !bitset_is_element (${bunch.bunch.volumes.seen.id}, ${volume.volume.volume.id})
        </condition>
      </defun>

      <connect-in port="bunch" place="pre_assign_bunch_loaded"/>
      <connect-out port="bunch" place="pre_bunch_loaded"/>

      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>

      <connect-out port="credit_assign" place="credit_assign"/>
    </transition>

    <transition name="assign_volume_in_progress" priority="1">
      <defun>

        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <out name="credit_assign" type="control"/>

        <expression>
          ${volume.assigned.bunch.id} := ${bunch.bunch.bunch.id};
          ${volume.assigned.store.id} := ${bunch.bunch.store.id};

          ${bunch.bunch.volumes.seen.id}
            := bitset_insert ( ${bunch.bunch.volumes.seen.id}
                             , ${volume.volume.volume.id}
                             );

          ${credit_assign} := [];
        </expression>

        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          !bitset_is_element (${bunch.bunch.volumes.seen.id}, ${volume.volume.volume.id})
        </condition>
      </defun>

      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="bunch" place="pre_bunch_loaded"/>

      <connect-in port="volume" place="pre_assign_volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>

      <connect-out port="credit_assign" place="credit_assign"/>
    </transition>

    <transition name="no_assign_bunch_loaded">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <out name="credit_assign" type="control"/>
        <expression>
          ${credit_assign} := [];
        </expression>
      </defun>
      <connect-in port="bunch" place="pre_assign_bunch_loaded"/>
      <connect-out port="bunch" place="wait_check_bunch_done"/>
      <connect-out port="credit_assign" place="credit_assign"/>
    </transition>

    <place name="wait_check_bunch_done" type="bunch_loaded"/>

    <transition name="start_check_bunch_done">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <expression>
        </expression>
      </defun>
      <connect-in port="bunch" place="wait_check_bunch_done"/>
      <connect-out port="bunch" place="check_bunch_done"/>
    </transition>

    <place name="check_bunch_done" type="bunch_loaded" capacity="1"/>

    <transition name="no_assign_volume_in_progress">
      <defun>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <out name="credit_assign" type="control"/>
        <expression>
          ${credit_assign} := [];
        </expression>
      </defun>
      <connect-in port="volume" place="pre_assign_volume_in_progress"/>
      <connect-out port="volume" place="volume_in_progress"/>
      <connect-out port="credit_assign" place="credit_assign"/>
    </transition>

    <place name="volume_to_process" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="process">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <module name="kdmfull2" function="process (config, volume)"/>
      </defun>
      <connect-read port="config" place="config_process"/>
      <connect-in port="volume" place="volume_to_process"/>
      <connect-out port="volume" place="volume_processed"/>
    </transition>

    <place name="volume_processed" type="volume_in_progress"/>

    <include-template href="dup.xml"/>
    <specialize name="dup_volume_in_progress" use="dup">
      <type-map replace="T" with="volume_in_progress"/>
    </specialize>

    <place name="update_bunch_state" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="update_volume_state">
      <defun>
        <in name="processed" type="volume_in_progress"/>
        <out name="processed" type="volume_in_progress"/>
        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>
        <expression>
          ${state.bunches.left} := ${state.bunches.left} - 1L;
        </expression>
        <condition>${state.volume} :eq: ${processed.volume.volume}</condition>
      </defun>
      <connect-in port="processed" place="volume_processed"/>
      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="check_volume_done"/>
      <connect-out port="processed" place="wait_update_bunch_state"/>
    </transition>

    <place name="wait_update_bunch_state" type="volume_in_progress" capacity="1"/>
    <place name="check_volume_done" type="volume_state" capacity="1"/>

    <!-- ****************************************************************** -->

    <transition name="unassign">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <expression>
          ${bunch.wait} := ${bunch.wait} - 1;

          ${volume.assigned.bunch.id} := -1L;
          ${volume.assigned.store.id} := -1L;
        </expression>
        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          ${bunch.bunch.bunch.id} :eq: ${volume.assigned.bunch.id}
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="bunch" place="pre_bunch_loaded"/>
      <connect-in port="volume" place="update_bunch_state"/>
      <connect-out port="volume" place="pre_volume_in_progress"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="bunch_done">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="store" type="store_bunch"/>
        <expression>
          ${store} := ${bunch.bunch.store}
        </expression>
        <condition>
          ${bunch.wait} :le: 0
        </condition>
      </defun>
      <connect-in port="bunch" place="check_bunch_done"/>
      <connect-out port="store" place="store_bunch"/>
    </transition>

    <transition name="not_bunch_done">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <expression>
          ${store} := ${bunch.bunch.store}
        </expression>
        <condition>
          ${bunch.wait} :gt: 0
        </condition>
      </defun>
      <connect-in port="bunch" place="check_bunch_done"/>
      <connect-out port="bunch" place="bunch_loaded"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="volume_done">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="processed" type="volume_in_progress"/>
        <out name="processed" type="volume_in_progress"/>
        <out name="state" type="volume_state"/>
        <expression>
        </expression>
        <condition>
          ${state.bunches.left} :le: 0
        </condition>
      </defun>
      <connect-in port="state" place="check_volume_done"/>
      <connect-out port="state" place="volume_done"/>
      <connect-in port="processed" place="wait_update_bunch_state"/>
      <connect-out port="processed" place="update_bunch_state"/>
    </transition>

    <transition name="not_volume_done">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="processed" type="volume_in_progress"/>
        <out name="processed" type="volume_in_progress"/>
        <out name="state" type="volume_state"/>
        <expression>
        </expression>
        <condition>
          ${state.bunches.left} :gt: 0
        </condition>
      </defun>
      <connect-in port="state" place="check_volume_done"/>
      <connect-out port="state" place="volume_state"/>
      <connect-in port="processed" place="wait_update_bunch_state"/>
      <connect-out port="processed" place="update_bunch_state"/>
    </transition>

    <place name="volume_done" type="volume_state"/>

    <transition name="reduce_start">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="sum" type="volume_in_reduction"/>
        <expression>
          ${sum.volume} := ${volume.volume};
          ${sum.left} := ${state.copies} - 1;
        </expression>
        <condition>
          ${state.volume} :eq: ${volume.volume.volume}
        </condition>
      </defun>
      <connect-in port="state" place="volume_done"/>
      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="sum" place="volume_in_reduction"/>
    </transition>

    <place name="volume_in_reduction" type="volume_in_reduction"/>

    <transition name="reduce_pair">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <in name="vol" type="volume_in_progress"/>
        <out name="pair" type="pair_to_reduce"/>
        <expression>
          ${pair.sum} := ${sum};
          ${pair.vol} := ${vol.volume}
        </expression>
        <condition>
          ${sum.volume.volume} :eq: ${vol.volume.volume}
        </condition>
      </defun>
      <connect-in port="vol" place="volume_in_progress"/>
      <connect-in port="sum" place="volume_in_reduction"/>
      <connect-out port="pair" place="pair_to_reduce"/>
    </transition>

    <place name="pair_to_reduce" type="pair_to_reduce"/>

    <transition name="reduce">
      <defun>
        <in name="config" type="config"/>
        <in name="pair" type="pair_to_reduce"/>
        <out name="pair" type="pair_to_reduce"/>
        <module name="kdmfull2" function="reduce (pair)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="pair" place="pair_to_reduce"/>
      <connect-out port="pair" place="pair_reduced"/>
    </transition>

    <place name="pair_reduced" type="pair_to_reduce"/>

    <transition name="reduce_unpair">
      <defun>
        <in name="pair" type="pair_to_reduce"/>
        <out name="sum" type="volume_in_reduction"/>
        <out name="volume" type="volume_with_store"/>
        <expression>
          ${sum} := ${pair.sum};
          ${sum.left} := ${sum.left} - 1L;
          ${volume} := ${pair.vol}
        </expression>
      </defun>
      <connect-in port="pair" place="pair_reduced"/>
      <connect-out port="sum" place="volume_in_reduction"/>
      <connect-out port="volume" place="volume_written"/>
    </transition>

    <transition name="reduce_done">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <out name="volume" type="volume_with_store"/>
        <expression>
          ${volume} := ${sum.volume}
        </expression>
        <condition>
          ${sum.left} :le: 0L
        </condition>
      </defun>
      <connect-in port="sum" place="volume_in_reduction"/>
      <connect-out port="volume" place="volume_to_be_written"/>
    </transition>

    <place name="volume_to_be_written" type="volume_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="write">
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_with_store"/>
        <out name="volume" type="volume_with_store"/>
        <module name="kdmfull2" function="write (config, volume)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_to_be_written"/>
      <connect-out port="volume" place="volume_written"/>
    </transition>

    <place name="volume_written" type="volume_with_store"/>

    <transition name="post_write">
      <defun>
        <in name="volume_written" type="volume_with_store"/>
        <out name="volume" type="volume"/>
        <out name="store" type="store_volume"/>
        <expression>
          ${volume} := ${volume_written.volume};
          ${store} := ${volume_written.store}
        </expression>
      </defun>
      <connect-in port="volume_written" place="volume_written"/>
      <connect-out port="volume" place="volume_to_be_finalized"/>
      <connect-out port="store" place="store_volume"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="volume_to_be_finalized" type="volume"/>

    <include-template href="wait.xml"/>
    <specialize name="wait_volume" use="wait">
      <type-map replace="T" with="volume"/>
    </specialize>

    <transition name="wait_volume">
      <use name="wait_volume"/>
      <place-map virtual="wait" real="volumes_left"/>
      <connect-in port="trigger" place="volume_to_be_finalized"/>
      <connect-out port="done" place="volumes_done"/>
    </transition>

    <place name="volumes_done" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="eat_store" inline="true">
      <include-function href="eat/store.xml"/>
      <place-map virtual="store_bunch" real="store_bunch"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <connect-in port="number_store_volume" place="number_store_volume"/>
      <connect-in port="number_store_bunch" place="number_store_bunch"/>
      <connect-in port="trigger" place="volumes_done"/>
      <connect-out port="done" place="done_eat_store"/>
    </transition>

    <place name="done_eat_store" type="control"/>

    <transition name="cleanup">
      <defun>
        <in name="config" type="config"/>
        <in name="assoc" type="map"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="config" place="config_process"/>
      <connect-in port="assoc" place="bunch_store_assoc_offset"/>
      <connect-in port="trigger" place="done_eat_store"/>
      <connect-out port="trigger" place="done_cleanup"/>
    </transition>

    <place name="done_cleanup" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="finalize">
      <defun>
        <in name="config" type="config"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <module name="kdmfull2" function="finalize (config)"/>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-in port="trigger" place="done_cleanup"/>
      <connect-out port="trigger" place="done"/>
   </transition>
  </net>
</defun>
