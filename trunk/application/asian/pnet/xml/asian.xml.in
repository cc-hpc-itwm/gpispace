<defun name="asian">

  <struct name="param">
    <field name="S" type="double"/>
    <field name="K" type="double"/>
    <field name="T" type="double"/>
    <field name="sigma" type="double"/>
    <field name="r" type="double"/>
    <field name="d" type="double"/>

    <field name="FirstFixing" type="long"/>
    <field name="FixingsProJahr" type="double"/>
    <field name="AnzahlderDividende" type="long"/>
    <field name="n" type="long"/>

    <field name="rowID" type="long"/>
    <field name="bin" type="string"/>

    <field name="epsilon" type="double"/>
    <field name="delta" type="double"/>

    <field name="iterations_per_run" type="long"/>
  </struct>

  <struct name="sums">
    <field name="sum1" type="double"/>
    <field name="sum2" type="double"/>
    <field name="param" type="param"/>
  </struct>

  <struct name="result">
    <field name="pv" type="double"/>
    <field name="stddev" type="double"/>
    <field name="Delta" type="double"/>
    <field name="Gamma" type="double"/>
    <field name="Vega" type="double"/>
    <field name="rowID" type="long"/>
  </struct>

  <in name="param" type="param" place="param"/>

  <out name="result" type="result" place="result"/>

  <net>

    <place name="param" type="param">
      <token>
        <field name="S"><value>7000.0</value></field>
        <field name="K"><value>85.0</value></field>
        <field name="T"><value>1.02</value></field>
        <field name="sigma"><value>0.2</value></field>
        <field name="r"><value>0.05</value></field>
        <field name="d"><value>0.0</value></field>
        <field name="FirstFixing"><value>1</value></field>
        <field name="FixingsProJahr"><value>50.0</value></field>
        <field name="AnzahlderDividende"><value>3</value></field>
        <field name="n"><value>100000</value></field>

        <field name="rowID"><value>0</value></field>
        <field name="bin"><value>"@BUILD@/application/asian/Asian"</value></field>

        <field name="epsilon"><value>0.01</value></field>
        <field name="delta"><value>0.01</value></field>

        <field name="iterations_per_run"><value>100000 div 2</value></field>
      </token>
    </place>

    <place name="param_eps1" type="param"/>
    <place name="param_eps2" type="param"/>
    <place name="param_delta" type="param"/>

    <place name="id" type="param"/>
    <place name="eps1" type="param"/>
    <place name="eps2" type="param"/>
    <place name="delta" type="param"/>

    <transition name="id">
      <defun>
        <in name="param" type="param"/>
        <out name="param" type="param"/>
        <out name="div" type="param"/>
        <expression>
          ${div} := ${param};
        </expression>
      </defun>
      <connect-in port="param" place="param"/>
      <connect-out port="param" place="param_eps1"/>
      <connect-out port="div" place="id"/>
    </transition>

    <transition name="eps1">
      <defun>
        <in name="param" type="param"/>
        <out name="param" type="param"/>
        <out name="div" type="param"/>
        <expression>
          ${div} := ${param};
          ${div.S} := ${div.S} * (1.0 + ${div.epsilon});
        </expression>
      </defun>
      <connect-in port="param" place="param_eps1"/>
      <connect-out port="param" place="param_eps2"/>
      <connect-out port="div" place="eps1"/>
    </transition>

    <transition name="eps2">
      <defun>
        <in name="param" type="param"/>
        <out name="param" type="param"/>
        <out name="div" type="param"/>
        <expression>
          ${div} := ${param};
          ${div.S} := ${div.S} * (1.0 + 2.0 * ${div.epsilon});
        </expression>
      </defun>
      <connect-in port="param" place="param_eps2"/>
      <connect-out port="param" place="param_delta"/>
      <connect-out port="div" place="eps2"/>
    </transition>

    <transition name="delta">
      <defun>
        <in name="param" type="param"/>
        <out name="div" type="param"/>
        <expression>
          ${div} := ${param};
          ${div.sigma} := ${div.sigma} * (1.0 + ${div.delta});
        </expression>
      </defun>
      <connect-in port="param" place="param_delta"/>
      <connect-out port="div" place="delta"/>
    </transition>

    <defun name="asian">
      <in name="param" type="param"/>
      <out name="sums" type="sums"/>
      <module name="asian" function="sums run (param)">
        <cinclude href="sstream"/>
        <cinclude href="process.hpp"/>
        <link href="@BUILD@/application/example/exec/libprocess.so"/>
        <code><![CDATA[
          std::ostringstream str;

          str << "S = " << param.S << std::endl;
          str << "K = " << param.K << std::endl;
          str << "T = " << param.T << std::endl;
          str << "sigma = " << param.sigma << std::endl;
          str << "r = " << param.r << std::endl;
          str << "d = " << param.d << std::endl;
          str << "FirstFixing = " << param.FirstFixing << std::endl;
          str << "FixingsProJahr = " << param.FixingsProJahr << std::endl;
          str << "AnzahlderDividende = " << param.AnzahlderDividende << std::endl;
          str << "n = " << param.n << std::endl;

          const std::size_t s (str.str().size());

          char result[1024];

          const std::size_t written
            ( process::execute ( param.bin
                               , str.str().c_str()
                               , s
                               , result
                               , 1024
                               )
            );

          ::pnetc::type::sums::sums sums;

          std::istringstream is (std::string (result, written));
          std::string dummy;

          is >> dummy;
          is >> dummy;
          is >> sums.sum1;
          is >> dummy;
          is >> dummy;
          is >> sums.sum2;

          sums.param = param;

          return sums;
        ]]></code>
      </module>
    </defun>

    <transition name="asian_id">
      <use name="asian"/>
      <connect-in port="param" place="id"/>
      <connect-out port="sums" place="sums_id"/>
    </transition>

    <transition name="asian_eps1">
      <use name="asian"/>
      <connect-in port="param" place="eps1"/>
      <connect-out port="sums" place="sums_eps1"/>
    </transition>

    <transition name="asian_eps2">
      <use name="asian"/>
      <connect-in port="param" place="eps2"/>
      <connect-out port="sums" place="sums_eps2"/>
    </transition>

    <transition name="asian_delta">
      <use name="asian"/>
      <connect-in port="param" place="delta"/>
      <connect-out port="sums" place="sums_delta"/>
    </transition>
<!--

    <transition name="asian_id" inline="true">
      <include-function href="run.xml"/>
      <connect-in port="param" place="id"/>
      <connect-out port="sums" place="sums_id"/>
    </transition>

    <transition name="asian_eps1" inline="true">
      <include-function href="run.xml"/>
      <connect-in port="param" place="eps1"/>
      <connect-out port="sums" place="sums_eps1"/>
    </transition>

    <transition name="asian_eps2" inline="true">
      <include-function href="run.xml"/>
      <connect-in port="param" place="eps2"/>
      <connect-out port="sums" place="sums_eps2"/>
    </transition>

    <transition name="asian_delta" inline="true">
      <include-function href="run.xml"/>
      <connect-in port="param" place="delta"/>
      <connect-out port="sums" place="sums_delta"/>
    </transition>
-->

    <place name="sums_id" type="sums"/>
    <place name="sums_eps1" type="sums"/>
    <place name="sums_eps2" type="sums"/>
    <place name="sums_delta" type="sums"/>

    <transition name="collect">
      <defun>
        <in name="sums_id" type="sums"/>
        <in name="sums_eps1" type="sums"/>
        <in name="sums_eps2" type="sums"/>
        <in name="sums_delta" type="sums"/>
        <out name="result" type="result"/>
        <expression>
          ${r} := ${sums_id.param.r};
          ${T} := ${sums_id.param.T};
          ${n} := double(${sums_id.param.n});
          ${epsilon} := ${sums_id.param.epsilon};
          ${delta} := ${sums_id.param.delta};

          ${pv_id} := e ** (-${r}) * ${T} * ${sums_id.sum1} / ${n};
          ${pv_eps1} := e ** (-${r}) * ${T} * ${sums_eps1.sum1} / ${n};
          ${pv_eps2} := e ** (-${r}) * ${T} * ${sums_eps2.sum1} / ${n};
          ${pv_delta} := e ** (-${r}) * ${T} * ${sums_delta.sum1} / ${n};

          ${stddev_id} := (${sums_id.sum2} - ${sums_id.sum1} * ${sums_id.sum1} / ${n}) / ${n};
          ${stddev_eps1} := (${sums_eps1.sum2} - ${sums_eps1.sum1} * ${sums_eps1.sum1} / ${n}) / ${n};
          ${stddev_eps2} := (${sums_eps2.sum2} - ${sums_eps2.sum1} * ${sums_eps2.sum1} / ${n}) / ${n};
          ${stddev_delta} := (${sums_delta.sum2} - ${sums_delta.sum1} * ${sums_delta.sum1} / ${n}) / ${n};

          ${result.pv} := ${pv_id};
          ${result.stddev} := ${stddev_id};
          ${result.Delta} := (${pv_eps1} - ${pv_id}) / ${epsilon};
          ${result.Gamma} := (${pv_eps2} - 2.0 * ${pv_eps1} + ${pv_id}) / (${epsilon} * ${epsilon});
          ${result.Vega} := (${pv_delta} - ${pv_id}) / ${delta};
          ${result.rowID} := ${sums_id.param.rowID};
        </expression>
        <condition>
          ${sums_id.param.rowID} :eq: ${sums_eps1.param.rowID}
        </condition>
        <condition>
          ${sums_id.param.rowID} :eq: ${sums_eps2.param.rowID}
        </condition>
        <condition>
          ${sums_id.param.rowID} :eq: ${sums_delta.param.rowID}
        </condition>
      </defun>
      <connect-in port="sums_id" place="sums_id"/>
      <connect-in port="sums_eps1" place="sums_eps1"/>
      <connect-in port="sums_eps2" place="sums_eps2"/>
      <connect-in port="sums_delta" place="sums_delta"/>
      <connect-out port="result" place="result"/>
    </transition>

    <place name="result" type="result"/>
  </net>

</defun>
