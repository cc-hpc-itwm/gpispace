#!/bin/sh
#
# a small tool to test the whole SDPA installation for functionality
#

mydir=$( cd $( dirname $( which $0 ) ) && pwd  )

# please set these variables to "meaningful" values on your system
sdpa_gpi="@GPI_BINARY_DIR@/sdpa-gpi"
pcd_cfg="${mydir}/../etc/fvm.cfg"
libexec="${mydir}/../libexec"
logfile=sdpa-selftest.log

# these values should already be ok (just make sure PATH is correctly set)
orch="orchestrator"
agg="aggregator"
nre="nre"
pcd="nre-pcd"
pnetc="pnetc"
sdpac="sdpac"
jobdesc="selftest.pnet"

# error codes:
ESUC=0
EERR=1
EGPI=4
EORCH=5
EAGG=6
ENRE=7
EPCD=8
ESUB=9

function log()
{
    echo "$*" >&2
    echo "$*" >> ${logfile}
}

function is_alive ()
{
    name=$1
    pid=$2
    kill -0 $pid >/dev/null 2>&1
    if [ $? -eq 0 ]; then
	return 0
    else
	return 1
    fi
}

function shutdown()
{
  log "shutting everything down..."
  for pid in `jobs -p` ; do
	log "shutting down $pid..."
	kill -TERM $pid >/dev/null 2>&1
	sleep 1
	if is_alive $pid $pid ; then
	  log "killing $pid..."
	  kill -KILL $pid >/dev/null 2>&1
    fi
  done
  log "waiting for background processes..."
  wait
}


trap shutdown EXIT

:> ${logfile}

sdpa_gpi_tmp=$( which ${sdpa_gpi} )
if [ x"$sdpa_gpi" != x"$sdpa_gpi_tmp" ] ; then
  log "Please make sure, that you specify the full path to the sdpa-gpi binary!"
  log "Currently set to: ${sdpa_gpi}"
  log "output of 'which $sdpa_gpi': $sdpa_gpi_tmp"
  exit ${EERR}
fi

log "initializing selftest..."
log "starting sdpa-gpi..."
${sdpa_gpi} >> ${logfile} 2>&1 &
sdpa_gpi_pid=$!
sleep 2
if ! is_alive "sdpa_gpi" $sdpa_gpi_pid ; then
    log "E: SDPA-GPI interface could not be started!"
    exit ${EGPI}
else
	log "OK"
fi

log "starting orchestrator..."
${orch} >> ${logfile} 2>&1 &
orch_pid=$!
sleep 1
if ! is_alive "orchestrator" $orch_pid ; then
	log "E: Orchestrator could not be started!"
	exit ${EORCH}
else
	log "OK"
fi

log "starting aggregator..."
${agg} >> ${logfile} 2>&1 &
agg_pid=$!
sleep 1
if ! is_alive "aggregator" $agg_pid ; then
	log "E: Aggregator could not be started!"
	exit ${EAGG}
else
	log "OK"
fi

log "reading PCD config from $pcd_cfg..."
while read k v; do
    case "$k" in
        SHMSZ)
            log "using shmsz $v"
            export FVM_PC_SHMSZ="$v"
            ;;
        FVMSZ)
            log "using fvmsz $v"
            export FVM_PC_FVMSZ="$v"
            ;;
        MSQFILE)
            log "using msq $v"
            export FVM_PC_MSQ="$v"
            ;;
        SHMFILE)
            log "using shm $v"
            export FVM_PC_SHM="$v"
            ;;
    esac
done < "$pcd_cfg"

log "starting process-container..."
${pcd} --rank "0" --load "${libexec}/libfvm-pc.so" -a "${libexec}" >> ${logfile} 2>&1 &
pcd_pid=$!
sleep 1
if ! is_alive "pcd" $pcd_pid ; then
	log "E: PCD could not be started!"
	exit ${EPCD}
else
	log "OK"
fi

log "starting nre..."
${nre} >> ${logfile} 2>&1 &
nre_pid=$!
sleep 1
if ! is_alive "nre" $nre_pid ; then
	log "E: NRE could not be started!"
	exit ${ENRE}
else
	log "OK"
fi
log "submitting job ${jobdesc}..."
jobid=$( ${sdpac} submit ${jobdesc} 2>&1 )
if [ $? -ne 0 ] ; then
  log "Could not submit job: $jobid"
  exit ${ESUB}
fi
log "JOB-ID := $jobid"

MAX=15
S=
for (( i=0; i < $MAX; i++ )) ; do
  S=$( ${sdpac} status ${jobid} )
  log "status: $S"
  if echo $S | grep -q -i 'finish' ; then
	break
  fi
  sleep 1
done
if echo $S | grep -q -i 'finish' ; then
  log "Congratulations, everything seems to work!"
  exit ${ESUC}
else
  log "Submitted job did not return within $MAX seconds!"
  exit ${ESUB}
fi
