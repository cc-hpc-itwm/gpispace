<?xml version="1.0" encoding="UTF-8"?>
<defun name="f_generate_sequence">
	<in name="amount" type="LONG" place="amount" />
	<out name="out" type="LONG" place="out" />
	<net>
<!-- not here for the moment, as this is parsed twice
		<struct name="COUNTER">
			<field name="i" type="long"/>
			<field name="max" type="long"/>
		</struct>
-->

		<place name="amount" type="LONG" />
		<place name="out" type="LONG" />

		<defun name="f_init">
			<in name="N" type="LONG" />
			<out name="counter" type="COUNTER" />
			<expression>
				${counter.i} := 0L;
				${counter.max} := ${N};
			</expression>
		</defun>

		<place name="counter" type="COUNTER" />
		<transition name="init" use="f_init">
			<connect-in place="amount" port="N" />
			<connect-out port="counter" place="counter" />
		</transition>

		<!-- just consume a token -->
		<defun name="f_break">
			<in name="in" type="COUNTER" />
			<expression>
			</expression>
			<condition>${counter.i} &gt;= ${counter.max}</condition>
		</defun>

		<transition name="break" use="f_break">
			<connect-in place="counter" port="state" />
		</transition>

		<defun name="f_step">
			<in name="counter" type="COUNTER" />
			<out name="counter" type="COUNTER" />
			<out name="out" type="LONG" />
			<expression>
				${out} := ${counter.i};
				${counter.i} := ${counter.i} + 1;
			</expression>
			<condition>${counter.i} &lt; ${counter.max}</condition>
		</defun>

		<transition name="step" use="f_step">
			<connect-in place="counter" port="counter" />
			<connect-out place="counter" port="counter" />
			<connect-out place="out" port="out" />
		</transition>

	</net>
</defun>