<defun>

  <in name="config" type="config" place="config"/>
  <out name="volume_state" type="volume_state" place="volume_state"/>
  <out name="volume_with_store" type="volume_with_store" place="volume_with_store"/>
  <out name="bunch_with_store" type="bunch_with_store" place="bunch_with_store"/>
  <tunnel name="assoc" type="map" place="assoc"/>
  <tunnel name="store_bunch_put" type="store_bunch" place="store_bunch_put"/>
  <tunnel name="store_bunch_get" type="store_bunch" place="store_bunch_get"/>
  <tunnel name="store_volume" type="store_volume" place="store_volume"/>

  <net>

    <place name="config" type="config"/>
    <place name="volume_state" type="volume_state"/>
    <place name="volume_with_store" type="volume_with_store"/>
    <place name="bunch_with_store" type="bunch_with_store"/>

    <struct name="state">
      <field name="offset" type="n_of_m"/>
      <field name="volume" type="n_of_m"/>
      <field name="copy" type="n_of_m"/>
      <field name="bunch" type="n_of_m"/>
      <field name="bunch_stores" type="long"/>
      <field name="volume_stores" type="long"/>
    </struct>

    <transition name="init">
      <defun>
        <in name="config" type="config"/>
        <out name="state" type="state"/>
        <expression>
          ${state.offset.id} := 0L;
          ${state.offset.max} := ${config.offsets};

          ${state.volume.id} := 0L;
          ${state.volume.max} := ${config.per.offset.volumes};

          ${state.copy.id} := 0L;
          ${state.copy.max} := ${config.per.volume.copies};

          ${state.bunch.id} := 0L;
          ${state.bunch.max} := ${config.per.offset.bunches};

          ${state.bunch_stores} := ${config.size.store.bunch};
          ${state.volume_stores} := ${config.size.store.volume};
        </expression>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-out port="state" place="state_offset"/>
    </transition>

    <place name="state_offset" type="state"/>

    <transition name="break_offset">
      <defun>
        <in name="state" type="state"/>
        <expression></expression>
        <condition>${state.offset.id} :ge: ${state.offset.max}</condition>
      </defun>
      <connect-in port="state" place="state_offset"/>
    </transition>

    <transition name="step_offset">
      <defun>
        <in name="state" type="state"/>
        <out name="volume" type="state"/>
        <out name="bunch" type="state"/>
        <in name="credit_state_bunch_check_break" type="control"/>
        <expression>
          ${volume} := ${state};
          ${volume.volume.id} := 0L;

          ${bunch} := ${state};
          ${bunch.bunch.id} := 0L;
        </expression>
        <condition>${state.offset.id} :lt: ${state.offset.max}</condition>
      </defun>
      <connect-in port="state" place="state_offset"/>
      <connect-out port="volume" place="state_volume"/>
      <connect-out port="bunch" place="state_bunch_check_break"/>
      <connect-in port="credit_state_bunch_check_break" place="credit_state_bunch_check_break"/>
    </transition>

    <place name="wait_state_bunch" type="state"/>
    <place name="state_bunch" type="state"/>

    <transition name="take_state_bunch">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <in name="credit" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="state" place="wait_state_bunch"/>
      <connect-out port="state" place="pre_step_bunch_state_bunch"/>
      <connect-in port="credit" place="credit_step_bunch"/>
    </transition>

    <place name="state_bunch_check_break" type="state"/>
    <place name="credit_state_bunch_check_break" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="break_bunch">
      <defun>
        <in name="state" type="state"/>
        <out name="credit_state_bunch_check_break" type="control"/>
        <expression>
          ${credit_state_bunch_check_break} := []
        </expression>
        <condition>${state.bunch.id} :ge: ${state.bunch.max}</condition>
      </defun>
      <connect-in port="state" place="state_bunch_check_break"/>
      <connect-out port="credit_state_bunch_check_break" place="credit_state_bunch_check_break"/>
    </transition>

    <transition name="not_break_bunch">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <out name="credit_state_bunch_check_break" type="control"/>
        <expression>
          ${credit_state_bunch_check_break} := []
        </expression>
        <condition>${state.bunch.id} :lt: ${state.bunch.max}</condition>
      </defun>
      <connect-in port="state" place="state_bunch_check_break"/>
      <connect-out port="state" place="wait_state_bunch"/>
      <connect-out port="credit_state_bunch_check_break" place="credit_state_bunch_check_break"/>
    </transition>

    <place name="assoc" type="map" virtual="true"/>
    <place name="assoc_assign" type="map"/>
    <place name="store_bunch_put" type="store_bunch" virtual="true"/>
    <place name="store_bunch_get" type="store_bunch" virtual="true"/>

    <transition name="take_store_bunch">
      <defun>
        <in name="store" type="store_bunch"/>
        <out name="store" type="store_bunch"/>
        <in name="credit" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="store" place="store_bunch_put"/>
      <connect-out port="store" place="pre_step_bunch_store_bunch_get"/>
      <connect-in port="credit" place="credit_step_bunch"/>
    </transition>

    <place name="credit_step_bunch" type="control">
      <token><value>[]</value></token>
    </place>

    <place name="pre_step_bunch_state_bunch" type="state"/>
    <place name="pre_step_bunch_store_bunch_get" type="store_bunch"/>

    <transition name="step_bunch_state_bunch" priority="1">
      <defun>
        <in name="state" type="state"/>
        <in name="assoc" type="map"/>
        <in name="store" type="store_bunch"/>
        <out name="state" type="state"/>
        <out name="bunch" type="bunch_with_store"/>
        <out name="credit_step_bunch" type="control"/>
        <expression>
          ${bunch.bunch.id} := ${state.bunch.id};
          ${bunch.bunch.offset.id} := ${state.offset.id};
          ${bunch.store} := ${store};
          ${bunch.volumes.seen.id} := {};

          ${state.bunch.id} := ${state.bunch.id} + 1;

          ${credit_step_bunch} := []
        </expression>
        <condition>
          "step_bunch_state_bunch" != ""
        </condition>
        <condition>
          map_is_assigned (${assoc}, ${store.id})
        </condition>
        <condition>
          ${state.offset.id} :eq: map_get_assignment (${assoc}, ${store.id})
        </condition>
      </defun>
      <connect-in port="state" place="pre_step_bunch_state_bunch"/>
      <connect-read port="assoc" place="assoc"/>
      <connect-in port="store" place="store_bunch_get"/>
      <connect-out port="state" place="state_bunch_check_break_wait"/>
      <connect-out port="bunch" place="bunch_with_store"/>
      <connect-out port="credit_step_bunch" place="credit_step_bunch"/>
    </transition>

    <transition name="step_bunch_store_bunch_get" priority="1">
      <defun>
        <in name="state" type="state"/>
        <in name="assoc" type="map"/>
        <in name="store" type="store_bunch"/>
        <out name="state" type="state"/>
        <out name="bunch" type="bunch_with_store"/>
        <out name="credit_step_bunch" type="control"/>
        <expression>
          ${bunch.bunch.id} := ${state.bunch.id};
          ${bunch.bunch.offset.id} := ${state.offset.id};
          ${bunch.store} := ${store};
          ${bunch.volumes.seen.id} := {};

          ${state.bunch.id} := ${state.bunch.id} + 1;

          ${credit_step_bunch} := []
        </expression>
        <condition>
          "step_bunch_store_bunch_get" != ""
        </condition>
        <condition>
          map_is_assigned (${assoc}, ${store.id})
        </condition>
        <condition>
          ${state.offset.id} :eq: map_get_assignment (${assoc}, ${store.id})
        </condition>
      </defun>
      <connect-in port="state" place="state_bunch"/>
      <connect-read port="assoc" place="assoc"/>
      <connect-in port="store" place="pre_step_bunch_store_bunch_get"/>
      <connect-out port="state" place="state_bunch_check_break_wait"/>
      <connect-out port="bunch" place="bunch_with_store"/>
      <connect-out port="credit_step_bunch" place="credit_step_bunch"/>
    </transition>

    <transition name="no_step_bunch_state_bunch">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <out name="credit_step_bunch" type="control"/>
        <expression>
          ${credit_step_bunch} := []
        </expression>
      </defun>
      <connect-in port="state" place="pre_step_bunch_state_bunch"/>
      <connect-out port="state" place="state_bunch"/>
      <connect-out port="credit_step_bunch" place="credit_step_bunch"/>
    </transition>

    <transition name="no_step_bunch_store_bunch_get">
      <defun>
        <in name="store" type="store_bunch"/>
        <out name="store" type="store_bunch"/>
        <out name="credit_step_bunch" type="control"/>
        <expression>
          ${credit_step_bunch} := []
        </expression>
      </defun>
      <connect-in port="store" place="pre_step_bunch_store_bunch_get"/>
      <connect-out port="store" place="store_bunch_get"/>
      <connect-out port="credit_step_bunch" place="credit_step_bunch"/>
    </transition>

    <transition name="step_bunch" priority="3">
      <defun>
        <in name="state" type="state"/>
        <in name="assoc" type="map"/>
        <out name="assoc" type="map"/>
        <in name="store" type="store_bunch"/>
        <out name="state" type="state"/>
        <out name="bunch" type="bunch_with_store"/>
        <expression>
          ${bunch.bunch.id} := ${state.bunch.id};
          ${bunch.bunch.offset.id} := ${state.offset.id};
          ${bunch.store} := ${store};
          ${bunch.volumes.seen.id} := {};

          ${state.bunch.id} := ${state.bunch.id} + 1
        </expression>
        <condition>
          "step_bunch" != ""
        </condition>
        <condition>
          map_is_assigned (${assoc}, ${store.id})
        </condition>
        <condition>
          ${state.offset.id} :eq: map_get_assignment (${assoc}, ${store.id})
        </condition>
      </defun>
      <connect-in port="state" place="state_bunch"/>
      <connect-in port="assoc" place="pre_step_bunch_assoc"/>
      <connect-out port="assoc" place="assoc"/>
      <connect-in port="store" place="store_bunch_get"/>
      <connect-out port="state" place="state_bunch_check_break_wait"/>
      <connect-out port="bunch" place="bunch_with_store"/>
    </transition>

    <transition name="no_step_bunch" priority="2">
      <defun>
        <in name="assoc" type="map"/>
        <out name="assoc" type="map"/>
        <expression>
        </expression>
      </defun>
      <connect-in port="assoc" place="pre_step_bunch_assoc"/>
      <connect-out port="assoc" place="assoc"/>
    </transition>

    <place name="state_bunch_check_break_wait" type="state"/>

    <transition name="state_bunch_check_break">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <in name="credit_state_bunch_check_break" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="state" place="state_bunch_check_break_wait"/>
      <connect-out port="state" place="state_bunch_check_break"/>
      <connect-in port="credit_state_bunch_check_break" place="credit_state_bunch_check_break"/>
    </transition>

    <place name="state_volume" type="state"/>

    <transition name="break_volume">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <expression>
          ${state.offset.id} := ${state.offset.id} + 1
        </expression>
        <condition>${state.volume.id} :ge: ${state.volume.max}</condition>
      </defun>
      <connect-in port="state" place="state_volume"/>
      <connect-out port="state" place="state_offset"/>
    </transition>

    <transition name="step_volume">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <out name="volume" type="volume_state"/>
        <in name="credit_state_copy_check_break" type="control"/>
        <expression>
          ${volume.volume.id} := ${state.volume.id};
          ${volume.volume.offset.id} := ${state.offset.id};
          ${volume.copies} := ${state.copy.max};

          ${volume.bunches.left} := ${state.bunch.max};

          ${state.copy.id} := 0L;
        </expression>
        <condition>${state.volume.id} :lt: ${state.volume.max}</condition>
      </defun>
      <connect-in port="state" place="state_volume"/>
      <connect-out port="state" place="state_copy_check_break"/>
      <connect-out port="volume" place="volume_state"/>
      <connect-in port="credit_state_copy_check_break" place="credit_state_copy_check_break"/>
    </transition>

    <place name="state_copy" type="state"/>
    <place name="state_copy_check_break" type="state"/>
    <place name="credit_state_copy_check_break" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="break_copy">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <out name="credit_state_copy_check_break" type="control"/>
        <expression>
          ${state.volume.id} := ${state.volume.id} + 1;
          ${credit_state_copy_check_break} := []
        </expression>
        <condition>
          ${state.copy.id} :ge: ${state.copy.max}
        </condition>
      </defun>
      <connect-in port="state" place="state_copy_check_break"/>
      <connect-out port="state" place="state_volume"/>
      <connect-out port="credit_state_copy_check_break" place="credit_state_copy_check_break"/>
    </transition>

    <transition name="not_break_copy">
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <out name="credit_state_copy_check_break" type="control"/>
        <expression>
          ${credit_state_copy_check_break} := []
        </expression>
        <condition>
          ${state.copy.id} :lt: ${state.copy.max}
        </condition>
      </defun>
      <connect-in port="state" place="state_copy_check_break"/>
      <connect-out port="state" place="state_copy"/>
      <connect-out port="credit_state_copy_check_break" place="credit_state_copy_check_break"/>
    </transition>

    <place name="store_volume" type="store_volume" virtual="true"/>

    <struct name="state_assign">
      <field name="volume_with_store" type="volume_with_store"/>
      <field name="bunch_store_to_assign" type="n_of_m"/>
    </struct>

    <place name="state_assign" type="state_assign"/>
    <place name="state_assign_check_break" type="state_assign"/>
    <place name="credit_state_assign_check_break" type="control">
      <token><value>[]</value></token>
    </place>

    <transition name="step_copy">
      <defun>
        <in name="state" type="state"/>
        <in name="store" type="store_volume"/>
        <out name="state" type="state"/>
        <out name="state_assign" type="state_assign"/>
        <in name="credit_state_assign_check_break" type="control"/>
        <in name="credit_state_copy_check_break" type="control"/>
        <in name="assoc" type="map"/>
        <out name="assoc" type="map"/>
        <expression>
          ${state_assign.volume_with_store.volume.id}
            := ${state.volume.id};
          ${state_assign.volume_with_store.volume.offset.id}
            := ${state.offset.id};
          ${state_assign.volume_with_store.store}
            := ${store};

          ${b} := ${state.bunch_stores};
          ${v} := ${state.volume_stores};

          ${state_assign.bunch_store_to_assign.id}
            := long (ceil ((${store.id} + 0L) * ${b} / ${v}));
          ${state_assign.bunch_store_to_assign.max}
            := long (ceil ((${store.id} + 1L) * ${b} / ${v}));

          ${state.copy.id} := ${state.copy.id} + 1
        </expression>
      </defun>
      <connect-in port="state" place="state_copy"/>
      <connect-out port="state" place="state_copy_check_break"/>
      <connect-in port="store" place="store_volume"/>
      <connect-out port="state_assign" place="state_assign_check_break"/>
      <connect-in port="credit_state_assign_check_break" place="credit_state_assign_check_break"/>
      <connect-in port="credit_state_copy_check_break" place="credit_state_copy_check_break"/>
      <connect-in port="assoc" place="assoc"/>
      <connect-out port="assoc" place="assoc_assign"/>
    </transition>

    <transition name="break_assign">
      <defun>
        <in name="state" type="state_assign"/>
        <in name="assoc" type="map"/>
        <out name="assoc" type="map"/>
        <out name="volume" type="volume_with_store"/>
        <out name="credit_state_assign_check_break" type="control"/>
        <expression>
          ${volume} := ${state.volume_with_store};
          ${credit_state_assign_check_break} := []
        </expression>
        <condition>
          ${state.bunch_store_to_assign.id}
          :ge:
          ${state.bunch_store_to_assign.max}
        </condition>
      </defun>
      <connect-in port="state" place="state_assign_check_break"/>
      <connect-out port="volume" place="volume_with_store"/>
      <connect-out port="credit_state_assign_check_break" place="credit_state_assign_check_break"/>
      <connect-in port="assoc" place="assoc_assign"/>
      <connect-out port="assoc" place="pre_step_bunch_assoc"/>
    </transition>

    <place name="pre_step_bunch_assoc" type="map"/>

    <transition name="not_break_assign">
      <defun>
        <in name="state" type="state_assign"/>
        <out name="state" type="state_assign"/>
        <out name="credit_state_assign_check_break" type="control"/>
        <expression>
          ${credit_state_assign_check_break} := []
        </expression>
        <condition>
          ${state.bunch_store_to_assign.id}
          :lt:
          ${state.bunch_store_to_assign.max}
        </condition>
      </defun>
      <connect-in port="state" place="state_assign_check_break"/>
      <connect-out port="state" place="state_assign"/>
      <connect-out port="credit_state_assign_check_break" place="credit_state_assign_check_break"/>
    </transition>

    <transition name="step_assign">
      <defun>
        <in name="state" type="state_assign"/>
        <out name="state" type="state_assign"/>
        <in name="assoc" type="map"/>
        <out name="assoc" type="map"/>
        <in name="credit_state_assign_check_break" type="control"/>
        <expression>
          ${assoc} := map_assign ( ${assoc}
                                 , ${state.bunch_store_to_assign.id}
                                 , ${state.volume_with_store.volume.offset.id}
                                 );

          ${state.bunch_store_to_assign.id}
            := ${state.bunch_store_to_assign.id} + 1;
        </expression>
      </defun>
      <connect-in port="state" place="state_assign"/>
      <connect-out port="state" place="state_assign_check_break"/>
      <connect-in port="assoc" place="assoc_assign"/>
      <connect-out port="assoc" place="assoc_assign"/>
      <connect-in port="credit_state_assign_check_break" place="credit_state_assign_check_break"/>
    </transition>

  </net>
</defun>
