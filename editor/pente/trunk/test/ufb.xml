<defun name="calc">
  <struct name="config">
    <struct name="handle">
      <struct name="data">
        <field name="coarse_mask" type="long"/>
        <field name="coarse_vel" type="long"/>
        <field name="fine_any" type="long"/>
        <field name="input" type="long"/>
        <field name="output" type="long"/>
        <field name="update" type="long"/>
      </struct>
      <struct name="scratch">
        <field name="coarse_mask" type="long"/>
        <field name="coarse_vel" type="long"/>
        <field name="fine_any" type="long"/>
        <field name="input" type="long"/>
        <field name="output" type="long"/>
        <field name="update" type="long"/>
      </struct>
    </struct>
    <struct name="num">
      <field name="interval" type="long"/>
      <field name="nodes" type="long"/>
      <field name="package" type="long"/>
      <field name="store" type="long"/>
    </struct>
    <struct name="size">
      <struct name="alloc">
        <field name="coarse_mask" type="long"/>
        <field name="coarse_vel" type="long"/>
        <field name="fine_any" type="long"/>
        <field name="input" type="long"/>
        <field name="output" type="long"/>
        <field name="update" type="long"/>
      </struct>
      <field name="input" type="long"/>
      <field name="interval" type="long"/>
      <struct name="mem">
        <field name="gpi" type="long"/>
        <field name="shmem" type="long"/>
      </struct>
      <field name="package" type="long"/>
    </struct>
  </struct>
  <struct name="package">
    <field name="id" type="long"/>
    <struct name="work">
      <field name="done" type="bool"/>
      <field name="ptr" type="long"/>
    </struct>
  </struct>
  <struct name="store">
    <field name="id" type="long"/>
  </struct>
  <struct name="assigned_package">
    <field name="package" type="package"/>
    <field name="store" type="store"/>
  </struct>
  <struct name="ready_package">
    <field name="assigned_package" type="assigned_package"/>
    <field name="interval" type="interval"/>
  </struct>
  <struct name="interval">
    <field name="offset" type="long"/>
    <field name="size" type="long"/>
    <field name="used" type="long"/>
  </struct>
  <in name="file_with_config" type="string" place="file_with_config"/>
  <out name="done" type="control" place="done"/>
  <net>
    <template name="quad">
      <in name="in" type="T" place="x"/>
      <out name="one" type="T" place="one"/>
      <out name="two" type="T" place="two"/>
      <out name="three" type="T" place="three"/>
      <out name="four" type="T" place="four"/>
      <net>
        <place name="x" type="T"/>
        <place name="one" type="T"/>
        <place name="two" type="T"/>
        <place name="three" type="T"/>
        <place name="four" type="T"/>
        <transition name="triple">
          <defun>
            <in name="x" type="T"/>
            <out name="one" type="T"/>
            <out name="two" type="T"/>
            <out name="three" type="T"/>
            <out name="four" type="T"/>
            <expression>
              ${one} := ${x}; ${two} := ${x}; ${three} := ${x}; ${four} := ${x};
            </expression>
          </defun>
          <connect-in port="x" place="x"/>
          <connect-out port="one" place="one"/>
          <connect-out port="two" place="two"/>
          <connect-out port="three" place="three"/>
          <connect-out port="four" place="four"/>
        </transition>
      </net>
    </template>
    <specialize name="scatter_config" use="quad">
      <type-map replace="T" with="config"/>
    </specialize>
    <place name="file_with_config" type="string"/>
    <place name="config" type="config"/>
    <place name="done" type="control"/>
    <place name="config_read" type="config"/>
    <place name="config_generate_interval" type="config"/>
    <place name="config_generate_store" type="config"/>
    <place name="config_generate_package" type="config"/>
    <place name="num_outputslots" type="long"/>
    <place name="output" type="long"/>
    <place name="done_update" type="control"/>
    <place name="wait" type="long"/>
    <place name="trigger_interval" type="control"/>
    <place name="empty_interval" type="interval"/>
    <place name="empty_store" type="store"/>
    <place name="assigned_package" type="assigned_package"/>
    <place name="trigger_store" type="control"/>
    <place name="loaded_package" type="assigned_package"/>
    <place name="processed_interval" type="interval"/>
    <place name="interval_size" type="long"/>
    <transition name="init" inline="true">
      <defun>
        <in name="file_with_config" type="string" place="file_with_config"/>
        <out name="config" type="config" place="config"/>
        <out name="wait" type="long" place="wait"/>
        <out name="interval_size" type="long" place="interval_size"/>
        <out name="num_outputslots" type="long" place="num_outputslots"/>
        <net>
          <place name="file_with_config" type="string"/>
          <place name="config" type="config"/>
          <place name="wait" type="long"/>
          <place name="interval_size" type="long"/>
          <place name="num_outputslots" type="long"/>
          <place name="config_read" type="config"/>
          <transition name="read_config" inline="true">
            <defun>
              <in name="file_with_config" type="string" place="file_with_config"/>
              <out name="config" type="config" place="config"/>
              <net>
                <template name="generic_read">
                  <in name="filename" type="string"/>
                  <out name="x" type="T"/>
                  <module name="ufbmig" function="read (filename, x)">
                    <cinclude href="fhglog/fhglog.hpp"/>
                    <cinclude href="util/rw.hpp"/>
                    <code>
                      <![CDATA[
      LOG (INFO, "read from file " << filename);

      ::ufbmig::util::serialize::read (filename, x);
    ]]>
                    </code>
                  </module>
                </template>
                <specialize name="read_config" use="generic_read">
                  <type-map replace="T" with="config"/>
                </specialize>
                <place name="file_with_config" type="string"/>
                <place name="config" type="config"/>
                <transition name="read_config">
                  <use name="read_config"/>
                  <connect-in port="filename" place="file_with_config"/>
                  <connect-out port="x" place="config"/>
                </transition>
              </net>
            </defun>
            <connect-in port="file_with_config" place="file_with_config"/>
            <connect-out port="config" place="config_read"/>
          </transition>
          <transition name="init">
            <defun>
              <in name="config" type="config"/>
              <out name="config" type="config"/>
              <out name="interval_size" type="long"/>
              <out name="num_outputslots" type="long"/>
              <out name="wait" type="long"/>
              <expression>
                ${interval_size} := ${config.size.interval}; ${wait} := ${config.num.package}; ${num_outputslots} := ${config.num.nodes};
              </expression>
            </defun>
            <connect-in port="config" place="config_read"/>
            <connect-out port="interval_size" place="interval_size"/>
            <connect-out port="num_outputslots" place="num_outputslots"/>
            <connect-out port="wait" place="wait"/>
            <connect-out port="config" place="config"/>
          </transition>
        </net>
      </defun>
      <connect-in port="file_with_config" place="file_with_config"/>
      <connect-out port="config" place="config"/>
      <connect-out port="wait" place="wait"/>
      <connect-out port="interval_size" place="interval_size"/>
      <connect-out port="num_outputslots" place="num_outputslots"/>
    </transition>
    <transition name="scatter_config" inline="true">
      <use name="scatter_config"/>
      <connect-in port="in" place="config"/>
      <connect-out port="one" place="config_read"/>
      <connect-out port="two" place="config_generate_interval"/>
      <connect-out port="three" place="config_generate_store"/>
      <connect-out port="four" place="config_generate_package"/>
    </transition>
    <transition name="generate_outputslots" inline="true">
      <defun name="sequence">
        <in name="amount" type="long" place="N"/>
        <out name="out" type="long" place="id"/>
        <net>
          <struct name="state">
            <field name="id" type="long"/>
            <field name="max" type="long"/>
          </struct>
          <place name="N" type="long"/>
          <place name="state" type="state"/>
          <place name="id" type="long"/>
          <place name="check_break" type="state" capacity="1"/>
          <transition name="init">
            <defun>
              <in name="N" type="long"/>
              <out name="state" type="state"/>
              <expression>
                ${state.id} := 0L; ${state.max} := ${N}
              </expression>
            </defun>
            <connect-in port="N" place="N"/>
            <connect-out port="state" place="check_break"/>
          </transition>
          <transition name="break">
            <defun>
              <in name="state" type="state"/>
              <expression/>
              <condition>
                ${state.id} :ge: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
          </transition>
          <transition name="not_break">
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <expression/>
              <condition>
                ${state.id} :lt: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="state" place="state"/>
          </transition>
          <transition name="step">
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <out name="id" type="long"/>
              <expression>
                ${id} := ${state.id}; ${state.id} := ${state.id} + 1
              </expression>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-out port="state" place="check_break"/>
            <connect-out port="id" place="id"/>
          </transition>
        </net>
      </defun>
      <connect-in port="amount" place="num_outputslots"/>
      <connect-out port="out" place="output"/>
    </transition>
    <transition name="generate_interval" inline="true">
      <defun>
        <in name="config" type="config" place="config"/>
        <out name="interval" type="interval" place="interval"/>
        <net>
          <struct name="counter">
            <field name="id" type="long"/>
            <field name="max" type="long"/>
          </struct>
          <struct name="state">
            <field name="counter" type="counter"/>
            <field name="size" type="long"/>
          </struct>
          <place name="config" type="config"/>
          <place name="interval" type="interval"/>
          <place name="state" type="state"/>
          <place name="trigger" type="control" virtual="true"/>
          <place name="done" type="control"/>
          <place name="state_not_done" type="state"/>
          <transition name="init">
            <defun>
              <in name="config" type="config"/>
              <out name="state" type="state"/>
              <expression>
                ${state.counter.max} := ${config.num.interval}; ${state.counter.id} := 0L; ${state.size} := ${config.size.alloc.update} div ${config.num.interval};
              </expression>
            </defun>
            <connect-in port="config" place="config"/>
            <connect-out port="state" place="state"/>
          </transition>
          <transition name="done">
            <defun>
              <in name="state" type="state"/>
              <out name="done" type="control"/>
              <expression>
                ${done} := []
              </expression>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-out port="done" place="done"/>
            <condition>
              ${state.counter.id} :ge: ${state.counter.max}
            </condition>
          </transition>
          <transition name="eat">
            <defun>
              <in name="online" type="control"/>
              <in name="x" type="control"/>
              <expression/>
            </defun>
            <connect-read port="online" place="done"/>
            <connect-in port="x" place="trigger"/>
          </transition>
          <transition name="not_done">
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <expression/>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-out port="state" place="state_not_done"/>
            <condition>
              ${state.counter.id} :lt: ${state.counter.max}
            </condition>
          </transition>
          <transition name="step">
            <defun>
              <in name="trigger" type="control"/>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <out name="interval" type="interval"/>
              <expression>
                ${interval.offset} := ${state.counter.id} * ${state.size}; ${interval.size} := ${state.size}; ${interval.used} := 0L; ${state.counter.id} := ${state.counter.id} + 1
              </expression>
            </defun>
            <connect-in port="trigger" place="trigger"/>
            <connect-in port="state" place="state_not_done"/>
            <connect-out port="state" place="state"/>
            <connect-out port="interval" place="interval"/>
          </transition>
        </net>
      </defun>
      <place-map virtual="trigger" real="trigger_interval"/>
      <connect-in port="config" place="config_generate_interval"/>
      <connect-out port="interval" place="empty_interval"/>
    </transition>
    <transition name="generate_store" inline="true">
      <defun>
        <in name="config" type="config" place="config"/>
        <out name="store" type="store" place="store"/>
        <net>
          <struct name="counter">
            <field name="id" type="long"/>
            <field name="max" type="long"/>
          </struct>
          <struct name="state">
            <field name="counter" type="counter"/>
          </struct>
          <place name="config" type="config"/>
          <place name="store" type="store"/>
          <place name="state" type="state"/>
          <place name="trigger" type="control" virtual="true"/>
          <place name="done" type="control"/>
          <place name="state_not_done" type="state"/>
          <transition name="init">
            <defun>
              <in name="config" type="config"/>
              <out name="state" type="state"/>
              <expression>
                ${state.counter.max} := ${config.num.store}; ${state.counter.id} := 0L;
              </expression>
            </defun>
            <connect-in port="config" place="config"/>
            <connect-out port="state" place="state"/>
          </transition>
          <transition name="done">
            <defun>
              <in name="state" type="state"/>
              <out name="done" type="control"/>
              <expression>
                ${done} := []
              </expression>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-out port="done" place="done"/>
            <condition>
              ${state.counter.id} :ge: ${state.counter.max}
            </condition>
          </transition>
          <transition name="eat">
            <defun>
              <in name="online" type="control"/>
              <in name="x" type="control"/>
              <expression/>
            </defun>
            <connect-read port="online" place="done"/>
            <connect-in port="x" place="trigger"/>
          </transition>
          <transition name="not_done">
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <expression/>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-out port="state" place="state_not_done"/>
            <condition>
              ${state.counter.id} :lt: ${state.counter.max}
            </condition>
          </transition>
          <transition name="step">
            <defun>
              <in name="trigger" type="control"/>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <out name="store" type="store"/>
              <expression>
                ${store.id} := ${state.counter.id}; ${state.counter.id} := ${state.counter.id} + 1
              </expression>
            </defun>
            <connect-in port="trigger" place="trigger"/>
            <connect-in port="state" place="state_not_done"/>
            <connect-out port="state" place="state"/>
            <connect-out port="store" place="store"/>
          </transition>
        </net>
      </defun>
      <place-map virtual="trigger" real="trigger_store"/>
      <connect-in port="config" place="config_generate_store"/>
      <connect-out port="store" place="empty_store"/>
    </transition>
    <transition name="generate_package" inline="true">
      <defun>
        <in name="config" type="config" place="config"/>
        <out name="assigned_package" type="assigned_package" place="assigned_package"/>
        <net>
          <struct name="state">
            <field name="id" type="long"/>
            <field name="max" type="long"/>
          </struct>
          <place name="config" type="config"/>
          <place name="assigned_package" type="assigned_package"/>
          <place name="check_break" type="state"/>
          <place name="state" type="state"/>
          <place name="trigger" type="control" virtual="true"/>
          <place name="store" type="store" virtual="true"/>
          <transition name="init">
            <defun>
              <in name="config" type="config"/>
              <out name="state" type="state"/>
              <expression>
                ${state.max} := ${config.num.package}; ${state.id} := 0L;
              </expression>
            </defun>
            <connect-in port="config" place="config"/>
            <connect-out port="state" place="check_break"/>
          </transition>
          <transition name="break">
            <defun>
              <in name="state" type="state"/>
              <expression/>
            </defun>
            <connect-in port="state" place="check_break"/>
            <condition>
              ${state.id} :ge: ${state.max}
            </condition>
          </transition>
          <transition name="not_break">
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <out name="trigger" type="control"/>
              <expression>
                ${trigger} := []
              </expression>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="state" place="state"/>
            <connect-out port="trigger" place="trigger"/>
            <condition>
              ${state.id} :lt: ${state.max}
            </condition>
          </transition>
          <transition name="step">
            <defun>
              <in name="state" type="state"/>
              <in name="store" type="store"/>
              <out name="state" type="state"/>
              <out name="assigned_package" type="assigned_package"/>
              <expression>
                ${package.id} := ${state.id}; ${package.work.done} := false; ${package.work.ptr} := 0L; ${state.id} := ${state.id} + 1; ${assigned_package.package} := ${package}; ${assigned_package.store} := ${store};
              </expression>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-in port="store" place="store"/>
            <connect-out port="state" place="check_break"/>
            <connect-out port="assigned_package" place="assigned_package"/>
          </transition>
        </net>
      </defun>
      <place-map virtual="trigger" real="trigger_store"/>
      <place-map virtual="store" real="empty_store"/>
      <connect-in port="config" place="config_generate_package"/>
      <connect-out port="assigned_package" place="assigned_package"/>
    </transition>
    <transition name="load" inline="true">
      <defun>
        <in name="assigned_package" type="assigned_package" place="assigned_package"/>
        <out name="assigned_package" type="assigned_package" place="loaded_package"/>
        <out name="trigger" type="control" place="trigger"/>
        <net>
          <template name="trigger_when">
            <in name="object" type="T"/>
            <out name="object" type="T"/>
            <out name="trigger" type="control"/>
            <expression>
              ${trigger} := []
            </expression>
          </template>
          <specialize name="trigger_when_assigned_package" use="trigger_when">
            <type-map replace="T" with="assigned_package"/>
          </specialize>
          <place name="config" type="config" virtual="true"/>
          <place name="assigned_package" type="assigned_package"/>
          <place name="loaded_package" type="assigned_package"/>
          <place name="trigger" type="control"/>
          <place name="pre_loaded_package" type="assigned_package"/>
          <transition name="load">
            <defun>
              <in name="config" type="config"/>
              <in name="assigned_package" type="assigned_package"/>
              <out name="assigned_package" type="assigned_package"/>
              <module name="ufbmig" function="load (config, assigned_package)">
                <cinclude href="fhglog/fhglog.hpp"/>
                <code>
                  <![CDATA[
            LOG (INFO, "LOAD " << assigned_package);
          ]]>
                </code>
              </module>
            </defun>
            <connect-read port="config" place="config"/>
            <connect-in port="assigned_package" place="assigned_package"/>
            <connect-out port="assigned_package" place="pre_loaded_package"/>
          </transition>
          <transition name="trigger">
            <use name="trigger_when_assigned_package"/>
            <connect-in port="object" place="pre_loaded_package"/>
            <connect-out port="object" place="loaded_package"/>
            <connect-out port="trigger" place="trigger"/>
          </transition>
        </net>
      </defun>
      <place-map virtual="config" real="config_read"/>
      <connect-in port="assigned_package" place="assigned_package"/>
      <connect-out port="assigned_package" place="loaded_package"/>
      <connect-out port="trigger" place="trigger_interval"/>
    </transition>
    <transition name="calculate" inline="true">
      <defun>
        <in name="empty_interval" type="interval" place="empty_interval"/>
        <in name="loaded_package" type="assigned_package" place="loaded_package"/>
        <out name="processed_interval" type="interval" place="processed_interval"/>
        <out name="empty_store" type="store" place="empty_store"/>
        <net>
          <place name="config" type="config" virtual="true"/>
          <place name="empty_interval" type="interval"/>
          <place name="loaded_package" type="assigned_package"/>
          <place name="processed_interval" type="interval"/>
          <place name="empty_store" type="store"/>
          <place name="ready_package" type="ready_package"/>
          <place name="done_package" type="ready_package"/>
          <place name="wait" type="long" virtual="true"/>
          <place name="trigger_interval" type="control" virtual="true"/>
          <transition name="ready_package">
            <defun>
              <in name="loaded_package" type="assigned_package"/>
              <in name="interval" type="interval"/>
              <out name="ready_package" type="ready_package"/>
              <expression>
                ${ready_package.assigned_package} := ${loaded_package}; ${ready_package.interval} := ${interval};
              </expression>
            </defun>
            <connect-in port="loaded_package" place="loaded_package"/>
            <connect-in port="interval" place="empty_interval"/>
            <connect-out port="ready_package" place="ready_package"/>
          </transition>
          <transition name="calculate">
            <defun>
              <in name="config" type="config"/>
              <in name="ready_package" type="ready_package"/>
              <out name="ready_package" type="ready_package"/>
              <module name="ufbmig" function="calculate (config, ready_package)">
                <cinclude href="fhglog/fhglog.hpp"/>
                <cinclude href="fvm-pc/pc.hpp"/>
                <cinclude href="string"/>
                <code>
                  <![CDATA[
            LOG (INFO, "RUN " << ready_package);

            char * update_descr = static_cast<char *> (fvmGetShmemPtr());

            ::pnetc::type::interval::interval & interval
             (ready_package.interval);
            ::pnetc::type::package::package & package
             (ready_package.assigned_package.package);

            const long ptr0 (package.work.ptr);
            const long num_updates (53);

            for ( long i (0)
                ; (i < interval.size) && (package.work.ptr < num_updates)
                ; ++i, ++package.work.ptr
                )
              {
                update_descr[i] = 'a' + (i + ptr0) % config.num.nodes;
              }

            package.work.done = (package.work.ptr >= num_updates);
            interval.used = (package.work.ptr - ptr0);

            // to just demonstrate this
            if (package.id == 23)
              {
                interval.used = 0;
                package.work.done = true;
              }

            LOG ( INFO
                , "RESULT: "
                << std::string ( update_descr
                               , update_descr + interval.used
                               )
                );

            waitComm ( fvmPutGlobalData
                       ( static_cast<fvmAllocHandle_t> (config.handle.data.update)
                       , interval.offset
                       , interval.used
                       , 0
                       , static_cast<fvmAllocHandle_t> (config.handle.scratch.update)
                       )
                     );
          ]]>
                </code>
              </module>
            </defun>
            <connect-read port="config" place="config"/>
            <connect-in port="ready_package" place="ready_package"/>
            <connect-out port="ready_package" place="done_package"/>
          </transition>
          <transition name="finalize_package">
            <defun>
              <in name="done_package" type="ready_package"/>
              <out name="store" type="store"/>
              <out name="interval" type="interval"/>
              <expression>
                ${store} := ${done_package.assigned_package.store}; ${interval} := ${done_package.interval};
              </expression>
            </defun>
            <connect-in port="done_package" place="done_package"/>
            <connect-out port="store" place="empty_store"/>
            <connect-out port="interval" place="processed_interval"/>
            <condition>
              ${done_package.assigned_package.package.work.done}
            </condition>
          </transition>
          <transition name="resubmit_package">
            <defun>
              <in name="done_package" type="ready_package"/>
              <in name="wait" type="long"/>
              <out name="wait" type="long"/>
              <out name="loaded_package" type="assigned_package"/>
              <out name="interval" type="interval"/>
              <out name="trigger" type="control"/>
              <expression>
                ${loaded_package} := ${done_package.assigned_package}; ${interval} := ${done_package.interval}; ${trigger} := []; ${wait} := ${wait} + 1;
              </expression>
            </defun>
            <connect-in port="done_package" place="done_package"/>
            <connect-in port="wait" place="wait"/>
            <connect-out port="loaded_package" place="loaded_package"/>
            <connect-out port="interval" place="processed_interval"/>
            <connect-out port="trigger" place="trigger_interval"/>
            <connect-out port="wait" place="wait"/>
            <condition>
              !${done_package.assigned_package.package.work.done}
            </condition>
          </transition>
        </net>
      </defun>
      <place-map virtual="config" real="config_read"/>
      <place-map virtual="trigger_interval" real="trigger_interval"/>
      <place-map virtual="wait" real="wait"/>
      <connect-in port="empty_interval" place="empty_interval"/>
      <connect-in port="loaded_package" place="loaded_package"/>
      <connect-out port="processed_interval" place="processed_interval"/>
      <connect-out port="empty_store" place="empty_store"/>
    </transition>
    <transition name="update" inline="true">
      <defun>
        <struct name="interval_tagged_with_id">
          <field name="id" type="long"/>
          <field name="interval" type="interval"/>
        </struct>
        <in name="processed_interval" type="interval" place="processed_interval"/>
        <out name="empty_interval" type="interval" place="empty_interval"/>
        <out name="done_update" type="control" place="done_update"/>
        <net>
          <template name="dup">
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="a"/>
            <out name="two" type="T" place="b"/>
            <net>
              <place name="x" type="T"/>
              <place name="a" type="T"/>
              <place name="b" type="T"/>
              <transition name="dup">
                <defun>
                  <in name="x" type="T"/>
                  <out name="a" type="T"/>
                  <out name="b" type="T"/>
                  <expression>
                    ${a} := ${x}; ${b} := ${x};
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="a" place="a"/>
                <connect-out port="b" place="b"/>
              </transition>
            </net>
          </template>
          <template name="wait">
            <in name="trigger" type="T" place="trigger"/>
            <out name="done" type="control" place="done"/>
            <net>
              <place name="trigger" type="T"/>
              <place name="done" type="control"/>
              <place name="wait" type="long" virtual="true"/>
              <transition name="dec">
                <defun>
                  <in name="object" type="T"/>
                  <in name="wait" type="long"/>
                  <out name="wait" type="long"/>
                  <expression>
                    ${wait} := ${wait} - 1;
                  </expression>
                  <condition>
                    ${wait} :gt: 0
                  </condition>
                </defun>
                <connect-in port="object" place="trigger"/>
                <connect-in port="wait" place="wait"/>
                <connect-out port="wait" place="wait"/>
              </transition>
              <transition name="break">
                <defun>
                  <in name="wait" type="long"/>
                  <out name="trigger" type="control"/>
                  <expression>
                    ${trigger} := []
                  </expression>
                  <condition>
                    ${wait} :eq: 0
                  </condition>
                </defun>
                <connect-in port="wait" place="wait"/>
                <connect-out port="trigger" place="done"/>
              </transition>
            </net>
          </template>
          <specialize name="dup_interval" use="dup">
            <type-map replace="T" with="interval"/>
          </specialize>
          <specialize name="wait_interval" use="wait">
            <type-map replace="T" with="interval"/>
          </specialize>
          <place name="config" type="config" virtual="true"/>
          <place name="processed_interval" type="interval"/>
          <place name="update_interval" type="interval_tagged_with_id"/>
          <place name="wait" type="long" virtual="true"/>
          <place name="empty_interval" type="interval"/>
          <place name="done_update" type="control"/>
          <place name="interval_size" type="long" virtual="true"/>
          <place name="nonempty_processed_interval" type="interval"/>
          <place name="output" type="long" virtual="true"/>
          <place name="selected_interval" type="interval_tagged_with_id"/>
          <place name="updated_interval_tagged" type="interval_tagged_with_id"/>
          <place name="updated_interval" type="interval"/>
          <place name="done_interval" type="interval"/>
          <place name="interval_to_merge" type="interval"/>
          <transition name="empty">
            <defun>
              <in name="i" type="interval"/>
              <in name="wait" type="long"/>
              <out name="i" type="interval"/>
              <out name="wait" type="long"/>
              <expression>
                ${wait} := ${wait} - 1L;
              </expression>
            </defun>
            <connect-in port="i" place="processed_interval"/>
            <connect-in port="wait" place="wait"/>
            <connect-out port="i" place="updated_interval"/>
            <connect-out port="wait" place="wait"/>
            <condition>
              ${i.used} :le: 0L
            </condition>
          </transition>
          <transition name="nonempty">
            <defun>
              <in name="i" type="interval"/>
              <out name="i" type="interval"/>
              <expression/>
            </defun>
            <connect-in port="i" place="processed_interval"/>
            <connect-out port="i" place="nonempty_processed_interval"/>
            <condition>
              ${i.used} :gt: 0L
            </condition>
          </transition>
          <transition name="split" inline="true">
            <defun>
              <in name="config" type="config" place="config"/>
              <in name="interval" type="interval" place="interval"/>
              <out name="interval_tagged" type="interval_tagged_with_id" place="splitted"/>
              <net>
                <struct name="intervals">
                  <field name="ids" type="stack"/>
                  <field name="interval" type="interval"/>
                  <field name="sizes" type="stack"/>
                  <field name="useds" type="stack"/>
                </struct>
                <place name="config" type="config"/>
                <place name="interval" type="interval"/>
                <place name="splitted" type="interval_tagged_with_id"/>
                <place name="update_wait" type="intervals"/>
                <place name="pre_intervals" type="intervals"/>
                <place name="intervals" type="intervals" capacity="1"/>
                <place name="wait" type="long" virtual="true"/>
                <place name="nonempty_intervals" type="intervals"/>
                <transition name="split">
                  <defun>
                    <in name="config" type="config"/>
                    <in name="interval" type="interval"/>
                    <out name="intervals" type="intervals"/>
                    <module name="ufbmig" function="intervals split (config, interval)">
                      <cinclude href="fhglog/fhglog.hpp"/>
                      <cinclude href="fvm-pc/pc.hpp"/>
                      <cinclude href="algorithm"/>
                      <cinclude href="stdexcept"/>
                      <code>
                        <![CDATA[
            if (interval.used <= 0)
              {
                throw std::runtime_error
                  ("STRANGE: empty interval given to split");
              }

            waitComm ( fvmGetGlobalData
                       ( static_cast<fvmAllocHandle_t> (config.handle.data.update)
                       , interval.offset
                       , interval.used
                       , 0
                       , static_cast<fvmAllocHandle_t> (config.handle.scratch.update)
                       )
                     );

            char * update_descr = static_cast<char *> (fvmGetShmemPtr());

            std::sort (update_descr, update_descr + interval.used);

            waitComm ( fvmPutGlobalData
                       ( static_cast<fvmAllocHandle_t> (config.handle.data.update)
                       , interval.offset
                       , interval.used
                       , 0
                       , static_cast<fvmAllocHandle_t> (config.handle.scratch.update)
                       )
                     );

            char x (update_descr[0]);

            ::pnetc::type::intervals::intervals intervals;

            intervals.interval = interval;
            intervals.sizes.push_front (1L);
            intervals.useds.push_front (1L);
            intervals.ids.push_front (static_cast<long>(x - 'a'));

            for (long i (1); i < interval.used; ++i)
              {
                const char & y (update_descr[i]);

                if (y != x)
                  {
                    x = y;

                    intervals.sizes.push_front (1L);
                    intervals.useds.push_front (1L);
                    intervals.ids.push_front (static_cast<long>(x - 'a'));
                  }
                else
                  {
                    intervals.sizes.front() += 1L;
                    intervals.useds.front() += 1L;
                  }
              }

            intervals.sizes.front() += interval.size - interval.used;

            {
              std::ostringstream oss;

              for (long i (interval.used); i < interval.size; ++i)
                {
                  oss << ".";
                }

              LOG ( INFO
                  , "SPLITTED "
                  << std::string (update_descr, update_descr + interval.used)
                  << oss.str()
                  << " into " << intervals
                  );
            }

            return intervals;
          ]]>
                      </code>
                    </module>
                  </defun>
                  <connect-in port="config" place="config"/>
                  <connect-in port="interval" place="interval"/>
                  <connect-out port="intervals" place="update_wait"/>
                </transition>
                <transition name="update_wait">
                  <defun>
                    <in name="intervals" type="intervals"/>
                    <in name="wait" type="long"/>
                    <out name="intervals" type="intervals"/>
                    <out name="wait" type="long"/>
                    <expression>
                      ${wait} := ${wait} - 1 + stack_size (${intervals.sizes})
                    </expression>
                  </defun>
                  <connect-in port="intervals" place="update_wait"/>
                  <connect-in port="wait" place="wait"/>
                  <connect-out port="intervals" place="pre_intervals"/>
                  <connect-out port="wait" place="wait"/>
                </transition>
                <transition name="select">
                  <defun>
                    <in name="intervals" type="intervals"/>
                    <out name="intervals" type="intervals"/>
                    <expression/>
                  </defun>
                  <connect-in port="intervals" place="pre_intervals"/>
                  <connect-out port="intervals" place="intervals"/>
                </transition>
                <transition name="empty">
                  <defun>
                    <in name="intervals" type="intervals"/>
                    <expression/>
                    <condition>
                      stack_empty (${intervals.sizes})
                    </condition>
                  </defun>
                  <connect-in port="intervals" place="intervals"/>
                </transition>
                <transition name="not_empty">
                  <defun>
                    <in name="intervals" type="intervals"/>
                    <out name="intervals" type="intervals"/>
                    <expression/>
                    <condition>
                      !stack_empty (${intervals.sizes})
                    </condition>
                  </defun>
                  <connect-in port="intervals" place="intervals"/>
                  <connect-out port="intervals" place="nonempty_intervals"/>
                </transition>
                <transition name="take">
                  <defun>
                    <in name="intervals" type="intervals"/>
                    <out name="intervals" type="intervals"/>
                    <out name="interval" type="interval_tagged_with_id"/>
                    <expression>
                      ${interval.interval} := ${intervals.interval}; ${interval.interval.size} := stack_top (${intervals.sizes}); ${interval.interval.used} := stack_top (${intervals.useds}); ${interval.id} := stack_top (${intervals.ids}); ${intervals.interval.offset} := ${intervals.interval.offset} + stack_top (${intervals.sizes}); ${intervals.sizes} := stack_pop (${intervals.sizes}); ${intervals.useds} := stack_pop (${intervals.useds}); ${intervals.ids} := stack_pop (${intervals.ids});
                    </expression>
                  </defun>
                  <connect-in port="intervals" place="nonempty_intervals"/>
                  <connect-out port="intervals" place="pre_intervals"/>
                  <connect-out port="interval" place="splitted"/>
                </transition>
              </net>
            </defun>
            <place-map virtual="wait" real="wait"/>
            <connect-read port="config" place="config"/>
            <connect-in port="interval" place="nonempty_processed_interval"/>
            <connect-out port="interval_tagged" place="update_interval"/>
          </transition>
          <transition name="select">
            <defun>
              <in name="interval_tagged" type="interval_tagged_with_id"/>
              <in name="output" type="long"/>
              <out name="interval_tagged" type="interval_tagged_with_id"/>
              <expression/>
            </defun>
            <connect-in port="interval_tagged" place="update_interval"/>
            <connect-in port="output" place="output"/>
            <connect-out port="interval_tagged" place="selected_interval"/>
            <condition>
              ${interval_tagged.id} :eq: ${output}
            </condition>
          </transition>
          <transition name="update">
            <defun>
              <in name="config" type="config"/>
              <in name="interval_tagged" type="interval_tagged_with_id"/>
              <out name="interval_tagged" type="interval_tagged_with_id"/>
              <module name="ufbmig" function="update (config, interval_tagged)">
                <cinclude href="fhglog/fhglog.hpp"/>
                <cinclude href="fvm-pc/pc.hpp"/>
                <code>
                  <![CDATA[
            LOG (INFO, "UPDATE " << interval_tagged);

            ::pnetc::type::interval::interval & interval (interval_tagged.interval);

            waitComm ( fvmGetGlobalData
                       ( static_cast<fvmAllocHandle_t> (config.handle.data.update)
                       , interval.offset
                       , interval.used
                       , 0
                       , static_cast<fvmAllocHandle_t> (config.handle.scratch.update)
                       )
                     );

            char * update_descr = static_cast<char *> (fvmGetShmemPtr());

            LOG ( INFO
                , "UPDATE_WITH "
                << std::string (update_descr, update_descr + interval.used)
                );

            interval.used = 0L;
          ]]>
                </code>
              </module>
            </defun>
            <connect-read port="config" place="config"/>
            <connect-in port="interval_tagged" place="selected_interval"/>
            <connect-out port="interval_tagged" place="updated_interval_tagged"/>
          </transition>
          <transition name="give_back">
            <defun>
              <in name="interval_tagged" type="interval_tagged_with_id"/>
              <out name="output" type="long"/>
              <out name="interval" type="interval"/>
              <expression>
                ${output} := ${interval_tagged.id}; ${interval} := ${interval_tagged.interval}
              </expression>
            </defun>
            <connect-in port="interval_tagged" place="updated_interval_tagged"/>
            <connect-out port="output" place="output"/>
            <connect-out port="interval" place="updated_interval"/>
          </transition>
          <transition name="scatter_interval" inline="true">
            <use name="dup_interval"/>
            <connect-in port="in" place="updated_interval"/>
            <connect-out port="one" place="done_interval"/>
            <connect-out port="two" place="interval_to_merge"/>
          </transition>
          <transition name="merge_interval" inline="true">
            <defun>
              <in name="empty" type="interval" place="pre_empty"/>
              <out name="interval" type="interval" place="interval"/>
              <net>
                <template name="select">
                  <in name="x" type="T"/>
                  <out name="x" type="T"/>
                  <expression/>
                </template>
                <specialize name="select_interval" use="select">
                  <type-map replace="T" with="interval"/>
                </specialize>
                <place name="pre_empty" type="interval"/>
                <place name="size_wanted" type="long" virtual="true"/>
                <place name="interval" type="interval"/>
                <place name="empty_interval" type="interval" capacity="1"/>
                <place name="small_interval" type="interval" capacity="1"/>
                <place name="pre_small_interval" type="interval"/>
                <place name="small_intervals" type="interval"/>
                <transition name="select_empty_interval">
                  <use name="select_interval"/>
                  <connect-in port="x" place="pre_empty"/>
                  <connect-out port="x" place="empty_interval"/>
                </transition>
                <transition name="interval_size_okay">
                  <defun>
                    <in name="size_wanted" type="long"/>
                    <in name="interval" type="interval"/>
                    <out name="interval" type="interval"/>
                    <expression/>
                  </defun>
                  <connect-read port="size_wanted" place="size_wanted"/>
                  <connect-in port="interval" place="empty_interval"/>
                  <connect-out port="interval" place="interval"/>
                  <condition>
                    ${interval.size} :eq: ${size_wanted}
                  </condition>
                </transition>
                <transition name="interval_to_small">
                  <defun>
                    <in name="size_wanted" type="long"/>
                    <in name="interval" type="interval"/>
                    <out name="interval" type="interval"/>
                    <expression/>
                  </defun>
                  <connect-read port="size_wanted" place="size_wanted"/>
                  <connect-in port="interval" place="empty_interval"/>
                  <connect-out port="interval" place="pre_small_interval"/>
                  <condition>
                    ${interval.size} :lt: ${size_wanted}
                  </condition>
                </transition>
                <transition name="select_small_interval">
                  <use name="select_interval"/>
                  <connect-in port="x" place="pre_small_interval"/>
                  <connect-out port="x" place="small_interval"/>
                </transition>
                <transition name="interval_to_big">
                  <defun>
                    <in name="size_wanted" type="long"/>
                    <in name="interval" type="interval"/>
                    <out name="rest" type="interval"/>
                    <out name="interval" type="interval"/>
                    <expression>
                      ${rest.offset} := ${interval.offset} + ${size_wanted}; ${rest.size} := ${interval.size} - ${size_wanted}; ${rest.used} := 0L; ${interval.size} := ${size_wanted}
                    </expression>
                  </defun>
                  <connect-read port="size_wanted" place="size_wanted"/>
                  <connect-in port="interval" place="empty_interval"/>
                  <connect-out port="interval" place="interval"/>
                  <connect-out port="rest" place="pre_empty"/>
                  <condition>
                    ${interval.size} :gt: ${size_wanted}
                  </condition>
                </transition>
                <transition name="mergeR" priority="1">
                  <defun>
                    <in name="a" type="interval"/>
                    <in name="b" type="interval"/>
                    <out name="s" type="interval"/>
                    <expression>
                      ${s.offset} := ${b.offset}; ${s.size} := ${a.size} + ${b.size}; ${s.used} := 0L;
                    </expression>
                  </defun>
                  <connect-in port="a" place="small_interval"/>
                  <connect-in port="b" place="small_intervals"/>
                  <connect-out port="s" place="pre_empty"/>
                  <condition>
                    ${b.offset} + ${b.size} :eq: ${a.offset}
                  </condition>
                </transition>
                <transition name="mergeL" priority="1">
                  <defun>
                    <in name="a" type="interval"/>
                    <in name="b" type="interval"/>
                    <out name="s" type="interval"/>
                    <expression>
                      ${s.offset} := ${a.offset}; ${s.size} := ${a.size} + ${b.size}; ${s.used} := 0L;
                    </expression>
                  </defun>
                  <connect-in port="a" place="small_interval"/>
                  <connect-in port="b" place="small_intervals"/>
                  <connect-out port="s" place="pre_empty"/>
                  <condition>
                    ${a.offset} + ${a.size} :eq: ${b.offset}
                  </condition>
                </transition>
                <transition name="no_merge">
                  <use name="select_interval"/>
                  <connect-in port="x" place="small_interval"/>
                  <connect-out port="x" place="small_intervals"/>
                </transition>
              </net>
            </defun>
            <place-map virtual="size_wanted" real="interval_size"/>
            <connect-in port="empty" place="interval_to_merge"/>
            <connect-out port="interval" place="empty_interval"/>
          </transition>
          <transition name="wait">
            <use name="wait_interval"/>
            <place-map virtual="wait" real="wait"/>
            <connect-in port="trigger" place="done_interval"/>
            <connect-out port="done" place="done_update"/>
          </transition>
        </net>
      </defun>
      <place-map virtual="wait" real="wait"/>
      <place-map virtual="config" real="config_read"/>
      <place-map virtual="interval_size" real="interval_size"/>
      <place-map virtual="output" real="output"/>
      <connect-in port="processed_interval" place="processed_interval"/>
      <connect-out port="empty_interval" place="empty_interval"/>
      <connect-out port="done_update" place="done_update"/>
    </transition>
    <transition name="finalize">
      <defun>
        <in name="done" type="control" place="done_update"/>
        <out name="done" type="control" place="done"/>
        <net>
          <place name="config" type="config" virtual="true"/>
          <place name="done_update" type="control"/>
          <place name="done" type="control"/>
          <transition name="finalize">
            <defun>
              <in name="config" type="config"/>
              <in name="done" type="control"/>
              <out name="done" type="control"/>
              <module name="ufbmig" function="done finalize_calc (config)">
                <cinclude href="fhglog/fhglog.hpp"/>
                <code>
                  <![CDATA[
                  LOG (INFO, "FINALIZE " << config);

                  return control();
                ]]>
                </code>
              </module>
            </defun>
            <connect-in port="config" place="config"/>
            <connect-in port="done" place="done_update"/>
            <connect-out port="done" place="done"/>
          </transition>
        </net>
      </defun>
      <place-map virtual="config" real="config_read"/>
      <connect-in port="done" place="done_update"/>
      <connect-out port="done" place="done"/>
    </transition>
  </net>
</defun>
