// mirko.rahn@itwm.fraunhofer.de

#include <xml/parse/includes.hpp>

#include <boost/filesystem/fstream.hpp>
#include <boost/program_options.hpp>

#include <iostream>
#include <iomanip>
#include <fstream>
#include <iterator>
#include <algorithm>
#include <sstream>

#include <fhg/revision.hpp>

using namespace pnetc::includes;

static void dump_quoted (std::ostream & os, const std::string & string)
{
  for ( std::string::const_iterator pos (string.begin())
      ; pos != string.end()
      ; ++pos
      )
    {
      switch (*pos)
        {
        case '"': os << "\\\""; break;
        case '\\': os << "\\\\"; break;
        case '\n': os << "\\n"; break;
        default: os << *pos; break;
        }
    }
}

static void dump (std::ostream& os)
{
  os << "// GPI-Space generated: DO NOT EDIT THIS FILE!"    << std::endl;
  os                                                        << std::endl;
  os << "#ifndef _XML_PARSE_HEADER_LIST_HPP"                << std::endl;
  os << "#define _XML_PARSE_HEADER_LIST_HPP 1"              << std::endl;
  os                                                        << std::endl;
  os << "#include <xml/parse/headergen.hpp>"                << std::endl;
  os                                                        << std::endl;

  os << "// force dependencies"                             << std::endl;

  for ( names_type::const_iterator name (includes().begin())
      ; name != includes().end()
      ; ++name
      )
    {
      os << "#include <" << name->string() << ">"           << std::endl;
    }

  os                                                        << std::endl;

  os << "namespace xml"                                     << std::endl;
  os << "{"                                                 << std::endl;
  os << "  namespace parse"                                 << std::endl;
  os << "  {"                                               << std::endl;
  os << "    namespace includes"                            << std::endl;
  os << "    {"                                             << std::endl;
  os                                                        << std::endl;

  os << "      inline void mks (descrs_type & descrs)"      << std::endl;
  os << "      {"                                           << std::endl;

  for ( names_type::const_iterator name (includes().begin())
      ; name != includes().end()
      ; ++name
      )
    {
      os                                                    << std::endl;
      os << "        {"                                     << std::endl;
      os << "          descr d (\"" << name->string() << "\");"
                                                                   << std::endl;

      boost::filesystem::ifstream file (root() / *name);

      file >> std::noskipws;

      std::istream_iterator<char> begin(file), end;

      std::ostringstream sstr;

      copy (begin, end, std::ostream_iterator<char>(sstr));

      os << "          d.content = \"";

      dump_quoted (os, sstr.str());

      os << "\";"                                           << std::endl;
      os                                                    << std::endl;
      os << "          descrs.push_back (d);"               << std::endl;
      os << "        }"                                     << std::endl;
    }

  os << "      } // mks"                                << std::endl;
  os << "    } // namespace includes"                       << std::endl;
  os << "  } // namespace parse"                            << std::endl;
  os << "} // namespace xml"                                << std::endl;
  os                                                        << std::endl;
  os << "#endif"                                            << std::endl;
}

namespace po = boost::program_options;

int
main (int argc, char** argv)
{
  std::string output ("-");

  po::options_description desc("General");

  desc.add_options()
    ( "help,h", "this message")
    ( "version,V", "print version information")
    ( "output,o"
    , po::value<std::string>(&output)->default_value(output)
    , "output file name, - for stdout, first positional parameter"
    )
    ;

  po::positional_options_description p;
  p.add("output",1);

  po::variables_map vm;

  try
  {
    po::store( po::command_line_parser(argc, argv)
             . options(desc).positional(p)
             . run()
             , vm
             );
    po::notify(vm);
  }
  catch (std::exception const & ex)
  {
    std::cerr << "invalid argument: " << ex.what() << std::endl;
    return EXIT_FAILURE;
  }

  if (vm.count("help"))
    {
      std::cout << argv[0] << std::endl;

      std::cout << desc << std::endl;

      return EXIT_SUCCESS;
    }

  if (vm.count("version"))
    {
      std::cout << fhg::project_info ("Include Generator");

      return EXIT_SUCCESS;
    }

  if (output == "-")
    {
      dump (std::cout);
    }
  else
    {
      std::ofstream os (output.c_str());

      if (not os)
        {
          throw std::runtime_error ("could not open " + output);

          exit (EXIT_FAILURE);
        }

      dump (os);
    }

  return EXIT_SUCCESS;
}
