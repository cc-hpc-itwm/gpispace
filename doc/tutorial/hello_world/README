:doctype: book
:toc:

= `share/gspc/doc/tutorial/hello_world`: Use external libraries in GPI-Space.

== Situation

External libraries are available in form of a header file and an object file. The header either is a `C` header (like in link:include/hello_util.h[] and link:include/hello2.h[]) or a `C++` header (like in link:include/hello_world.hpp[]). Their implementations are available either as `.o` object or `.so` shared object.

== Run `hello_world`

The first step is to build the demonstration libraries by

[source,bash]
----
share/gspc/doc/tutorial/hello_world$ mkdir $HOME/build
share/gspc/doc/tutorial/hello_world$ make BUILDDIR=$HOME/build -C src
share/gspc/doc/tutorial/hello_world$ ls $HOME/build/*.*o
$HOME/build/hello2.o
$HOME/build/hello_world.o
$HOME/build/libhello_util.so
----

Now `hello_world` is started by

[source,bash]
----
share/gspc/doc/tutorial/hello_world$ make BUILDDIR=$HOME/build run
----

The output that is produced contains (near the end) lines like

....
*** Calling 3 versions of hello...*** Calling 3 versions of hello...
*** (CPP) Hello
*** (CPP) Hello World *** (CPP)
World *** (CPP)
*** (C) Hallo*** (C) Hallo Welt *** (C)
*** (LIB) Hola Welt *** (C)
*** (LIB) Hola mundo *** (LIB)
*** ...[done]
 mundo *** (LIB)
*** ...[done]
....

The output also shows the commands that are executed by GPI-Space in order to build the modules that actually connect with the external libraries.

Please find in the folder link:src/[] the implementations that produced this output.

Please note that the output could differ on your system as it actually is the interleaving of two outputs. The easiest way to serialize the execution is to run the demonstration with a single worker only, e.g.

[source,bash]
----
share/gspc/doc/tutorial/hello_world$ make BUILDDIR=$HOME/build WE_EXEC_WORKER=1 run
----

and the output will contain the lines:

....
*** Calling 3 versions of hello...
*** (CPP) Hello World *** (CPP)
*** (C) Hallo Welt *** (C)
*** (LIB) Hola mundo *** (LIB)
*** ...[done]
*** Calling 3 versions of hello...
*** (CPP) Hello World *** (CPP)
*** (C) Hallo Welt *** (C)
*** (LIB) Hola mundo *** (LIB)
*** ...[done]
....

== Connect GPI-Space with external libraries

The connection between GPI-Space and the external libraries is done in link:hello_world.xpnet[]. It contains a standard link:../../user.html#module_call[module call] and the connection with the three implementations is done by the lines

[source,xml]
----
    <cinclude href="hello_world.hpp"/> <!-- cpp library -->
    <link href="hello2.o" prefix="${libdir}/"/>

    <cinclude href="hello2.h"/>        <!-- c library -->
    <link href="hello_world.o" prefix="${libdir}/"/>

    <cinclude href="hello_util.h"/>    <!-- shared object -->
    <ld flag="-lhello_util"/>
----

In all cases the header is included. The location of the header files is specified in the link:Makefile[]:

[source,makefile]
----
CXXINCLUDEPATHS += $(CURDIR)/include
----

For the `.o` objects GPI-Space is told to link with `hello2.o` and `hello_world.o` repectively and the prefix to find them is specified to be `${libdir}/`. The compiler will replace the variable `${libdir}` with a value that is specified in the link:Makefile[]:

[source,makefile]
----
PNETC_LINK_PREFIX += "libdir=$(BUILDDIR)"
----

Please note that above the libraries were produced in the folder`$(BUILDDIR)`. In general the `prefix` allows to write workflows that are independent of the location of the libraries.

The location of the shared object file is specified in the link:Makefile[]:

[source,makefile]
----
CXXLIBRARYPATHS += $(BUILDDIR)
----

Finally, in the `<code>` section of the module call, the implementations be called:

[source,xml]
----
    <code><![CDATA[
      std::cout << "*** Calling 3 versions of hello..." << std::endl;

      impl_hello_world();
      ::hello_world();
      hello_util();

      std::cout << "*** ...[done]" << std::endl;

      return we::type::literal::control();
    ]]></code>
----

Please note that the call of the `C++` version explicitely uses the top level namespace. This is necessary as the content of the `<code>` section is put into the namespace `pnetc::op::hello_world` where `hello_world` ist the name of the module as specified in link:hello_world.xpnet[]:

[source,xml]
----
  <module name="hello_world" function="out call_hello_world (in)">
----

== Call `hello_world` many times

The workflow description in link:hello_many.xpnet[] is a small wrapper that allows to call `hello_world` many times. In the link:Makefile[] there are two control tokens putted on the port `in`:

[source,makefile]
----
PUT_PORT += in=[]
PUT_PORT += in=[]
----

The function `hello_world` is called for each token on the port `in` once.
