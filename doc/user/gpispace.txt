:doctype: book
:toc:

= GPI-Space -- a system to develop and execute cluster applications

== Overview

GPI-Space is a system to develop and execute cluster applications. The
main focus of GPI-Space is to separate communication and coordination.
(see <<gelernter:1992>>)

This manual is written for users that want to implement applications
within GPI-Space.

GPI-Space consists of three main components:

* the distributed runtime system,
* the workflow engine and
* the virtual memory layer.

== Installation

The installation of GPI-Space requires to unpack the distribution file:

[source,bash]
----
$ cd $HOME
$ tar xvzf gspc-<VERSION>.tar.gz
----

and to add `$HOME/gspc-<VERSION>/bin` to the search path, e.g. in case
`bash` is used:

[source,bash]
----
$ export PATH=$HOME/gspc-<VERSION>/bin:$PATH
----

The installation can be tested with

[source,bash]
----
$ gspc selftest
----

When GPI-Space is installed correctly the output will be something
like:

----
GPI-Space selftest started...
test FOO: OKAY
test BAR: OKAY
GPI-Space selftest completed: 0 error(s)
----

== Distributed runtime system

agent, orchestrator, worker, client

image:images/gpi_space_workflow_notext.png[alt="Schematic overview of
development and execution of GPI-Space workflows",align="center",width="75%"]

[source,tex]
----
\put(23,23){Editor}
\put(60,270){\acs{XML}}
\put(260,270){pnetc}
\put(320,395){gen}
\put(320,493){c++}
\put(275,605){modules}
\put(523,633){\ac{DRTS}}
\put(505,435){sdpa submit}
\put(472,270){pnet}
\put(644,270){pnet}
\put(450,50){pnetput}
\put(620,50){pnetget}
\put(833,633){\acs{GUI}}
\put(800,580){Monitoring}
----

=== Start and Stop

The command to start the runtime system is `sdpa boot`. It allows to specify
which kind of workers and how many should be started. The full list of
options is

[source,bash]
----
$ sdpa boot -h
usage: start-sdpa [options]

  -h: this help
  -v: be verbose
  -n: dry run
  -A path: add a path to the list of application search paths
  -f: node file to use
  -S: state directory to use
  -m: amount of gpi memory to use
  -M: disable use of the memory layer
  -s: default amount of shared memory to use (=0)
  -d: do not delete logfiles
  -C: capability specification
  -G: number of segments
  -x: GPI binary to execute
  -k: kvs port (=2439)
  -l: log url (=voyager:38559)
  -g: gui url (=voyager:38560)

        format:
           <CAP>[+CAP1...][#socket][:N[xM][,shm]]

        examples:
           INIT:1x1,0
              exactly *one* INIT worker

           LOAD:2,16*2**20
              2 LOAD worker/node

           WRITE:2x4,16*2**20
              2 WRITE workers/node but on at most 4 nodes

           WRITE+LOAD:2
              2 workers/node with capabilities WRITE *and* LOAD
----

The values in braces are default values that could differ from system to system.

[source,bash]
----
$ sdpa boot
E: nodefile is missing (-f)
----

The `boot` command requires to set a list of hosts to start on, this is done by specifying `-f <file>`.

Typically the list of nodes is stored in an environment variable the depends on the queuing system, e.g. `$PBS_NODEFILE` when `pbs` is used. For testing on a single node it is convenient to create a nodefile like

[source,bash]
----
$ hostname > nodefile
----

[source,bash]
----
$ sdpa boot -f nodefile
E: No virtual memory binary was specified (-x), to disable the virtual memory specify -M
----

TODO: The usage of the virtual memory layer is described else where!?

[source,bash]
----
$ sdpa boot -f nodefile -M
I: using nodefile: /home/rahn/gpispace/doc/user/nodefile
starting base sdpa components on brank...
I: sending log events to: brank:38559
I: sending execution events to: brank:38560
+ fhgkvsd (3327)
Running orchestrator on brank
I: starting agent: agent-brank-0 on host brank with parent orchestrator
Running agent-brank-0 on brank with master orchestrator
----

TODO: The lines have three different prefixes.

The status of the runtime system is examined with

[source,bash]
----
$ sdpa status
gpi is dead
process container (all nodes)
    brank
drts is dead
----

TODO: The status output is useless.

The following runs the example `sum` from the tutorial

[source,bash]
----
gpispace/doc/tutorial/sum$ make -C src
gpispace/doc/tutorial/sum$ make DESTDIR=$PWD install
gpispace/doc/tutorial/sum$ hostname > nodefile
gpispace/doc/tutorial/sum$ sdpa boot -f nodefile -M -A $PWD/modules work:1
gpispace/doc/tutorial/sum$ make submit
gpispace/doc/tutorial/sum$ pnetget -i sum_many.out
on 0: 7L
on 0: 1L
----

TODO: Explain all the many steps that are required here!

TODO: The same does not work for `hello_world`: `error-message := Module call failed: call to 'hello_world::call_hello_world' failed: could not load module '/home/rahn/gpispace/doc/tutorial/hello_world/modules/libhello_world.so': libhello_util.so: cannot open shared object file: No such file or directory`

The runtime system can be stopped by

[source,bash]
----
$ sdpa stop
process container (all nodes)
    brank
agent (all nodes)
    brank
orchestrator
    sending SIGTERM to orchestrator (3381)....ok
gpi
fhgkvsd
    sending SIGTERM to fhgkvsd (3327)....ok
----

TODO: The number for orchestrator makes no sense to the user.

=== Observe, Gantt-Viewer, (gspcmon?)
.

=== Advanced: fhglog*
.

=== Advanced: kvs
.

=== Advanced: fhgcfg
.

=== Advanced: gspc*
.

== Workflows

=== Small example (predefined)
=== Submit
=== Extract results
=== Workflow description language

every workflow is a function with inputs and outputs, which are named ports.
every function is either a small expression, a net (sub-workflow), or
a c++ module call.
typed, tokens in nets on places, consumed and produced by
transitions. behavior of transitions defined by functions,
i.e. workflows again.

small workflow, being a module call below:
[[module_call]]

[source,xml]
----
<defun> <!-- <1> -->
  <in name="in" type="string"/> <!-- <2> -->
  <out name="out" type="string"/>

  <module name="hello" function="out assemble (in)"> <!-- <3> -->
    <cinclude href="hello_world.hpp"/> <!-- <5> -->
    <link href="hello_world.o"/>
    <code> <!-- <4> -->
      <![CDATA[ return hello_world::greet (in); ]]>
    </code>
  </module>
</defun>
----

<1> Top level function of the workflow.
<2> Inputs and outputs of the function.
<3> The function is implemented as a call to a C++ module.
<4> C++ code can be inlined into a module.
<5> Compilation flags for the module may be given. In this case: a
legacy library.

==== Place, Token, Transition, Port

Including legacy/external code is important, but obviously not the
thing to do at top level of a workflow. In GPI-Space, workflows are
based on Petri nets. Petri nets consist of places and transitions
where transitions represent module calls/algorithms/functions.
Places can be compared to checkpoints with intermediate results, which
again may be inputs to other transitions. Transitions and places are
connected by directed edges.  Data is represented by tokens which are
stored on places and may be consumed by transitions.

Transitions may only consume tokens if there is one for every
connected input and will produce exactly one new token on each
outwards-connected place. If there is more than one token on a
connected place, which token is consumed will be random. Each
transition is defined as a sub-workflow, thus contains a function as
defined above, which may be given in-line or in an included file.

In addition to the basic concepts of Petri nets, GPI-Space uses
"colored" tokens, meaning that every token, place and port has a type
and connections may only be made between places and ports of the same
type. Being typed, tokens also have a value which may be read and
modified by a transition.

[source,xml]
----
<place name="value" type="long"> <!-- <1> -->
  <token><value>3L</value></token>
</place>
<place name="square_of_value" type="long"/> <!-- <2> -->

<transition name="square"> <!-- <3> -->
  <include-function href="square.xpnet"> <!-- <4> -->
  <connect-in port="x" place="value"/> <!-- <5> -->
  <connect-out port="square" place="square_of_value"/>
</transition>
----

<1> A place of type `long` with the name `value`, containing a token with value `3L`.
<2> A second place of type `long` with no token on it.
<3> A transition with name `square`.
<4> The transition `square` includes a workflow, defined in
`square.xpnet`. Alternatively, the sub-workflow may be defined
in-line.
<5> Place `value` is inbound-connected to the functions port `x`. The
output produced on port `square` is put onto place `square_of_value`.

==== Type

As tokens, places and ports are typed, user defined types are required
in addition to the already existing built-in types. User defined types
are a structure of named fields of built-in or other user defined
types and may be defined within any function (`<defun>`) or net (`<net>`).

[source,xml]
----
<defun name="2d_geometry">
  <struct name="point2d">
    <field name="x" type="double"/>
    <field name="y" type="double"/>
  </struct>
  <struct name="rect2d">
    <field name="position" type="point2d"/>
    <field name="width" type="double"/>
    <field name="height" type="double"/>
  </struct>
  <!-- … -->
</defun>
----

Built-in types include `control` (an empty token), `bool`, `int`,
`long`, `unsigned int` and `unsigned long`, `float` and `double`, but
also more complex type like `string`, `bitset`, `bytearray`, `list`,
`set` or `map`. For a full list of available types, their attributes,
behavior and functions, see
<<section:reference_builtintypes>>. Generic built-in types
(e.g. collections like `list`) can be parameterized using `Type : U`
(e.g. `List : rect2d`).

==== Simple networks
==== Expressions

The third type of a function besides module calls and sub-nets are
expressions. Expressions are a light-weight alternative to module
calls if modification or construction of token is based on the input only, without having any side effects. The expression
language is small, but powerful and a lot faster than calling native
code.

The expression in
[source,xml]
----
<defun name="get_top_of_stack">
  <inout name="stack" type="Stack : long"/> <!-- stack of longs -->
  <out name="value" type="long"/>
  <expression>
    ${value} := stack_top (${stack});
    ${stack} := stack_pop (${stack}); /* stack_pop does not modify
                                         given stack, but returns
                                         the modified stack! */
  </expression>
</defun>
----
is equivalent to the module call
[source,xml]
----
<module name="stack_mod" function="value top_and_pop (stack)">
  <code><![CDATA[
    long value const (stack.top());
    stack.pop();
    return value;
  ]]></code>
</module>
----

For a full reference of language syntax as well as available
functions, see <<section:reference_expression>>.

NOTE: All functions provided do not modify the given variable but
return a modified copy, i.e. all functions are pass-by-value, not
pass-by-reference.

==== Conditions

To further control, if a transition is activated, use conditions to
let activation of a transition depend on the value of the
input token(s). Conditions are boolean expressions that are evaluated until an
activating combination of input tokens is found, that is a combination
that evaluates to `true`.

For example, the transition `collatz_even`

[source,xml]
----
<transition name="collatz_even">
  <defun>
    <in name="a" type="unsigned long"/>
    <out name="f" type="unsigned long"/>
    <expression>
      ${f} := ${a} div 2UL
    </expression>
    <condition>
      ${a} mod 2UL :eq: 0UL
    </condition>
  </defun>
  <connect-in port="a" place="a"/>
  <connect-out port="f" place="f"/>
</transition>
----

is activated only for even values on place `a`.

NOTE: Let 'T' be a transition with input places 'p~1~,...,p~n~' and
let 'k~i~' be the number of tokens on the place 'p~i~'. Let 'c' be the
condition attached to 'T'. Then 'c' gets evaluated at most
'k~1~ · k~2~ ·...· k~n~' times, that is the product of the number of
tokens on each input place.

Conditions can be attached either to transitions or to functions. The
code above is equivalent to

[source,xml]
----
<defun name="half">
  <in name="a" type="unsigned long"/>
  <out name="f" type="unsigned long"/>
  <expression>
    ${f} := ${a} div 2UL
  </expression>
</defun>

<transition name="collatz_even">
  <use name="half"/>
  <condition>
    ${a} mod 2UL :eq: 0UL
  </condition>
  <connect-in port="a" place="a"/>
  <connect-out port="f" place="f"/>
</transition>
----

==== Hierarchies
==== External modules
==== Advanced: Virtual Places
==== Advanced: Templates
==== Advanced: Make
==== Advanced: Verify (pnetv)

=== Compile, pnetc
==== Wrapper

=== Display, pnet2dot
=== Big example (superbinning)
=== Library
=== Editor
=== Advanced: Execute (we-exec)
=== Advanced: Debugging

== Virtual memory
=== Start and Stop
=== Interface
=== Example
=== Advanced: gpish

== Reference

Detailed, technical reference of different formats used in gspc.

=== Petri-net Structure

equals xsd | pnet/src/xml/parse/parser.cpp,
[graphviz]
----
include::../intern/xml_internal_structure.dot[]
----
=== Expression Language Syntax
[[section:reference_expression]]
[[section:reference_builtintypes]]

grammar, available types, functions, associativity, equals pnet/src/we/expr/, pnet/src/we/type/

=== gspcmon Protocol

grammar, line based, messages. equals editor/src/pnete/ui/gspc_monitor_client.cpp

== Literature and links

[bibliography]
.Articles
- [[[gelernter:1992]]] D. Gelernter, N. Carriero: 'Coordination
languages and their significance.'  Commun. ACM 35(2), 1992.

== Glossary

DRTS:: Distributed runtime system.

Place:: In a Petri net: Placeholder for meta data, drawn as a
  circle. Each place has a type and cannot contain token of another
  type.

Token:: In a Petri net: The representation of meta data, typically
  drawn as a small circle. The meta data has a type.

Transition:: In a Petri net: Placeholder for an action, drawn as a
   rectangle. If all input places contain at least one token, then the
   transition is 'enabled' and can 'fire'. A transition that fires
   consumes one token from each input place and produces one token on
   each output place.

Petri net:: A bipartite directed graph. The members of the two node
  sets are called places and transitions.
