<defun>

  <in name="empty" type="interval" place="pre_empty"/>
  <out name="interval" type="interval" place="interval"/>
  <tunnel name="size_wanted" type="long" place="size_wanted"/>

  <net>

    <template name="select">
      <template-parameter type="T"/>
      <defun>
        <in name="x" type="T"/>
        <out name="x" type="T"/>
        <expression/>
      </defun>
    </template>

    <specialize name="select_interval" use="select">
      <type-map replace="T" with="interval"/>
    </specialize>

    <place name="pre_empty" type="interval"/>
    <place name="size_wanted" type="long" virtual="true"/>
    <place name="interval" type="interval"/>

    <place name="empty_interval" type="interval"/>
    <place name="credit_empty_interval" type="control">
      <token><value>[]</value></token>
    </place>

    <include-template href="lib/trigger_if.xml"/>
    <specialize name="select_interval_get_credit" use="trigger_if">
      <type-map replace="T" with="interval"/>
    </specialize>

    <include-template href="lib/trigger_when.xml"/>
    <specialize name="select_interval_put_credit" use="trigger_when">
      <type-map replace="T" with="interval"/>
    </specialize>

    <transition name="select_empty_interval">
      <use name="select_interval_get_credit"/>
      <connect-in port="object" place="pre_empty"/>
      <connect-out port="object" place="empty_interval"/>
      <connect-in port="trigger" place="credit_empty_interval"/>
    </transition>

    <transition name="interval_size_okay">
      <defun>
        <in name="size_wanted" type="long"/>
        <in name="interval" type="interval"/>
        <out name="interval" type="interval"/>
        <out name="credit_empty_interval" type="control"/>
        <expression>
          ${credit_empty_interval} := []
        </expression>
      </defun>
      <condition>
        ${interval.size} :eq: ${size_wanted}
      </condition>
      <connect-read port="size_wanted" place="size_wanted"/>
      <connect-in port="interval" place="empty_interval"/>
      <connect-out port="interval" place="interval"/>
      <connect-out port="credit_empty_interval" place="credit_empty_interval"/>
    </transition>

    <transition name="interval_to_small">
      <defun>
        <in name="size_wanted" type="long"/>
        <in name="interval" type="interval"/>
        <out name="interval" type="interval"/>
        <out name="credit_empty_interval" type="control"/>
        <expression>
          ${credit_empty_interval} := []
        </expression>
      </defun>
      <condition>
        ${interval.size} :lt: ${size_wanted}
      </condition>
      <connect-read port="size_wanted" place="size_wanted"/>
      <connect-in port="interval" place="empty_interval"/>
      <connect-out port="interval" place="pre_small_interval"/>
      <connect-out port="credit_empty_interval" place="credit_empty_interval"/>
    </transition>

    <place name="small_interval" type="interval"/>
    <place name="credit_small_interval" type="control">
      <token><value>[]</value></token>
    </place>
    <place name="pre_small_interval" type="interval"/>

    <transition name="interval_to_big">
      <defun>
        <in name="size_wanted" type="long"/>
        <in name="interval" type="interval"/>
        <out name="rest" type="interval"/>
        <out name="interval" type="interval"/>
        <out name="credit_empty_interval" type="control"/>
        <expression>
          ${rest.offset} := ${interval.offset} + ${size_wanted};
          ${rest.size} := ${interval.size} - ${size_wanted};
          ${rest.used} := 0L;
          ${interval.size} := ${size_wanted};
          ${credit_empty_interval} := []
        </expression>
      </defun>
      <condition>
        ${interval.size} :gt: ${size_wanted}
      </condition>
      <connect-read port="size_wanted" place="size_wanted"/>
      <connect-in port="interval" place="empty_interval"/>
      <connect-out port="interval" place="interval"/>
      <connect-out port="rest" place="pre_empty"/>
      <connect-out port="credit_empty_interval" place="credit_empty_interval"/>
    </transition>

    <transition name="select_small_interval">
      <defun>
        <in name="trigger" type="control"/>
        <inout name="interval" type="interval"/>
        <out name="num" type="long"/>
        <expression>
          ${num} := 0L;
        </expression>
      </defun>
      <connect-in port="trigger" place="credit_small_interval"/>
      <connect-in port="interval" place="pre_small_interval"/>
      <connect-out port="interval" place="small_interval"/>
      <connect-out port="num" place="num_tested"/>
    </transition>

    <place name="num_tested" type="long"/>

    <transition name="mergeR">
      <defun>
        <in name="a" type="interval"/>
        <in name="b" type="interval"/>
        <out name="s" type="interval"/>
        <inout name="num_intervals" type="long"/>
        <out name="trigger_return" type="control"/>
        <expression>
          ${s.offset} := ${b.offset};
          ${s.size} := ${a.size} + ${b.size};
          ${s.used} := 0L;
          ${num_intervals} := ${num_intervals} - 1L;
          ${trigger_return} := []
        </expression>
      </defun>
      <condition>
        ${b.offset} + ${b.size} :eq: ${a.offset}
      </condition>
      <connect-in port="a" place="small_interval"/>
      <connect-in port="b" place="small_intervals"/>
      <connect-out port="s" place="pre_empty"/>
      <connect-inout port="num_intervals" place="num_small_intervals"/>
      <connect-out port="trigger_return" place="trigger_return"/>
    </transition>
    <transition name="mergeL">
      <defun>
        <in name="a" type="interval"/>
        <in name="b" type="interval"/>
        <out name="s" type="interval"/>
        <inout name="num_intervals" type="long"/>
        <out name="trigger_return" type="control"/>
        <expression>
          ${s.offset} := ${a.offset};
          ${s.size} := ${a.size} + ${b.size};
          ${s.used} := 0L;
          ${num_intervals} := ${num_intervals} - 1L;
          ${trigger_return} := []
        </expression>
      </defun>
      <condition>
        ${a.offset} + ${a.size} :eq: ${b.offset}
      </condition>
      <connect-in port="a" place="small_interval"/>
      <connect-in port="b" place="small_intervals"/>
      <connect-out port="s" place="pre_empty"/>
      <connect-inout port="num_intervals" place="num_small_intervals"/>
      <connect-out port="trigger_return" place="trigger_return"/>
    </transition>
    <transition name="no_merge">
      <defun>
        <in name="a" type="interval"/>
        <inout name="b" type="interval"/>
        <inout name="num" type="long"/>
        <expression>
          ${num} := ${num} + 1L;
        </expression>
      </defun>
      <condition>
        ${a.offset} + ${a.size} :ne: ${b.offset}
      </condition>
      <condition>
        ${b.offset} + ${b.size} :ne: ${a.offset}
      </condition>
      <connect-read port="a" place="small_interval"/>
      <connect-in port="b" place="small_intervals"/>
      <connect-out port="b" place="tested"/>
      <connect-inout port="num" place="num_tested"/>
    </transition>

    <transition name="all_tested">
      <defun>
        <inout name="interval" type="interval"/>
        <in name="num_tested" type="long"/>
        <inout name="num_intervals" type="long"/>
        <out name="trigger" type="control"/>
        <expression>
          ${num_intervals} := ${num_intervals} + 1L;
          ${trigger} := [];
        </expression>
        <condition>
          ${num_tested} :eq: ${num_intervals}
        </condition>
      </defun>
      <connect-read port="num_tested" place="num_tested"/>
      <connect-inout port="num_intervals" place="num_small_intervals"/>
      <connect-out port="trigger" place="trigger_return"/>
      <connect-in port="interval" place="small_interval"/>
      <connect-out port="interval" place="small_intervals"/>
    </transition>

    <place name="trigger_return" type="control"/>

    <transition name="return">
      <defun>
        <inout name="num" type="long"/>
        <in name="trigger" type="control"/>
        <inout name="interval" type="interval"/>
        <expression>
          ${num} := ${num} - 1L;
        </expression>
      </defun>
      <connect-inout port="num" place="num_tested"/>
      <connect-read port="trigger" place="trigger_return"/>
      <connect-in port="interval" place="tested"/>
      <connect-out port="interval" place="small_intervals"/>
    </transition>

    <transition name="done_return">
      <defun>
        <inout name="trigger" type="control"/>
        <in name="num" type="long"/>
        <expression/>
        <condition>
          ${num} :eq: 0L
        </condition>
      </defun>
      <connect-in port="trigger" place="trigger_return"/>
      <connect-out port="trigger" place="credit_small_interval"/>
      <connect-in port="num" place="num_tested"/>
    </transition>

    <place name="small_intervals" type="interval"/>
    <place name="num_small_intervals" type="long">
      <token><value>0L</value></token>
    </place>

    <place name="tested" type="interval"/>
  </net>

</defun>
