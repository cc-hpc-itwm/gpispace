#!/bin/bash
#
# usage: sdpa {start|stop|status|submit file}
#

# increment this value if anything config related changes!
CONFIG_VERSION=10

config_file=${SDPA_CONFIG:="$HOME/.sdpa/configs/sdpa.rc"}
state_dir=${SDPA_STATE_DIR:="$HOME/.sdpa/state"}
debug_enabled=false

function log ()
{
    echo "$@" >&2
}

function debug ()
{
    if [ x"$debug_enabled" == x"true" ] ; then
        log $@
    fi
}

function prepend_to_path ()
{
    local var="$1"; shift
    local val=$(eval echo \$${var})
    for v ; do
        if [ -z "$v" ] ; then
            continue
        fi
        val=$(echo "$val" | sed "s,:$v:,:,g")
        val=$(echo "$val" | sed -e "s,^$v:,,g")
        val=$(echo "$val" | sed -e "s,:$v\$,,g")
        if [ -z "$val" ] ; then
            val="$v"
        else
            val="$v:$val"
        fi
    done
    eval "$var=$val"
}

##############################################
#                                            #
#      Default configuration section         #
#                                            #
##############################################

#
# cluster related
#
DEFAULT_CLUSTER_HEAD="" # if needed

#
# SDPA
#
DEFAULT_STATEFUL_EXECUTION="false"
DEFAULT_SCRATCH_DIR="$HOME/.sdpa/scratch"
DEFAULT_TMP_DIR="/var/tmp"
DEFAULT_WORKER_PER_NODE="1"
DEFAULT_WITH_MEDIATOR="false"

DEFAULT_LOG_PORT="$(( (65535 - 30000 + $(id -u) * 2) % 65535 + 1024 + 0))"
DEFAULT_GUI_PORT="$(( (65535 - 30000 + $(id -u) * 2) % 65535 + 1024 + 1))"
DEFAULT_KVS_PORT=2439
DEFAULT_LOGD_PORT=3456
DEFAULT_LOG_URL=""
DEFAULT_GUI_URL=""

#
# GPI
#
DEFAULT_GPI_PRIV_DIR=""
DEFAULT_GPI_ENABLED="false"
DEFAULT_GPI_MEMSIZE="5G"
DEFAULT_GPI_SHMSIZE="1G"
DEFAULT_GPI_COMSIZE="16M"
DEFAULT_GPI_API="gpi.api.real"

#
# plugins
#
DEFAULT_KERNEL_LOAD_LAZY="true"
DEFAULT_PLUGIN_GPI_STARTMODE="nowait"
DEFAULT_PLUGIN_DRTS_BACKLOG="1"
DEFAULT_PLUGIN_DRTS_MAX_RECONNECT="128"

#
# override defaults by:
#
#     1. /etc/sdpa/defaults
#     2. /usr/local/etc/sdpa/defaults
#     3. $SDPA_HOME/etc/sdpa/defaults
#     4. $HOME/.sdpa.defaults
#

for system_default in "/etc/sdpa/defaults"               \
                      "/usr/etc/sdpa/defaults"           \
                      "/usr/local/etc/sdpa/defaults"     \
                      "${SDPA_HOME}/etc/sdpa/defaults"   \
                      "${SDPA_SYSTEM_DEFAULTS}"          \
                      ~/.sdpa.defaults                   ; do
    if [ -r "$system_default" ] ; then
        debug "reading system default from: '$system_default'" >&2
        source "$system_default"
    fi
done

#
# if SDPA_HOME is still empty, try to guess it
#
if [ -z "$SDPA_HOME" ] ; then
    export SDPA_HOME=$(dirname $(dirname $(which "$0")))
    export SDPA_LIBEXEC="${SDPA_HOME}/libexec/sdpa"
    prepend_to_path PATH "$SDPA_HOME/bin"
fi

export SDPA_SCRIPT_DIR="$SDPA_LIBEXEC/scripts"
prepend_to_path PATH "$SDPA_SCRIPT_DIR"

##############################################
#                                            #
#  F U N C T I O N    D E F I N I T I O N S  #
#                                            #
##############################################

function require()
{
    local tool="$1"; shift
    if [ -z "$tool" ] ; then
        return 2
    fi

    tool_bin=$(which "$tool" 2>/dev/null)
    if [ -z "$tool_bin" ] ; then
        tool_bin="$SDPA_HOME/bin/$tool"
    fi

    if [ ! -x "$tool_bin" ] ; then
        echo "Could not locate required tool $tool" >&2
        return 1
    fi
    eval "$tool=$tool_bin"
    return 0
}

if ! require fhgcfg ; then
    exit 1
fi

if ! require fhglogc ; then
    exit 1
fi

function log_helper ()
{
    local fn="$1"; shift
    local ln="$1"; shift
    local file="$0"

    echo "$file:$ln - $@" >&2
    if [ -n "$fhglogc" ] ; then
        ${fhglogc} -L "$ln" -F "$file" -p 2 -m "$@"
    fi
}

do_log="eval log_helper \"\$FUNCNAME\" \"\$LINENO\""

function get ()
{
    local key="$1"; shift
    local def="$1"; shift

    ${fhgcfg} -f "$config_file" -g "$key" -v "$def"
}

function put ()
{
    local key="$1"; shift
    local val="$1"; shift

    ${fhgcfg} -f "$config_file" -a "$key" -v "$val"
    log "-: set $key to '$val'"
}

function rexec ()
{
    gspc rexec "${@}"
}

function guess_head_node ()
{
    if [ -n "${DEFAULT_CLUSTER_HEAD}" ] ; then
        echo "${DEFAULT_CLUSTER_HEAD}"
    elif [ -n "$PBS_O_HOST" ] ; then
        echo "$PBS_O_HOST"
    else
        echo "$(hostname -f)"
    fi
}

function isatty()
{
    local f="$1" ; shift
    f=$(readlink -f "$f")
    if [ -e "$f" ] ; then
        tty -s < "$f" >/dev/null 2>&1
        return $?
    else
        return 1
    fi
}

function is_unattended ()
{
    if [ -n "$SDPA_PERFORM_UNATTENDED_SETUP" ] ; then
        return 0
    fi

    if ! isatty /dev/stdin ; then
        return 0
    fi

    return 1
}

#
# check, if we have to start the setup routine
#
function setup_required ()
{
    if ! test -e "$config_file" ; then
        mkdir -p $(dirname "$config_file") 2>/dev/null
        touch "$config_file"
        return 0
    fi
    local cfg_version=$( get "config.version" "0" )
    if test "$cfg_version" -lt "$CONFIG_VERSION" ; then
        log "W: config is outdated"
        log "W: found version: $cfg_version, will generate: $CONFIG_VERSION"
        return 0
    elif test "$cfg_version" -gt "$CONFIG_VERSION" ; then
        log "W: your config was generated by a newer version of SDPA"
        log "W: found version: $cfg_version, would generate: $CONFIG_VERSION"
        log "W: this could lead to funny effects"
    fi
    return 1
}

function setup_state ()
{
    local sdpa_home="$SDPA_HOME"
    if [ -z "$sdpa_home" ] ; then
        mydir=$(cd $(dirname $( which $0 )) && pwd)
        sdpa_home=$(dirname "$mydir")
    fi
    get_user_input "SDPA installation directory [$sdpa_home]:" sdpa_home

    export SDPA_HOME="$sdpa_home"

    local p_stateful=$(get "sdpa.stateful" "${DEFAULT_STATEFUL_EXECUTION:?}")
    if [ x"$p_stateful" = x"true" ] ; then
        y_n_p "Do you want stateful execution? [Y/n] "
    else
        y_n_p "Do you want stateful execution? [y/N] "
    fi
    local ec=$?
    if [ $ec -eq 0 ] ; then
        p_stateful="true"
    elif [ $ec -eq 1 ] ; then
        p_stateful="false"
    fi

    case "$p_stateful" in
        true)
            put "sdpa.stateful" "true"
            ;;
        false)
            put "sdpa.stateful" "false"
            ;;
        *)
            log "E: sdpa.stateful must be one of true/false"
            return 1
            ;;
    esac

    return 0
}

function setup_kvs ()
{
    put "plugin.kvs.port" $(get "plugin.kvs.port" "${DEFAULT_KVS_PORT:?}")

    log "I: kvs setup"

    return 0
}

function y_n_p ()
{
    local prompt="$1" ; shift

    if is_unattended ; then
        return 2
    fi

    read -n 1 -p "$prompt" yes_or_no
    case "$yes_or_no" in
        y|Y)
            echo
            return 0
            ;;
        n|N)
            echo
            return 1
            ;;
        ?)
            echo
            return 2
            ;;
        *)
            return 2
            ;;
    esac
}

function append_to_path ()
{
    local var="$1"; shift
    local val=$(eval echo \$${var})
    for v ; do
        if ! echo "$val" | grep -q -- "$v" ; then
            val="$val:$v"
        fi
    done
    eval "$var=$val"
}

function get_user_input ()
{
    local prompt="$1"; shift
    local var="$1"; shift
    local doc="$1"; shift
    if [ -n "$doc" ] ; then
        cat <<EOF
$doc
EOF
    fi
    if is_unattended ; then
        return
    fi

    read -e -p "  $prompt " new_val
    if [ -n "$new_val" ] ; then
        new_val=$(eval echo "$new_val")
        eval "$var=$new_val"
    fi
}

function setup_scratch ()
{
    local doc='

                 ================================
                 *       Scratch directory      *
                 ================================

The "scratch"  directory should be a directory  you are allowed to  write to and
that is shared among all nodes.
'

    local scratch_dir=$(get "sdpa.scratch_dir" "${DEFAULT_SCRATCH_DIR:?}")
    get_user_input "scratch directory to use [$scratch_dir]:" scratch_dir "$doc"

    if ! test -d "$scratch_dir" ; then
        if ! mkdir -p "$scratch_dir" ; then
            log "E: failed to create scratch directory: $scratch_dir"
            return 1
        fi
    fi

    put "sdpa.scratch_dir" "$scratch_dir"
}

function setup_logging ()
{
    local doc='

                 ================================
                 *     Logging Configuration    *
                 ================================

This "host:port" definition  defines where all the components  send log messages
to. It should be on the same host that you run the GUI on.
'
    def_log_server_url="${DEFAULT_LOG_URL}"
    if [ -z "${DEFAULT_LOG_URL}" ] ; then
        def_log_server_url="$(guess_head_node):${DEFAULT_LOG_PORT:?}"
    fi

    local url=$(get "log.server.url" "${def_log_server_url}")
    local prompt="remote logging to (host:port) [$url]:"
    get_user_input "$prompt" url "$doc"

    local lvl=$(get "log.server.level" "INFO")
    local prompt="log level [$lvl]:"
    get_user_input "log level to use [$lvl]:" lvl ""
    lvl=$( echo "$lvl" | tr 'a-z' 'A-Z' )

    put "log.server.url" "$url"
    put "log.server.level" "$lvl"
    put "plugin.logd.port" "${DEFAULT_LOGD_PORT:?}"
}

function setup_temp ()
{
    local doc='

                 ================================
                 *     Node local directory     *
                 ================================

This  directory  should point  to  a  path that  is  local  to  each node,  like
/var/tmp. It is used to create local temporary files that might be necessary for
some components.
'
    local key="sdpa.temp_dir"
    local val=$(get "$key" "${DEFAULT_TMP_DIR:?}")
    local prompt="temporary directory to use [$val]:"
    get_user_input "$prompt" val "$doc"

    if ! test -d "$val" ; then
        if ! mkdir -p "$val" ; then
            log "E: failed to create temporary directory: $val"
            return 1
        fi
    fi

    put "$key" "$val"
}

function setup_gui ()
{
    local doc='

                 ================================
                 *   Graphical User Interface   *
                 ================================

Now I need a "host:port" string on which the graphical monitor interface will be
running.  It  does not  have to run  all the  time, but if  you want  to monitor
activities, I need to know that location. Please make sure that nobody else uses
this location.
'
    def_gui_server_url="${DEFAULT_GUI_URL}"
    if [ -z "${DEFAULT_GUI_URL}" ] ; then
        def_gui_server_url="$(guess_head_node):${DEFAULT_GUI_PORT:?}"
    fi

    local key="sdpa.gui"
    local val=$(get "$key" "${def_gui_server_url}")
    local prompt="location of the monitor gui (host:port) [$val]:"
    get_user_input "$prompt" val "$doc"
    put "$key" "$val"
}

function setup_plugins ()
{
    cat <<EOF

Setting up plugins....
EOF

    local mod_dir="$HOME/.sdpa/modules"
    if ! test -d "$mod_dir" ; then
        if ! mkdir -p "$mod_dir" ; then
            log "E: failed to create modules directory: $mod_dir"
            return 1
        fi
    fi
    local plugin_dir="$HOME/.sdpa/plugins"
    if ! test -d "$plugin_dir" ; then
        if ! mkdir -p "$plugin_dir" ; then
            log "E: failed to create plugin directory: $plugin_dir"
            return 1
        fi
    fi

    local prefix="$SDPA_HOME"
    if [ -z "$prefix" ] ; then
        log "E: SDPA_HOME is not defined!"
        return 1
    fi

    log "-: setting up the DRTS"
    put "kernel.plugins" "logc,gui,kvs,progress,wfe,gpi,gpi_compat,drts"
    put "kernel.lazy" $(get "kernel.lazy" "${DEFAULT_KERNEL_LOAD_LAZY:?}")

    log "-: configuring plugins"
    put "plugin.gpi.startmode" $(get "plugin.gpi.startmode" "${DEFAULT_PLUGIN_GPI_STARTMODE:?}")
    put "plugin.drts.backlog" $(get "plugin.drts.backlog" "${DEFAULT_PLUGIN_DRTS_BACKLOG:?}")
    put "plugin.drts.max_reconnect_attempts" $(get "plugin.drts.max_reconnect_attempts" "${DEFAULT_PLUGIN_DRTS_MAX_RECONNECT:?}")
}

function setup_topology ()
{
    local doc='

                 ================================
                 *    Topology Configuration    *
                 ================================

This step asks  you some questions about the topology that  will be setup during
the start routine.

If you decide to run a mediator on each node, I will start a separate process on
every node that  takes care of the worker processes on  that node. Otherwise all
workers will be attached to a single master.

The number  of workers on each  node can either be  set to a fixed  number or to
zero. In case of a zero, I will start as many workers as there are processors.
'
    echo "$doc"

    local p_with_mediator=$(get "topology.with-mediator" "${DEFAULT_WITH_MEDIATOR:?}")
    if [ x"$p_with_mediator" = x"true" ] ; then
        y_n_p "Do you want to use a per-node mediator? [Y/n] "
    else
        y_n_p "Do you want to use a per-node mediator? [y/N] "
    fi
    local ec=$?
    if [ $ec -eq 0 ] ; then
        p_with_mediator=true
    elif [ $ec -eq 1 ] ; then
        p_with_mediator=false
    fi

    case "$p_with_mediator" in
        true)
            put "topology.with-mediator" "true"
            ;;
        false)
            put "topology.with-mediator" "false"
            ;;
        *)
            log "E: per-node mediator must be one of true/false"
            return 1
            ;;
    esac

    local key="topology.per-node"
    local val=$(get "$key" "${DEFAULT_WORKER_PER_NODE:?}")
    local prompt="How many workers shall I start on each node? [$val]:"
    get_user_input "$prompt" val ""
    sanity_val=$(( val + 0 ))
    put "$key" "$sanity_val"
}

function parse_human_readable_size ()
{
    local size_value="$1"; shift
    local var="$1"; shift
    size_value=$( echo "$size_value" | tr 'a-z' 'A-Z' )
    size_value=$( echo "$size_value" | sed -e 's/E$/*1024T/' )
    size_value=$( echo "$size_value" | sed -e 's/T$/*1024G/' )
    size_value=$( echo "$size_value" | sed -e 's/G$/*1024M/' )
    size_value=$( echo "$size_value" | sed -e 's/M$/*1024K/' )
    size_value=$( echo "$size_value" | sed -e 's/K$/*1024B/'  )
    size_value=$( echo "$size_value" | sed -e 's/B$/*1/'  )

    # compute the total and round to an integer
    size_value=$( echo "$size_value" | bc | xargs printf "%1.0f" )
    if [ -n "$var" ] ; then
        eval "$var=$size_value"
    else
        echo "$size_value"
    fi
}

function to_human_readable_size ()
{
    local size_value="$1"; shift
    local var="$1"; shift

    local new_val="1"
    local tmp=$( echo "$size_value > 1024" | bc )
    while test "$tmp" == "1" ; do
        new_val="$new_val*1024"
        size_value=$( echo "scale=2; $size_value/1024.0" | bc )
        tmp=$( echo "$size_value > 1024" | bc )
    done

    new_val=$( echo "$new_val" | sed -e 's/*1024$/K/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024K$/M/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024M$/G/' )
    new_val=$( echo "$new_val" | sed -e 's/*1024G$/T/' )
    new_val=$( echo "$new_val" | sed -e 's/^1//')

    new_val="${size_value}${new_val}"
    if [ -n "$var" ] ; then
        eval "$var=$new_val"
    else
        echo "$new_val"
    fi
}

function setup_gpi ()
{
    local doc='

                 ================================
                 *        Fraunhofer GPI        *
                 ================================

This step configures  the GPI part of  the SDPA.  I will ask  for the privileged
directory from which user binaries are  allowed to be executed (the -p parameter
to the  gpid.exe). Additionally I will  ask for the  amount of GPI memory  to be
used on each node.

On  each   node,  so  called  process-containers  (worker   processes)  will  be
started.   Those  need   a  bit   of  memory   to  communicate   with   the  GPI
process. Depending on  how many workers you are planning to  use, you might have
to adjust the amount.

'
    echo "$doc"

    local p_gpi_enabled=$(get "gpi.enabled" "${DEFAULT_GPI_ENABLED:?}")
    if [ x"$p_gpi_enabled" = x"true" ] ; then
        y_n_p "Do you want to enable GPI? [Y/n] "
    else
        y_n_p "Do you want to enable GPI? [y/N] "
    fi
    local ec=$?
    if [ $ec -eq 0 ] ; then
        p_gpi_enabled="true"
    elif [ $ec -eq 1 ] ; then
        p_gpi_enabled="false"
    fi

    case "$p_gpi_enabled" in
        true)
            put "gpi.enabled" "true"
            ;;
        false)
            put "gpi.enabled" "false"
            ;;
        *)
            log "E: gpi.enabled must be one of true/false"
            return 1
            ;;
    esac

    if [ "$p_gpi_enabled" = "false" ] ; then
        log "I: GPI support has been disabled."
        log "I: to activate it, run 'sdpa setup gpi'"
        return
    fi

    local gpid_pid=""
    local gpid_dir="$DEFAULT_GPI_PRIV_DIR"

    if [ -z "$DEFAULT_GPI_PRIV_DIR" ] ; then
        for gpi_prog in "gpid.exe" "gpid.bin" ; do
            gpid_pid=$(ps -C $gpi_prog -o pid= | tr -d ' ')
            if [ -z "$gpid_pid" ] ; then
                continue
            fi
            gpid_dir=$(cat /proc/$gpid_pid/cmdline 2>/dev/null | tr '\0' ' ' | grep -o -- '-p [^ ]*' | cut -d' ' -f 2)
            if [ -d "$gpid_dir" ] ; then
                break
            fi
        done
    fi

    if [ -z "$gpid_dir" ] ; then
        log "W: could not discover GPI priviledged directory, using /"
        gpid_dir="/"
    fi

    gpid_dir=$(get "gpi.priv_dir" "$gpid_dir")
    get_user_input "GPI privileged directory to use [$gpid_dir]:" gpid_dir

    local gpi_size=$(get "gpi.memory_size" "${DEFAULT_GPI_MEMSIZE:?}")
    get_user_input "gpi memory size (per node) [$gpi_size]:" gpi_size
    parse_human_readable_size $gpi_size gpi_size
    if [ $gpi_size -le 0 ] ; then
        log "E: size must be larger than 0: $gpi_size"
        return 1
    fi

    local shm_size=$(get "plugin.gpi_compat.shm_size" "${DEFAULT_GPI_SHMSIZE:?}")
    get_user_input "shm memory size (per worker) [$shm_size]:" shm_size
    parse_human_readable_size $shm_size shm_size
    if [ $shm_size -le 0 ] ; then
        log "E: size must be larger than 0: $shm_size"
        return 1
    fi

    local mem_size=$(( $gpi_size + $shm_size ))

    # try to get total memory size
    local total_mem=$( grep ^MemTotal: /proc/meminfo | awk '{print $2}')
    total_mem=$(( total_mem * 1024 ))
    if [ $mem_size -gt $total_mem ] ; then
        log "W: the sum of your specified memory sizes exceeds your available memory!"
        log "-:     max available: $total_mem"
        log "-:          gpi size: $gpi_size"
        log "-:          shm size: $shm_size"
        if ! y_n_p "Are you really sure to use these values? [y/N] " ; then
            return 1
        fi
    fi

    put "gpi.memory_size" "$gpi_size"
    put "gpi.priv_dir" "$gpid_dir"
    put "plugin.gpi_compat.shm_size" "$shm_size"

    put "gpi.api" $(get gpi.api "${DEFAULT_GPI_API:?}")
    put "gpi.timeout" $(get gpi.timeout "30")
    put "gpi.socket_mode" $(get gpi.socket_mode "0700")
    put "gpi.mtu" $(get gpi.mtu "default")
    put "gpi.network_type" $(get gpi.network_type "default")
    put "gpi.port" $(get gpi.port "default")
    put "gpi.processes" $(get gpi.processes "default")

    local sdpa_temp_dir=$(get "sdpa.temp_dir")
    local gpi_socket_path=$(get gpi.socket_path "${sdpa_temp_dir}")
    put "gpi.socket_path" "$gpi_socket_path"
    if ! test -d "$gpi_socket_path" ; then
        if ! mkdir -p "$gpi_socket_path" ; then
            log "E: failed to create gpi socket directory: $gpi_socket_path"
            return 1
        else
            if ! chmod 1777 "$gpi_socket_path" ; then
                log "E: failed to adjust mode on $gpi_socket_path"
                return 1
            fi
        fi
    else
        if ! test -w "${gpi_socket_path}" ; then
            log "E: cannot write to gpi socket path: ${gpi_socket_path}"
            return 1
        fi
    fi
}

function setup ()
{
    cat <<EOF
$(sdpac --version 2>/dev/null)

Initiating the  setup routine of  SDPA. In case  of errors or  questions, please
contact 'Alexander Petry <petry@itwm.fhg.de>'.
EOF

    if is_unattended ; then
        log "I: performing automatic setup"
    fi

    if ! test -e "$config_file" ; then
        mkdir -p $(dirname "$config_file") 2>/dev/null
        touch "$config_file"
    fi

    local real_config_file="$config_file"
    local temp_config_file="${config_file}~"

    local old_trap=$(trap -p EXIT)
    trap -- "rm -f $temp_config_file" EXIT

    local parts=$1
    if [ -z "$parts" ] ; then
        parts="state kvs scratch logging temp gui plugins gpi topology"
    else
        shift
    fi

    if test -f "$real_config_file" ; then
        cp "$real_config_file" "$temp_config_file"
    fi
    config_file="$temp_config_file"

    local p
    for p in $parts ; do
        setup_$p $@ || { log "E: setup_$p failed!" ; return 1 ; }
    done

    put "config.version" "$CONFIG_VERSION"
    put "config.modified" "$(date)"
    put "config.sdpa_version" "$(sdpac --dumpversion 2>/dev/null)"
    put "config.sdpa_revision" "$(sdpac --revision 2>/dev/null)"

    cp "$real_config_file" "${real_config_file}.bak"
    mv "$temp_config_file" "$real_config_file"

    # putting config in place
    config_file="$real_config_file"
    eval $old_trap

    echo
    log "I: setup complete."
}

function generate_environment ()
{
    if ! on_master_node ; then
        log "E: cannot generate environment on slave node!"
        return 1
    fi

    kvs_port=$(get "plugin.kvs.port")
    if [ -z "$kvs_port" ] ; then
        log "E: could not get kvs port from config!"
        return 1
    fi
    echo export KVS_URL="$(hostname -s):${kvs_port:?}"

    # read variables from config and write them to an environment file
    #     replacing init-screen.env in principle
    ${fhgcfg} -f "$config_file" -l | while read key dummy val ; do
        case "$key" in
            log.server.level)
                echo export FHGLOG_level="$val"
                ;;
            log.server.url)
                echo export FHGLOG_to_server="$val"
                ;;
            kvs.url)
                echo export KVS_URL="$val"
                ;;
            gpi.priv_dir)
                echo export GPI_PRIV_DIR="$val"
                ;;
            sdpa.gui)
                echo export SDPA_GUI="$val"
                ;;
            sdpa.scratch_dir)
                echo export SDPA_SCRATCH_DIR="$val"
                ;;
            sdpa.temp_dir)
                echo export SDPA_TEMP_DIR="$val"
                ;;
            sdpa.home)
                ;;
            *)
                ;;
        esac
    done

    if [ -z "$SDPA_HOME" ] ; then
        mydir="$(cd $(dirname $( which $0 )) && pwd)"
        export SDPA_HOME=$(dirname "$mydir")
    else
        # sanitize HOME
        export SDPA_HOME="$(echo $SDPA_HOME | sed -e 's,/\+$,,')"
    fi

    export SDPA_LIBEXEC="$SDPA_HOME/libexec/sdpa"
    export SDPA_PLUGINS="$SDPA_HOME/libexec/fhg/plugins"

    echo export SDPA_HOME="$SDPA_HOME"
    echo export SDPA_LIBEXEC="$SDPA_LIBEXEC"
    echo export SDPA_PLUGINS="$SDPA_PLUGINS"

    prepend_to_path PATH "$SDPA_HOME/bin"
    prepend_to_path LD_LIBRARY_PATH "$SDPA_HOME/lib"
    prepend_to_path LD_LIBRARY_PATH "$SDPA_LIBEXEC"
    prepend_to_path LD_LIBRARY_PATH "$HOME/.sdpa/plugins"

    prepend_to_path PC_LIBRARY_PATH "$SDPA_LIBEXEC/apps"
    if [ -n "$SDPA_APP_PATH" ] ; then
        prepend_to_path PC_LIBRARY_PATH "$SDPA_APP_PATH"
        prepend_to_path LD_LIBRARY_PATH "$SDPA_APP_PATH"
    fi
    prepend_to_path PC_LIBRARY_PATH "$HOME/.sdpa/modules"

    echo export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:\$LD_LIBRARY_PATH"
    echo export PC_LIBRARY_PATH="$PC_LIBRARY_PATH:\$PC_LIBRARY_PATH"
    echo export PATH="$PATH:\$PATH"

    debug "I: PATH := ${PATH}"
    debug "I: LD_LIBRARY_PATH := ${LD_LIBRARY_PATH}"
    debug "I: PC_LIBRARY_PATH := ${PC_LIBRARY_PATH}"
}

function dump_config ()
{
    ${fhgcfg} -f "$config_file" -p
}

function initialize ()
{
    local hostfile="$PBS_NODEFILE"
    local node_file=

    app_path="${SDPA_APP_PATH}"
    argv="$@"
    OPTIND=1
    while getopts "hF:n:s:A:" opt $argv ; do
        case $opt in
            h)
                echo >&2 "usage: init: [-h] [-F hostfile] [-s state-dir] [-A module-dir]"
                return 0
                ;;
            F)
                hostfile="$OPTARG"
                shift 2
                ;;
            s)
                state_dir="$OPTARG"
                shift 2
                ;;
            A)
                app_path="${OPTARG}:${app_path}"
                shift 2
                ;;
            \?)
                shift
                ;;
        esac
    done

    export SDPA_APP_PATH="${app_path}"

    if [ -n "$1" ] ; then
        hostfile="$1"; shift
    fi

    if [ -z "$hostfile" ] ; then
        log "E: hostfile not set"
        log "usage: init: [-h] [-F hostfile] [-s state-dir]"
        return 1
    fi

    if [ ! -r "$hostfile" ] ; then
        log "E: cannot read hostfile: $hostfile"
        return 1
    fi

    if ! grep -q -e "^$(hostname -f)$" "${hostfile}" ; then
        if ! grep -q -e "^$(hostname -s)$" "${hostfile}" ; then
            log "E: could not find current host '$(hostname)' in hostfile: $hostfile"
            return 1
        fi
    fi

    if [ ! -d "$state_dir" ] ; then
        local msg=$( mkdir -p "$state_dir" 2>&1 )
        if [ $? -ne 0 ] ; then
            echo "E: failed to create state-dir: $state_dir: $msg" >&2
            return 1
        fi
    fi

    mkdir -p "$state_dir/log" || {
        echo >&2 "E: could not create log directory!"
        return 1
    }

    node_file="${state_dir}/nodefile"

    if ! cp "$hostfile" "$node_file" ; then
        log "E: could not copy nodefile from '$hostfile' to '$node_file'"
        return 1
    fi

    local tmp_file="$state_dir/sdpa.env~"
    :> "$tmp_file"
    echo test -e "$state_dir/sdpa.pre.env" \&\& source "$state_dir/sdpa.pre.env" >> "$tmp_file"
    if ! generate_environment >> "$tmp_file" ; then
        log "E: could not generate environment"
        return 1
    fi
    cat >>"$tmp_file" <<EOF
function log()
{
  echo "\$@" >&2
  test -x "\$SDPA_HOME/bin/fhglogc" && "\$SDPA_HOME/bin/fhglogc" -t "\$0" -p 2 -m "\$*"
}
EOF
    echo test -e "$state_dir/sdpa.post.env" \&\& source "$state_dir/sdpa.post.env" >> "$tmp_file"
    echo ":" >> "$tmp_file"

    local sdpa_home="$SDPA_HOME"
    if [ -z "$sdpa_home" ] ; then
        log "E: SDPA_HOME is not defined!"
    fi
    mv "$tmp_file" "$state_dir/sdpa.env"
    sync
}

function cleanup ()
{
    test -r "$state_dir/sdpa.env" && source "$state_dir/sdpa.env"

    echo "cleaning up" >&2

    echo "  * state" >&2
    if [ -n "$SDPA_SCRATCH_DIR" ] ; then
        if [ -d "$SDPA_SCRATCH_DIR"/state ] ; then
            find "$SDPA_SCRATCH_DIR"/state -mindepth 1 -delete
        fi
    fi

    echo "  * logs" >&2
    clear-logs -f -a -x

    echo "  * backup files" >&2
    for f in "$HOME"/*.bkp *.bkp ; do
        if [ -e "$f" ] ; then
            read -t 5 -n 1 -p "    remove $f? [y/N] " do_rm
            case "$do_rm" in
                y|Y|j|J)
                    echo
                    rm -f "$f"
                    ;;
                *)
                    echo
                    ;;
            esac
        fi
    done
    return 0
}

function help ()
{
    cat >&2 <<EOF
usage: `basename $0` command [parameters...]

   available commands:
        setup       - setup SDPA
        init        - initialize environment file
                      execute this in a a fresh allocation
        load        - print instructions to load
                      the environment file: eval \$(sdpa load)
     selftest       - perform a self-test
       config       - dump the current config

  start [component] - start all components or "component"
   stop [component] - stop all components or "component"
restart [component] - restart all components or "component"
 status [component] - get the current status of component
                gui - start the GUI

      submit <file> - submit a job
 cancel [job-id...] - cancel the given job or the current job
     unload-modules - unload modules in the process containers

EOF
                      return 0
}

function start_log ()
{
    echo "  - fhglog (disabled)" >&2
    return 0
}

function is_proc_alive ()
{
    local name="$1" ; shift
    local pid="$1" ; shift

    if [ -z "$name" ] ; then
        echo "E: usage: is_proc_alive <binary> <pid>" >&2
        exit 42
    fi

    if [ -z "$pid" ] ; then
        return 1
    fi

    if grep -q "$name" /proc/$pid/cmdline >/dev/null 2>&1 ; then
        if kill -0 "$pid" >/dev/null 2>&1 ; then
            return 0
        else
            echo "E: $name: there seems to be an alien around!" >&2
            echo "E:       cannot send signal to $pid" >&2
            return 2 # not allowed to send signals!
        fi
    else
        return 1 # not there
    fi
}

function start_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    # check for old one
    local pid_file="$state_dir/$name.pid"
    local log_file="$state_dir/log/$name.log"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if ! is_proc_alive "$name" "$pid" ; then
        :> "$pid_file"
        debug $binary "$@"
        $binary "$@" </dev/null >"$log_file" 2>&1
        for (( i = 0 ; i < 6 ; ++i )) ; do
            sleep 0.5
            pid=$( cat "$pid_file" 2>/dev/null )
            if [ -n "$pid" ] ; then
                if is_proc_alive "$name" "$pid" ; then
                    echo "+ $name ($pid)" >&2
                    return 0
                fi
            fi
        done
        echo "- $name (dead), check '$log_file' for more - here are the last 3 lines:"
        tail -n 3 "$log_file" >&2
        return 1
    fi
    return 0
}

function stop_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    local pid_file="$state_dir/$name.pid"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if [ -n "$pid" ] ; then
        echo -n "    sending SIGTERM to $name ($pid)..." >&2
        for (( i=0; i<3; ++i )); do
            if is_proc_alive "$name" "$pid" ; then
                echo -n "."
                kill -TERM "$pid" >/dev/null 2>&1
                sleep 1
            else
                :> "$pid_file"
                echo "ok" >&2
                break
            fi
        done
    fi

    if is_proc_alive "$name" "$pid" ; then
        kill -KILL "$pid" >/dev/null 2>&1
        echo "killed" >&2
    else
        pkill "$name" >/dev/null 2>&1
        return 0
    fi
}

function start_agent ()
{
    local name="$1" ; shift
    local master="$1" ; shift

    if [ -z "$name" ] ; then
        echo "E: start_agent(): no name given!" >&2
        return 1
    fi

    if [ -z "$master" ] ; then
        echo "E: start_agent(): no master given!" >&2
        return 1
    fi

    # name format: name[-node]
    local node=$(get_master_node)

    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/start-agent" -s "$state_dir" -F "${config_file}" -P "$state_dir/agent.$name.pid" -D -n "$name" -m "$master" $@ </dev/null 2>&1)
    ec=$?
    if [ $ec -eq 0 ] ; then
        echo "$name" >&2
        return 0
    elif [ $ec -eq 2 ] ; then
        return 0
    else
        echo "- $name: $ec: $err" >&2
        return $ec
    fi
}

function stop_agent_on_node ()
{
    local node="${1}" ; shift
    local rc=0
    local err=""

    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/stop-agent" 2>&1)
    rc=$?

    if [ $rc -ne 0 -a $rc -ne 2 ] ; then
        echo >&2 "stop-agent on node '$node' failed: $rc: $err"
    fi

    return $rc
}

function stop_agent ()
{
    echo "agent (all nodes)" >&2
    node_loop stop_agent_on_node $@
    ec=$?
    if [ $ec -ne 0 ] ; then
        return $ec
    fi
}

function status_agent ()
{
    local name="$1" ; shift

    local node=$(get_master_node)
    local cmd="rexec $node $SDPA_SCRIPT_DIR/status-agent -n $name-$node"
    debug $cmd
    $cmd </dev/null >/dev/null 2>&1
}

function start_kvs ()
{
    if ! on_master_node ; then
        log "E: kvs must be started on the master node"
        exit 1
    fi
    kvs_port=$(get "plugin.kvs.port")
    if [ -z "$kvs_port" ] ; then
        log "E: could not get kvs port from config!"
        return 1
    fi

    if ! start_proc "fhgkvsd" "$SDPA_HOME/bin/fhgkvsd" -s "" "-C" "-b" "0" "-p" "${kvs_port}" "--pidfile" "$state_dir/fhgkvsd.pid" "--daemonize"; then
        log "E: could not start kvs, giving up!"
        return 1
    else
        sleep 1
        return 0
    fi
}

function stop_kvs ()
{
    echo "fhgkvsd"
    if ! stop_proc "fhgkvsd" "fhgkvsd" ; then
        echo "E: could not stop kvs!" >&2
        return 1
    fi
}

function start_orch ()
{
    if ! on_master_node ; then
        log "E: Orchestrator must be started on the master node"
        exit 1
    fi
    if ! start_proc "orchestrator" "start-orch" "-s" "$state_dir" "-P" "$state_dir/orchestrator.pid" "-D" ; then
        echo "E: could not start orchestrator, giving up!" >&2
        return 1
    else
        return 0
    fi
}

function stop_orch ()
{
    echo "orchestrator"
    if ! stop_proc "orchestrator" "start-orch" ; then
        echo "E: could not stop orchestrator" >&2
        return 1
    fi
}

function start_agg ()
{
    if ! start_agent "agent-$(get_master_node)-0" "orchestrator" ; then
        echo "E: could not start agent, giving up!" >&2
        return 1
    else
        return 0
    fi
}

function stop_agg ()
{
    if ! stop_agent ; then
        echo "E: could not stop agent" >&2
        return 1
    fi
}

function node_loop ()
{
    if [ ! -r "${state_dir}/nodefile" ] ; then
        echo "Cannot read nodefile: ${state_dir}/nodefile" >&2
        return 1
    fi

    local body="$1" ; shift

    nodes=$(uniq "${state_dir}/nodefile")

    local rc=0
    local bunch_size=16
    local count=0
    local procs=
    local node=
    local p
    echo -n "   " >&2
    for node in $nodes; do
        count=$(( count + 1 ))

        debug " ++++ executing $body $@ on $node" >&2

        echo -n " $node" >&2

        $body $node $@ &

        procs="$procs $!"
        if [ $count -ge $bunch_size ] ; then
            for p in $procs ; do
                wait $p
                rc=$(( rc + $? ))
            done
            procs=
            count=0
            echo
            echo -n "   " >&2
        fi
    done
    for p in $procs ; do
        wait $p
        rc=$(( rc + $? ))
    done
    echo >&2
    return $rc
}

function start_nre ()
{
    local with_mediator=$(get "topology.with-mediator" "true")
    if [ x"$with_mediator" == x"true" ] ; then
        log "nres" >&2
        node_loop start_nre_on_node $@
    fi
}

function stop_nre ()
{
    with_mediator=$(get "topology.with-mediator" "true")
    if [ x"$with_mediator" == x"true" ] ; then
        log "nres" >&2
        node_loop stop_nre_on_node $@
        ec=$?
    fi
}

function status_nre ()
{
    local err
    local ec

    with_mediator=$(get "topology.with-mediator" "true")
    if [ x"$with_mediator" == x"true" ] ; then
        node_loop status_nre_on_node $@
        ec=$?
    else
        ec=23
    fi
    return $ec
}

function start_nre_on_node ()
{
    local node=$1 ; shift

    if ! start_agent "nre-$node" "aggregator" $@ ; then
        log "E: could not start nre on $node!" >&2
        return 1
    else
        return 0
    fi
}

function stop_nre_on_node ()
{
    local node=$1 ; shift
    local err
    local ec
    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/stop-agent" -n "nre-$node" 2>&1)
    ec=$?
    if [ $ec -eq 0 ] ; then
        return 0
    elif [ $ec -eq 2 ] ; then
        return 0 # not running
    else
        log "E: stop-nre on node $node failed: $ec: $err"
    fi
    return $ec
}

function status_nre_on_node ()
{
    local node=$1; shift
    local pid
    status_agent "nre-$node"
    return $?
}

function start_drts ()
{
    local node=
    local master=agent-$(get_master_node)-0
    local ident=
    local count=
    local force=

    argv="$@"
    OPTIND=1
    while getopts ":hfN:i:c:m:" opt $argv; do
        case $opt in
            h)
                echo "usage: drts: [-h] [-f] [-N node [-i identity|-c count] [-m master]]" >&2
                echo "    -h: print this help" >&2
                echo "    -f: force" >&2
                return 0
                ;;
            f)
                force="-f"
                ;;
            N)
                node=$OPTARG
                shift 2
                ;;
            i)
                ident=$OPTARG
                shift 2
                ;;
            m)
                master=$OPTARG
                shift 2
                ;;
            c)
                count=$OPTARG
                shift 2
                ;;
            \?)
                ;;
        esac
    done

    if [ -z "$node" ] ; then
        echo "process container (all nodes)" >&2
        node_loop start_drts_on_node "$master" "" $force $@
        ec=$?
        if [ -n "$err" ] ; then
            echo "$err"
        fi
        if [ $ec -ne 0 ] ; then
            echo "$err"
            return $ec
        fi
    else
        if [ -z "$ident" ] ; then
            echo "process container $node" >&2
            start_drts_on_node "$node" "$master" "$count" $force $@
            ec=$?
            return $ec
        else
            count=1
            echo "process container $node-$ident with master $master" >&2
            start_drts_on_node "$node" "$master" "$count" -i "$ident" $force $@
            ec=$?
            return $ec
        fi
    fi
}

function stop_drts ()
{
    local node=
    local ident=

    argv="$@"
    OPTIND=1
    while getopts ":hN:i:" opt $argv; do
        case $opt in
            h)
                echo "usage: drts: [-h] [-N node [-i identity]" >&2
                return 0
                ;;
            N)
                node=$OPTARG
                shift 2
                ;;
            i)
                ident=$OPTARG
                shift 2
                ;;
            \?)
                ;;
        esac
    done

    if [ -z "$node" ] ; then
        echo "process container (all nodes)" >&2
        node_loop stop_drts_on_node $@
        ec=$?
        if [ $ec -ne 0 ] ; then
            return $ec
        fi
    else
        if [ -z "$ident" ] ; then
            echo "process container $node" >&2
            stop_drts_on_node "$node" $@
            ec=$?
            return $ec
        else
            echo "process container $node-$ident" >&2
            stop_drts_on_node "$node" -i "$ident" $@
            ec=$?
            return $ec
        fi
    fi
}

function status_drts ()
{
    local node=
    local ident=

    argv="$@"
    OPTIND=1
    while getopts ":hN:i:" opt $argv; do
        case $opt in
            h)
                echo "usage: drts: [-h] [-N node [-i identity]" >&2
                return 0
                ;;
            N)
                node=$OPTARG
                shift 2
                ;;
            i)
                ident=$OPTARG
                shift 2
                ;;
            \?)
                ;;
        esac
    done

    if [ -z "$node" ] ; then
        echo "process container (all nodes)" >&2
        node_loop status_drts_on_node $@
        ec=$?
        if [ $ec -ne 0 ] ; then
            echo "$err"
            return $ec
        fi
    else
        if [ -z "$ident" ] ; then
            echo -n "process container $node" >&2
            status_drts_on_node "$node" $@
            ec=$?
            if [ $ec -eq 0 ] ; then
                echo " ok" >&2
            else
                echo " dead" >&2
            fi
            return $ec
        else
            echo "process container $node-$ident" >&2
            status_drts_on_node "$node" -i "$ident" $@
            ec=$?
            if [ $ec -eq 0 ] ; then
                echo " ok" >&2
            else
                echo " dead" >&2
            fi
            return $ec
        fi
    fi
}

function start_drts_on_node ()
{
    local node=$1 ; shift
    local master="$1" ; shift
    local per_node="$1"; shift
    if [ -z "$master" ] ; then
        master="agent-$(get_master_node)-0"
    fi
    if [ -z "$per_node" ] ; then
        per_node=$(get "topology.per-node" "0")
    fi

    with_mediator=$(get "topology.with-mediator" "true")
    if [ x"$with_mediator" == x"true" ] ; then
        master="nre-$node"
    fi

    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/start-drts" -F "${config_file}" -s "$state_dir" -D -m "$master" -c "$per_node" $@ 2>&1)
    ec=$?
    if [ $ec -eq 0 ] ; then
        return 0
    elif [ $ec -eq 1 ] ; then
        log "E: pc did not startup on node $node: $err" >&2
        return 1
    elif [ $ec -eq 2 ] ; then
        return 0
    else
        return 0
    fi
}

function stop_drts_on_node ()
{
    local node=$1 ; shift
    local err
    local ec
    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/stop-drts" $@)
    ec=$?
    if [ $ec -ne 0 ] ; then
        log "W: stop-drts on node $node failed: $ec: $err"
    fi
    return $ec
}

function status_drts_on_node ()
{
    local node=$1 ; shift
    local err
    local ec
    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/status-drts" -s "$@" 2>&1)
    ec=$?
    if [ $ec -ne 0 ] ; then
        if [ -n "$err" ] ; then
            log "W: status-drts on node $node failed: $ec: $err"
        fi
    fi
    return $ec
}

function start_gui ()
{
    local log_url=$(get "log.server.url")
    local log_port=$(echo "$log_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$log_port" ] ; then
        log "E: log url ($log_url) does not contain a port!"
        return 1
    fi
    local log_host=$(echo "$log_url" | cut -d ':' -f 1)

    local gui_url=$(get "sdpa.gui")
    local gui_port=$(echo "$gui_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$gui_port" ] ; then
        log "E: gui url ($gui_url) does not contain a port!"
        return 1
    fi
    local gui_host=$(echo "$gui_url" | cut -d ':' -f 1)

    local cmd="ssh -X $gui_host /usr/bin/env LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" $SDPA_SCRIPT_DIR/start-gui -s $state_dir -G $gui_port -L $log_port -r $SDPA_HOME"
    log "I: starting gui with $cmd ..."
    $cmd &
}

function start_gpi ()
{
    if ! on_master_node ; then
        log "E: GPI must be started on the master node"
        exit 1
    fi
    local gpi_enabled=$(get "gpi.enabled" "true")

    local log_url=$(get "log.server.url")
    local log_port=$(echo "$log_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$log_port" ] ; then
        log "E: log url ($log_url) does not contain a port!"
        return 1
    fi
    local log_host=$(echo "$log_url" | cut -d ':' -f 1)

    local kvs_port=$(get "plugin.kvs.port" "2439")

    if [ x"$gpi_enabled" == x"true" ] ; then
        if ! status_kvs ; then
            start_kvs
        fi

        if ! start_proc "gpi-space" "$SDPA_SCRIPT_DIR/start-gpi" "-s" "$state_dir" -F "${config_file}" "-f" "-P" "$state_dir/gpi-space.pid" "-m" $(get "gpi.memory_size" "${DEFAULT_GPI_MEMSIZE:?}") "-k" $(hostname -s) -K $kvs_port -l $log_host -L $log_port ; then
            log "E: could not start GPI, giving up!"
            return 1
        else
            return 0
        fi
    else
        log "gpi (deactivated)" >&2
    fi
}

function stop_gpi ()
{
    log "gpi"
    if ! stop_proc "gpi-space" "gpi-space" ; then
        log "E: could not stop gpi"
        return 1
    else
        return 0
    fi
}

function start ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
        parts="kvs gpi orch agg drts"
    else
        shift
    fi

    local p
    local rc=0
    for p in $parts ; do
        if ! start_$p $@ ; then
            log "Start of $p failed!"
            rc=$(( rc + 1 ))
        fi
    done
    return $rc
}

function stop ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
        parts="drts agg orch gpi kvs"
    else
        shift
    fi

    local p
    local rc=0
    for p in $parts ; do
        if ! stop_$p $@ ; then
            rc=$(( rc + 1 ))
        fi
    done
    return $rc
}

function restart ()
{
    if stop $@ ; then
        sleep 3
        start $@
    else
        log "E: stop failed, not starting!"
        return 1
    fi
}

function program_status ()
{
    local p=$1 ; shift
    local rc=0
    local pid
    pid=$(pidof "$p")

    if is_proc_alive "$p" "$pid" ; then
        return 0
    else
        return 1
    fi
}

function status_orch ()
{
    is_proc_alive "orchestrator" $(cat "$state_dir/orchestrator.pid" 2>/dev/null)
}

function status_agg ()
{
    status_agent "agent-$(get_master_node)-0"
}

function status_kvs ()
{
    is_proc_alive "fhgkvsd" $(cat "$state_dir/fhgkvsd.pid" 2>/dev/null)
}

function status_gpi ()
{
    local ec=0
    local gpi_enabled=$(get "gpi.enabled" "true")
    if [ x"$gpi_enabled" == x"true" ] ; then
        program_status "gpi-space"
        ec=$?
    else
        ec=23
    fi
    return $ec
}

function status ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
        parts="kvs orch agg gpi drts"
    else
        shift
    fi

    # check system status
    local rc=0
    local p
    local err
    for p in $parts ; do
        local cmd
        cmd="status_$p"
        if type "$cmd" >/dev/null 2>&1 ; then
            err=$(status_$p $@)
            ec=$?
            if [ $ec -eq 0 ] ; then
                :
#               log "$p is alive"
            elif [ $ec -eq 23 ] ; then
                log "$p is deactivated"
            else
                if [ -z "$err" ] ; then
                    log "$p is dead"
                else
                    log "$p is dead: $err"
                fi
                rc=$(( rc + 1 ))
            fi
        else
            sdpac status $p
        fi
    done
    return $rc
}

function cancel ()
{
    local jobs="$@"
    if [ -z "$jobs" ] ; then
        if test -e "$state_dir/current_job" ; then
            jobs=$(cat "$state_dir/current_job")
        fi
    fi

    if [ -z "$jobs" ] ; then
        log "E: nothing to cancel"
        return 1
    fi

    local err
    for job in $jobs ; do
        log "I: cancelling job $job"
        err=$(sdpac cancel "$job" 2>&1)
        local ec=$?
        if [ $ec -ne 0 ] ; then
            log "E: failed: $ec: $err"
        fi
    done
}

function submit ()
{
    # check system health
    #    if not running:
    #       abort/ask
    #    else
    #       submit
    local net="$1" ; shift
    if [ ! -r "$net" ] ; then
        log "E: submit: cannot read file: $net"
        return 42
    fi
    if [ x"$net" = x"-" ] ; then
        net="/dev/stdin"
    fi
    local output="$1"; shift
    if [ -z "$output" ] ; then
        output=/dev/null
    fi

    log "I: checking system status..."
    if ! status kvs >/dev/null 2>&1 || ! status orch >/dev/null 2>&1 ; then
        log "W: system not completely up and running"
        read -t 15 -n 1 -p "Do you want me to start it? [Y/n] " do_start
        case "$do_start" in
            n|N)
                ;;
            *)
                echo
                if ! start ; then
                    log "E: could not start, please check the logs"
                    return 3
                else
                    sleep 5
                fi
                ;;
        esac
    fi

    log "I: submitting file: $net"
    jobid=$( sdpac submit "$net" 2>&1 )
    if [ $? -ne 0 ] ; then
        log "E: submission failed: $jobid"
        return 4
    else
        log "  + job ($jobid)"
        echo "$jobid" > "$state_dir/current_job"
        sdpac wait "$jobid"
        s=$(sdpac status "${jobid}")
        log "    $jobid -> $s"
        s=$(echo "$s" | tr 'A-Z' 'a-z')
        case "$s" in
            *finish*)
                log "I: job finished"
                ;;
            *fail*)
                log "E: job faiiled"
                ;;
            *cancel*)
                log "E: job cancelled"
                ;;
            *)
                log "W: unknown state: $s"
                ;;
        esac
        sdpac -o "$output" --force results "$jobid"
        sdpac delete "${jobid}"
        if [ $? -eq 0 ] ; then
            echo "  - job ($jobid)"
        fi
    fi
}

function configure()
{
    test -e "$state_dir/sdpa.env" && source "$state_dir/sdpa.env"
}

function on_valid_host ()
{
    local host="$(hostname -s)"
    if test -r "$state_dir/nodefile" ; then
        if grep -q -e "^$host" "$state_dir/nodefile" ; then
            return 0
        else
            #log "W: your hostname ($host) does not match any in $state_dir/nodefile"
            return 1
        fi
    else
        log "E: no nodefile present"
        return 2
    fi
    return 1
}

function get_master_node()
{
    if test -r "$state_dir/nodefile" ; then
        head -n 1 "$state_dir/nodefile"
    else
        return 1
    fi
}

function on_master_node ()
{
    if test -r "$state_dir/nodefile" ; then
        local master=$( head -n 1 "$state_dir/nodefile" )
        if [ "$master" = "$(hostname -s)" ] ; then
            return 0
        fi
        if [ "$master" = "$(hostname -f)" ] ; then
            return 0
        fi
    else
        log "E: no nodefile present"
    fi
    return 1
}

function selftest ()
{
    log "I: performing self-test"

    local xml="$SDPA_LIBEXEC/apps/selftest/selftest.xml"
    if ! test -r "$xml" ; then
        log "E: cannot read $xml"
        return 1
    fi

    local pnetc=$(which pnetc)
    if ! test -x "$pnetc" ; then
        log "E: cannot execute $pnetc"
        return 2
    fi

    local sdpac=$(which sdpac)
    if ! test -x "$sdpac" ; then
        log "E: cannot execute sdpac"
        return 3
    fi

    local pnetput=$(which pnetput)
    if ! test -x "$pnetput" ; then
        log "E: cannot execute pnetput"
        return 3
    fi

    local pnetget=$(which pnetget)
    if ! test -x "$pnetget" ; then
        log "E: cannot execute pnetget"
        return 3
    fi

    local job_desc=$(mktemp)
    local old_trap=$(trap -p EXIT)
    trap -- "rm -f $job_desc" EXIT

    log "I: building job description..."
    local challenge=$(date +%s | md5sum | awk '{print $1}')
    if [ $? -ne 0 ] ; then
        challenge="dummy"
    fi

    local expected_response="sdpa.response.$challenge"

    if ! cat "$xml" | $pnetc | $pnetput -p challenge=\"$challenge\" > "$job_desc" ; then
        log "E: could not generate job description and place tokens"
        return 5
    fi

    log "I: (re-)starting SDPA..."

    if ! restart ; then
        stop
        log "E: restart failed"
        return 4
    fi

    log "I: computing response for challenge: $challenge"

    log "I: submitting job..."
    local job_id=$(sdpac submit "$job_desc")
    log "I: JOB-ID: $job_id"

    local walltime=120
    log "I: waiting at most $walltime seconds for job to return..."
    local job_state=42
    for ((i=0 ; i < $walltime ; ++i)) ; do
        sleep 1
        local job_status=$(sdpac status "$job_id")
        if echo "$job_status" | grep -q -i -e 'finished' ; then
            log "I: job has finished"
            job_state=0
            break
        elif echo "$job_status" | grep -q -i -e 'failed' ; then
            log "E: job has failed"
            job_state=1
            break
        elif echo "$job_status" | grep -q -i -e 'cancelled' ; then
            log "E: job has been cancelled"
            job_state=2
            break
        fi
    done

    if [ "$job_state" -eq 0 ] ; then
        log "I: retrieving results"
        if ! sdpac --force -o "$job_desc" results "$job_id" ; then
            log "E: could not retrieve results"
            rm "$job_desc"
            stop
            return 6
        fi

        if ! sdpac delete "$job_id" ; then
            log "E: could not delete job"
            rm "$job_desc"
            stop
            return 7
        fi
        local response=$(pnetget < "$job_desc" --type=output response | sed -e 's/^"//g' -e 's/"$//g')
        if [ x"$response" != x"$expected_response" ] ; then
            log "E: response: '$response' does not match expected response: '$expected_response'"
        else
            log "I: got correct response"
        fi

        if [ -z "$USER" ] ; then
            greeting="You-Know-Who"
        else
            greeting="user $USER"
        fi

        log "I: Congratulations $greeting, your SDPA installation is working!"
    else
        log "E: self test job could not be executed!"
        stop
        return 8
    fi

    rm "$job_desc"
    stop

    return 0
}

##########################################################
#                                                        #
#          S C R I P T     B E H A V I O R               #
#                                                        #
##########################################################

if [ "$1" = "help" ] ; then
    shift
    help $@
    exit $?
fi

if [ "$1" = "version" ] ; then
    shift
    sdpac --version
    exit $?
fi

if [ "$1" = "-s" ] ; then
    shift
    state_dir="$1"; shift
    if [ -z "$state_dir" ] ; then
        log "E: empty state dir"
        exit 1
    fi
    export SDPA_STATE_DIR="$state_dir"
fi

if [ "$1" = "-c" ] ; then
    shift
    config_file="$1"; shift
    if [ -z "$config_file" ] ; then
        log "E: empty config file"
        exit 1
    fi
    export SDPA_CONFIG="config_file"
fi

if [ "$1" = "setup" ] ; then
    shift
    setup $@
    exit $?
fi

if setup_required ; then
    if setup ; then
        log "I: setup complete"
    else
        rc=$?
        log E: setup was unsuccessful: $rc
        exit $rc
    fi
fi

if [ "$1" = "init" ] ; then
    shift
    if ! initialize $@; then
        log "E: could not initialize!"
        exit 1
    else
        exit 0
    fi
fi

if [ "$1" = "gui" ] ; then
    start_gui
    exit $?
fi

function require_state ()
{
    if ! on_valid_host ; then
#    log "W: you are executing 'sdpa' on an invalid host!"
#    log "W: this might not be what you want"
#    log "I: please run 'sdpa init' on the master node first!"
        :
    fi

    if ! configure ; then
        log "E: configure() failed"
        exit $?
    fi
}

case "$1" in
    start)
        require_state
        shift
        start $@
        ;;
    stop)
        require_state
        if ! on_master_node ; then
            log "E: not on master node"
            exit 1
        fi
        shift
        stop $@
        ;;
    restart)
        require_state
        if ! on_master_node ; then
            log "E: not on master node"
            exit 1
        fi
        shift
        restart $@
        ;;
    status)
        require_state
        if ! on_master_node ; then
            log "E: not on master node"
            exit 1
        fi
        shift
        status $@
        ;;
    cleanup)
        if status >/dev/null 2>&1 ; then
            echo "E: still running!" >&2
            exit 1
        else
            cleanup
        fi
        ;;
    cancel)
        require_state
        shift
        cancel $@
        ;;
    submit)
        require_state
        shift
        submit $@
        ;;
    help)
        help
        ;;
    gui)
        start_gui
        ;;
    config)
        dump_config
        ;;
    load)
        if test -f "$state_dir/sdpa.env" ; then
            echo source "$state_dir/sdpa.env"\;
        fi
        ;;
    unload-modules)
        require_state
        if ! on_master_node ; then
            log "E: not on master node"
            exit 1
        fi
        shift
        restart drts
        ;;
    boot)
        "$0" -s "$state_dir" -c "$config_file" init || {
            echo >&2 "sdpa: could not initialize!"
            exit 1
        }
        shift
        "${SDPA_SCRIPT_DIR}/start-sdpa" -S "$state_dir" -F "$config_file" "$@"
        ;;
    selftest)
        "$0" -s "$state_dir" -c "$config_file" init || {
            echo >&2 "sdpa: could not initialize!"
            exit 1
        }
        if ! on_master_node ; then
            log "E: not on master node"
            exit 1
        fi
        selftest
        ;;
    '')
        help
        ;;
    *)
        echo "E: unknown command: $1, try '$0 help'" >&2
        exit 1
        ;;
esac
