#!/bin/bash
#
# usage: sdpa {start|stop|status|submit file}
#

kvs_host=
kvs_port=

function log ()
{
    echo "$@" >&2
}

function debug ()
{
    if [ x"$debug_enabled" = x"true" ] ; then
        log $@
    fi
}

function prepend_to_path ()
{
    local var="$1"; shift
    local val=$(eval echo \$${var})
    for v ; do
        if [ -z "$v" ] ; then
            continue
        fi
        val=$(echo "$val" | sed "s,:$v:,:,g")
        val=$(echo "$val" | sed -e "s,^$v:,,g")
        val=$(echo "$val" | sed -e "s,:$v\$,,g")
        if [ -z "$val" ] ; then
            val="$v"
        else
            val="$v:$val"
        fi
    done
    eval "export $var=$val"
}

if [ -z "$HOME" ]
then
    export HOME=$(echo ~)
fi

export SDPA_HOME=$(dirname $(dirname $(which "$0")))
SDPA_SCRIPT_DIR="${SDPA_HOME}/libexec/sdpa/scripts"
prepend_to_path PATH "$SDPA_HOME/bin"

state_dir=${SDPA_STATE_DIR:="$HOME/.sdpa/state"}
debug_enabled=false

##############################################
#                                            #
#  F U N C T I O N    D E F I N I T I O N S  #
#                                            #
##############################################

function require()
{
    local tool="$1"; shift
    if [ -z "$tool" ] ; then
        return 2
    fi

    tool_bin=$(which "$tool" 2>/dev/null)
    if [ -z "$tool_bin" ] ; then
        tool_bin="$SDPA_HOME/bin/$tool"
    fi

    if [ ! -x "$tool_bin" ] ; then
        echo "Could not locate required tool $tool" >&2
        return 1
    fi
    eval "$tool=$tool_bin"
    return 0
}

if ! require fhglogc ; then
    exit 1
fi

function rexec ()
{
    local node="$1"; shift
    local err
    local rc
    local ssh_opts="-q -x -T -n -C -4 -c arcfour,blowfish-cbc -o CheckHostIP=no -o StrictHostKeyChecking=no"
    local cmd="ssh $ssh_opts $node $@"
    debug $cmd
    err=$($cmd 2>&1)
    rc=$?
    if [ $rc -eq 0 ] ; then
        return 0
    elif [ $rc -eq 255 ] ; then
        echo "ssh could not connect to $node: $err: $rc" >&2
        return $rc
    else
        echo "$err"
        return $rc
    fi
}

function initialize ()
{
    local node_file=
    local hostfile="${1}"; shift

    if [ -z "$hostfile" ] ; then
        log "E: hostfile not set"
        log "usage: init: [-h] [-F hostfile] [-s state-dir]"
        return 1
    fi

    if [ ! -r "$hostfile" ] ; then
        log "E: cannot read hostfile: $hostfile"
        return 1
    fi

    if ! grep -q -e "^$(hostname -f)$" "${hostfile}" ; then
        if ! grep -q -e "^$(hostname -s)$" "${hostfile}" ; then
            log "E: could not find current host '$(hostname)' in hostfile: $hostfile"
            return 1
        fi
    fi

    if [ ! -d "$state_dir" ] ; then
        local msg=$( mkdir -p "$state_dir" 2>&1 )
        if [ $? -ne 0 ] ; then
            echo "E: failed to create state-dir: $state_dir: $msg" >&2
            return 1
        fi
    fi

    mkdir -p "$state_dir/log" || {
        echo >&2 "E: could not create log directory!"
        return 1
    }

    node_file="${state_dir}/nodefile"

    if ! cp "$hostfile" "$node_file" ; then
        log "E: could not copy nodefile from '$hostfile' to '$node_file'"
        return 1
    fi
}

function help ()
{
    cat >&2 <<EOF
usage: `basename $0` command [parameters...]

   available commands:
        init        - initialize environment file
                      execute this in a a fresh allocation
     selftest       - perform a self-test

  start [component] - start all components or "component"
   stop [component] - stop all components or "component"
 status [component] - get the current status of component
                gui - start the GUI
             bundle - bundle an application and its libraries

      submit <file> - submit a job
 cancel [job-id...] - cancel the given job or the current job
     unload-modules - unload modules in the process containers

EOF
                      return 0
}

function is_proc_alive ()
{
    local name="$1" ; shift
    local pid="$1" ; shift

    if [ -z "$name" ] ; then
        echo "E: usage: is_proc_alive <binary> <pid>" >&2
        exit 42
    fi

    if [ -z "$pid" ] ; then
        return 1
    fi

    if grep -q "$name" /proc/$pid/cmdline >/dev/null 2>&1 ; then
        if kill -0 "$pid" >/dev/null 2>&1 ; then
            return 0
        else
            echo "E: $name: there seems to be an alien around!" >&2
            echo "E:       cannot send signal to $pid" >&2
            return 2 # not allowed to send signals!
        fi
    else
        return 1 # not there
    fi
}

function start_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    # check for old one
    local pid_file="$state_dir/$name.pid"
    local log_file="$state_dir/log/$name.log"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if ! is_proc_alive "$name" "$pid" ; then
        :> "$pid_file"
        debug $binary "$@"
        $binary "$@" </dev/null >"$log_file" 2>&1
        for (( i = 0 ; i < 6 ; ++i )) ; do
            sleep 0.5
            pid=$( cat "$pid_file" 2>/dev/null )
            if [ -n "$pid" ] ; then
                if is_proc_alive "$name" "$pid" ; then
                    echo "+ $name ($pid)" >&2
                    return 0
                fi
            fi
        done
        echo "- $name (dead), check '$log_file' for more - here are the last 3 lines:"
        tail -n 3 "$log_file" >&2
        return 1
    fi
    return 0
}

function stop_proc ()
{
    local name="$1" ; shift
    local binary="$1" ; shift

    local pid_file="$state_dir/$name.pid"
    local pid=$( cat "$pid_file" 2>/dev/null )
    if [ -n "$pid" ] ; then
        echo -n "    sending SIGTERM to $name ($pid)" >&2
        for (( i=0; i<3; ++i )); do
            if is_proc_alive "$name" "$pid" ; then
                echo -n "." >&2
                kill -TERM "$pid" >/dev/null 2>&1
                sleep 1
            else
                :> "$pid_file"
                echo "ok" >&2
                break
            fi
        done
    fi

    if is_proc_alive "$name" "$pid" ; then
        kill -KILL "$pid" >/dev/null 2>&1
        echo "killed" >&2
    else
        pkill "$name" >/dev/null 2>&1
        return 0
    fi
}

function stop_agent_on_node ()
{
    local node="${1}" ; shift
    local rc=0
    local err=""

    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/stop-agent" 2>&1)
    rc=$?

    if [ $rc -ne 0 -a $rc -ne 2 ] ; then
        echo >&2 "stop-agent on node '$node' failed: $rc: $err"
    fi

    return $rc
}

function stop_agent ()
{
    echo "agent (all nodes)" >&2
    node_loop stop_agent_on_node $@
    ec=$?
    if [ $ec -ne 0 ] ; then
        return $ec
    fi
}

function status_agent ()
{
    local name="$1" ; shift

    local node=$(get_master_node)
    local cmd="rexec $node $SDPA_SCRIPT_DIR/status-agent -n $name-$node"
    debug $cmd
    $cmd </dev/null >/dev/null 2>&1
}

function start_kvs ()
{
    if ! on_master_node ; then
        log "E: kvs must be started on the master node"
        exit 1
    fi
    if ! start_proc "fhgkvsd" "$SDPA_HOME/bin/fhgkvsd" --bind "0" --port '*' "--pidfile" "$state_dir/fhgkvsd.pid" "--daemonize" > "${state_dir}/kvs.port"; then
        log "E: could not start kvs, giving up!"
        return 1
    fi
    local kvs_host=$(hostname -f)
    local kvs_port=$(cat "${state_dir}/log/fhgkvsd.log")
    echo -n "${kvs_host}" > "${state_dir}/kvs.host"
    echo -n "${kvs_port}" > "${state_dir}/kvs.port"
    log "I: kvs started at ${kvs_host}:${kvs_port}"
    return 0
}

function stop_kvs ()
{
    echo "fhgkvsd"

    rm -f "${state_dir}/kvs.host"
    rm -f "${state_dir}/kvs.port"

    if ! stop_proc "fhgkvsd" "fhgkvsd" ; then
        echo "E: could not stop kvs!" >&2
        return 1
    fi
}

function stop_orch ()
{
    echo "orchestrator"
    if ! stop_proc "orchestrator" "$SDPA_SCRIPT_DIR/start-orch" ; then
        echo "E: could not stop orchestrator" >&2
        return 1
    fi
}

function stop_agg ()
{
    if ! stop_agent ; then
        echo "E: could not stop agent" >&2
        return 1
    fi
}

function node_loop ()
{
    if [ ! -r "${state_dir}/nodefile" ] ; then
        echo "Cannot read nodefile: ${state_dir}/nodefile" >&2
        return 1
    fi

    local body="$1" ; shift

    nodes=$(uniq "${state_dir}/nodefile")

    local rc=0
    local bunch_size=16
    local count=0
    local procs=
    local node=
    local p
    echo -n "   " >&2
    for node in $nodes; do
        count=$(( count + 1 ))

        debug " ++++ executing $body $@ on $node" >&2

        echo -n " $node" >&2

        $body $node $@ &

        procs="$procs $!"
        if [ $count -ge $bunch_size ] ; then
            for p in $procs ; do
                wait $p
                rc=$(( rc + $? ))
            done
            procs=
            count=0
            echo
            echo -n "   " >&2
        fi
    done
    for p in $procs ; do
        wait $p
        rc=$(( rc + $? ))
    done
    echo >&2
    return $rc
}

function stop_drts ()
{
    local node=
    local ident=

    argv="$@"
    OPTIND=1
    while getopts ":hN:i:" opt $argv; do
        case $opt in
            h)
                echo "usage: drts: [-h] [-N node [-i identity]" >&2
                return 0
                ;;
            N)
                node=$OPTARG
                shift 2
                ;;
            i)
                ident=$OPTARG
                shift 2
                ;;
            \?)
                ;;
        esac
    done

    if [ -z "$node" ] ; then
        echo "process container (all nodes)" >&2
        node_loop stop_drts_on_node $@
        ec=$?
        if [ $ec -ne 0 ] ; then
            return $ec
        fi
    else
        if [ -z "$ident" ] ; then
            echo "process container $node" >&2
            stop_drts_on_node "$node" $@
            ec=$?
            return $ec
        else
            echo "process container $node-$ident" >&2
            stop_drts_on_node "$node" -i "$ident" $@
            ec=$?
            return $ec
        fi
    fi
}

function status_drts ()
{
    local node=
    local ident=

    argv="$@"
    OPTIND=1
    while getopts ":hN:i:" opt $argv; do
        case $opt in
            h)
                echo "usage: drts: [-h] [-N node [-i identity]" >&2
                return 0
                ;;
            N)
                node=$OPTARG
                shift 2
                ;;
            i)
                ident=$OPTARG
                shift 2
                ;;
            \?)
                ;;
        esac
    done

    if [ -z "$node" ] ; then
        echo "process container (all nodes)" >&2
        node_loop status_drts_on_node $@
        ec=$?
        if [ $ec -ne 0 ] ; then
            echo "$err"
            return $ec
        fi
    else
        if [ -z "$ident" ] ; then
            echo -n "process container $node" >&2
            status_drts_on_node "$node" $@
            ec=$?
            if [ $ec -eq 0 ] ; then
                echo " ok" >&2
            else
                echo " dead" >&2
            fi
            return $ec
        else
            echo "process container $node-$ident" >&2
            status_drts_on_node "$node" -i "$ident" $@
            ec=$?
            if [ $ec -eq 0 ] ; then
                echo " ok" >&2
            else
                echo " dead" >&2
            fi
            return $ec
        fi
    fi
}

function stop_drts_on_node ()
{
    local node=$1 ; shift
    local err
    local ec
    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/stop-drts" $@)
    ec=$?
    if [ $ec -ne 0 ] ; then
        log "W: stop-drts on node $node failed: $ec: $err"
    fi
    return $ec
}

function status_drts_on_node ()
{
    local node=$1 ; shift
    local err
    local ec
    err=$(rexec "$node" "$SDPA_SCRIPT_DIR/status-drts" -s "$@" 2>&1)
    ec=$?
    if [ $ec -ne 0 ] ; then
        if [ -n "$err" ] ; then
            log "W: status-drts on node $node failed: $ec: $err"
        fi
    fi
    return $ec
}

function start_gui ()
{
    local gui_port="${1}" ; shift
    if [ -z "${gui_port}" ]
    then
        log "usage: gui: gui-port log-port!"
        return 1
    fi
    local log_port="${1}" ; shift
    if [ -z "$log_port" ] ; then
        log "usage: gui: gui-port log-port!"
        return 1
    fi

    "$SDPA_HOME/bin/sdpa-gui" $gui_port $log_port &
}

function stop_gpi ()
{
    log "gpi"
    if ! stop_proc "gpi-space" "gpi-space" ; then
        log "E: could not stop gpi"
        return 1
    else
        return 0
    fi
}

function start ()
{
    local part=$1; shift
    if [ -z "$part" ] ; then
        echo >&2 "start: requires a component to start: kvs"
        return 1
    fi

    start_${part} $@
    rc=$?

    if [ $rc -ne 0 ] ; then
        log "Start of $part failed!"
    fi

    return $rc
}

function stop ()
{
    local parts="drts agg orch gpi kvs"

    local p
    local rc=0
    for p in $parts ; do
        if ! stop_$p $@ ; then
            rc=$(( rc + 1 ))
        fi
    done
    return $rc
}

function status_orch ()
{
    is_proc_alive "orchestrator" $(cat "$state_dir/orchestrator.pid" 2>/dev/null)
}

function status_agg ()
{
    status_agent "agent-$(get_master_node)-0"
}

function status_kvs ()
{
    is_proc_alive "fhgkvsd" $(cat "$state_dir/fhgkvsd.pid" 2>/dev/null)
}

function status_gpi ()
{
    is_proc_alive "gpi-space" $(cat "$state_dir/gpi-space.pid" 2>/dev/null)
}

function status ()
{
    local parts=$1
    if [ -z "$parts" ] ; then
        parts="kvs orch agg gpi drts"
    else
        shift
    fi

    # check system status
    local rc=0
    local p
    local err
    for p in $parts ; do
        local cmd
        cmd="status_$p"
        if type "$cmd" >/dev/null 2>&1 ; then
            err=$(status_$p $@)
            ec=$?
            if [ $ec -eq 0 ] ; then
                :
#               log "$p is alive"
            elif [ $ec -eq 23 ] ; then
                log "$p is deactivated"
            else
                if [ -z "$err" ] ; then
                    log "$p is dead"
                else
                    log "$p is dead: $err"
                fi
                rc=$(( rc + 1 ))
            fi
        else
            sdpac --kvs-host "${kvs_host}" --kvs-port ${kvs_port} status $p
        fi
    done
    return $rc
}

function submit ()
{
    local net="$1" ; shift
    if [ ! -r "$net" ] ; then
        log "E: submit: cannot read file: $net"
        return 42
    fi
    if [ x"$net" = x"-" ] ; then
        net="/dev/stdin"
    fi
    local output="$1"; shift
    if [ -z "$output" ] ; then
        output=/dev/null
    fi

    log "I: submitting file: $net"
    jobid=$( sdpac --kvs-host "${kvs_host}" --kvs-port ${kvs_port} submit "$net" 2>&1 )
    if [ $? -ne 0 ] ; then
        log "E: submission failed: $jobid"
        return 4
    else
        log "  + job ($jobid)"
        echo "$jobid" > "$state_dir/current_job"
        sdpac --kvs-host "${kvs_host}" --kvs-port ${kvs_port} wait "$jobid"
        s=$(sdpac --kvs-host "${kvs_host}" --kvs-port ${kvs_port} status "${jobid}")
        log "    $jobid -> $s"
        s=$(echo "$s" | tr 'A-Z' 'a-z')
        case "$s" in
            *finish*)
                log "I: job finished"
                ;;
            *fail*)
                log "E: job failed"
                ;;
            *cancel*)
                log "E: job canceled"
                ;;
            *)
                log "W: unknown state: $s"
                ;;
        esac
        sdpac --kvs-host "${kvs_host}" --kvs-port ${kvs_port} -o "$output" --force results "$jobid"
        sdpac --kvs-host "${kvs_host}" --kvs-port ${kvs_port} delete "${jobid}"
        if [ $? -eq 0 ] ; then
            echo "  - job ($jobid)"
        fi
    fi
}

function on_valid_host ()
{
    local host="$(hostname -s)"
    if test -r "$state_dir/nodefile" ; then
        if grep -q -e "^$host" "$state_dir/nodefile" ; then
            return 0
        else
            #log "W: your hostname ($host) does not match any in $state_dir/nodefile"
            return 1
        fi
    else
        log "E: no nodefile present"
        return 2
    fi
    return 1
}

function get_master_node()
{
    if test -r "$state_dir/nodefile" ; then
        head -n 1 "$state_dir/nodefile"
    else
        return 1
    fi
}

function on_master_node ()
{
    if test -r "$state_dir/nodefile" ; then
        local master=$( head -n 1 "$state_dir/nodefile" )
        if [ "$master" = "$(hostname -s)" ] ; then
            return 0
        fi
        if [ "$master" = "$(hostname -f)" ] ; then
            return 0
        fi
    else
        log "E: no nodefile present"
    fi
    return 1
}

##########################################################
#                                                        #
#          S C R I P T     B E H A V I O R               #
#                                                        #
##########################################################

if [ "$1" = "help" ] ; then
    shift
    help $@
    exit $?
fi

if [ "$1" = "version" ] ; then
    shift
    sdpac --version
    exit $?
fi

if [ "$1" = "-s" ] ; then
    shift
    state_dir="$1"; shift
    if [ -z "$state_dir" ] ; then
        log "E: empty state dir"
        exit 1
    fi
    export SDPA_STATE_DIR="$state_dir"
fi

if [ -f "${state_dir}/kvs.host" ]
then
  kvs_host=$(cat "${state_dir}/kvs.host")
fi
if [ -f "${state_dir}/kvs.port" ]
then
  kvs_port=$(cat "${state_dir}/kvs.port")
fi

if [ "$1" = "init" ] ; then
    shift
    if ! initialize $@; then
        log "E: could not initialize!"
        exit 1
    else
        exit 0
    fi
fi

if [ "$1" = "gui" ] ; then
    shift
    start_gui $@
    exit $?
fi

function sigterm()
{
    trap sigterm TERM
}
trap sigterm TERM

function require_state ()
{
    if ! on_valid_host ; then
#    log "W: you are executing 'sdpa' on an invalid host!"
#    log "W: this might not be what you want"
#    log "I: please run 'sdpa init' on the master node first!"
        :
    fi
}

case "$1" in
    start)
        require_state
        shift
        start $@
        ;;
    stop)
        require_state
        if ! on_master_node ; then
            log "E: not on master node"
            exit 1
        fi
        shift
        stop $@
        ;;
    status)
        require_state
        if ! on_master_node ; then
            log "E: not on master node"
            exit 1
        fi
        shift
        status $@
        ;;
    submit)
        require_state
        shift
        submit $@
        ;;
    help)
        help
        ;;
    gui)
        shift
        start_gui $@
        ;;
    bundle)
        shift
        "${SDPA_SCRIPT_DIR}/bundle.sh" "$@"
        ;;
    boot)
        shift
        "${SDPA_SCRIPT_DIR}/start-sdpa" -S "$state_dir" -H "${SDPA_HOME}" "$@"
        ;;
    selftest)
        shift
        "${SDPA_SCRIPT_DIR}/sdpa-selftest" -s "${state_dir}" -H "${SDPA_HOME}" "${@}"
        ;;
    '')
        help
        ;;
    *)
        echo "E: unknown command: $1, try '$0 help'" >&2
        exit 1
        ;;
esac
