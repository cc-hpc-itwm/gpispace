#!/bin/bash
### avoid strange behaviour with temporary inconsistency
### on Panasas Filesystems:
###
###     the test -r was sucessful but the source didn't
###     source anything
###
###

gui=
force=false
debug=false
verbose=false
daemonize=false
backlog=-1
identity=0
name_prefix="drts"
master=
gpi_socket=
lib_path=
kvs_url=
count=
capabilities=""
state_dir="$HOME/.sdpa/state"
config_file="$HOME/.sdpa/configs/sdpa.rc"
logdir=
shm_size=

function usage ()
{
    cat >&2 <<EOF
usage: $(basename "$0") [options]

    -h: print this help
    -v: verbose
    -f: force: kill still running processes
    -i ident (=$identiy): identity
    -m master (=$master): master to connect to
    -n name prefix: name to prefix before hostname and identity
    -g ip:port (=$gui): gui address
    -b N (=$backlog): set the backlog
    -S path (=$gpi_socket): gpi socket path
    -l path: library path
    -k kvs-url (=$kvs_url): url to the key-value-store
    -c count: start this many processes (0==#cores)
    -C capability: start with this capability (can be specified more than once
    -D daemonize
    -L logfile
    -s state-dir
    -F config file
    -M shared memory size
    -B communication buffer size
EOF
}

# sends a given pid after N(=0) seconds to the background
function to_bg ()
{
    local pid="$1"; shift
    if [ -z "$pid" ] ; then
        return 1
    fi
    if ! kill -0 "$pid" &>/dev/null ; then
        return 2
    fi
    local when="$1"; shift
    if [ -z "$when" ] ; then
        when=0
    fi
    #echo "to_bg: sleeping $when second(s)"
    sleep $when
    #echo "to_bg: stopping $pid"
    # note: the builtin kill doesn't seem to to work always(?)
    /bin/kill -STOP "$pid"
    #echo "to_bg: resuming $pid"
    /bin/kill -CONT "$pid"
}

while getopts ":hvfg:m:i:b:S:l:k:Dc:C:L:s:n:M:F:B:" opt; do
    case $opt in
        h)
            usage
            exit 0
            ;;
        v)
            verbose=true
            ;;
        f)
            force=true
            ;;
        g)
            gui=$OPTARG
            ;;
        m)
            master=$OPTARG
            ;;
        i)
            if [ $OPTARG -le 0 ] ; then
                echo "identity must be greater than 0!" >&2
                exit 2
            fi
            identity=$OPTARG
            ;;
        b)
            backlog=$OPTARG
            ;;
        S)
            gpi_socket=$OPTARG
            ;;
        l)
            lib_path=$OPTARG
            ;;
        k)
            kvs_url=$OPTARG
            ;;
        D)
            daemonize=true
            ;;
        c)
            count="$OPTARG"
            ;;
        C)
            if [ -z "$capabilities" ] ; then
                capabilities="$OPTARG"
            else
                capabilities="$capabilities,$OPTARG"
            fi
            ;;
        L)
            logdir="$OPTARG"
            ;;
        s)
            state_dir="$OPTARG"
            ;;
        F)
            config_file="$OPTARG"
            ;;
        n)
            name_prefix="$OPTARG"
            ;;
        M)
            shm_size=$OPTARG
            ;;
        B)
            echo >&2 "W: ignoring obosolete option -B <com_size>"
            ;;
        \?)
            echo "invalid option: -$OPTARG" >&2
            echo "try: $0 -h" >&2
            exit 1
            ;;
    esac
done

# read sdpa state if it exists

if [ -r "${state_dir}/sdpa.env" ] ; then
    source "${state_dir}/sdpa.env"
else
    echo >&2 "needs to be executed under SDPA"
    exit 4
fi

if [ ! -r "${config_file}" ] ; then
    echo >&2 "config file '${config_file}' does not exist, aborting."
    exit 4
fi

if [ -z "$gui" ]
then
  gui=$(fhgcfg -f "${config_file}" -g sdpa.gui -v "$GUI_URL")
fi

gpi_enabled=$(fhgcfg -f "${config_file}" -g gpi.enabled -v true)
if [ $backlog -lt 0 ] ; then
    backlog=$(fhgcfg -f "${config_file}" -g plugin.drts.backlog -v 1)
fi

if [ -z "$lib_path" ]
then
    lib_path="$PC_LIBRARY_PATH"
fi

if [ -z "$kvs_url" ]
then
    kvs_url="${KVS_URL}"
fi


if [ -z "$kvs_url" ] ; then
    log "E: no kvs-url specified!"
    exit 1
fi

if [ -z "$master" ] ; then
    log "E: no master specified!"
    exit 1
fi

if [ x"$identity" == x"0" ] ; then
# quick hack to easily start multiple instances
    if [ -n "$count" ] ; then
        if [ $count -eq 0 ] ; then
            count=$(grep ^processor /proc/cpuinfo | wc -l)
        fi
        opts=
        opts="$opts -m $master"
        opts="$opts -k $kvs_url"
        opts="$opts -b $backlog"
        if [ -n "$gpi_socket" ] ; then
            opts="$opts -S $gpi_socket"
        fi
        opts="$opts -g $gui"
        opts="$opts -l ${lib_path}"
        opts="$opts -s $state_dir"
        opts="$opts -F $config_file"
        opts="$opts -n $name_prefix"

        if [ x"$force" = x"true" ] ; then
            opts="$opts -f"
        fi

        ec=0
        for i in $(seq 1 $count) ; do
            $0 -i $i $opts -D &
        done
        for i in $(jobs -p) ; do
            wait $i
            err=$?
            if [ $err -eq 1 ] ; then
                ec=$(( ec + 1 ))
            fi
        done
        if [ $ec -ne 0 ] ; then
            exit 1
        else
            exit 0
        fi
    fi
fi

name="${name_prefix}-$(hostname -s)-${identity}"

if [ -z "$logdir" ]
then
    logdir="${state_dir}/log"
fi
logprefix="${logdir}/${name}"

bin="$(which fhgkernel)"
if [ ! -x "$bin" ] ; then
  log "# could not find fhgkernel in the path!"
  exit 1
fi

# check if still running
still_running=$(ps -C fhgkernel -o pid=)
for p in $still_running ; do
    name_opt=$(cat /proc/$p/cmdline | tr '\0' '\n' | grep -A1 -e '-n' | tail -n 1)

    if [ "$name_opt" = "${name}" ] ; then
        if [ "$force" = "true" ] ; then
            log "W: $name is still running, terminating it"
            kill -TERM "$p"
            sleep 3
            kill -KILL "$p" &>/dev/null
        else
            log "E: $name still running, not starting again"
            exit 2
        fi
    fi
    unset name_opt
done

# config values (kernel)

cfg="$cfg -n $name"
cfg="$cfg -L $SDPA_PLUGINS"
lazy=$(fhgcfg -f "${config_file}" -g kernel.lazy -v false)
if [ x"$lazy" = x"true" ] ; then
    cfg="$cfg -s kernel.load.lazy=1"
else
    cfg="$cfg -s kernel.load.lazy=0"
fi

stateful=$(fhgcfg -f "${config_file}" -g sdpa.stateful -v false)
if [ x"$stateful" = x"true" ] ; then
    cfg="$cfg -S ${state_dir}/state/kernel/$name"
fi

# config values (kvs plugin)
kvs_host=$(echo "$kvs_url" | cut -d: -f1)
kvs_port=$(echo "$kvs_url" | cut -d: -f2)
cfg="$cfg -s plugin.kvs.host=$kvs_host"
cfg="$cfg -s plugin.kvs.port=$kvs_port"

# config values (logc plugin)
logc_port=$(fhgcfg -f "${config_file}" -g plugin.logd.port -v "3456")
logc_host=$(head -n 1 "${state_dir}/nodefile")
cfg="$cfg -s plugin.logc.url=${logc_host}:${logc_port}"

# config values (drts plugin)
cfg="$cfg -s plugin.drts.master=$master"
cfg="$cfg -s plugin.drts.backlog=$backlog"
cfg="$cfg -s plugin.drts.max_reconnect_attempts=$(fhgcfg -f "${config_file}" -g plugin.drts.max_reconnect_attempts -v 128)"
cfg="$cfg -s plugin.drts.capabilities=${capabilities}"

# config values (gpi plugin)
if [ -z "$gpi_socket" ] ; then
    gpi_socket=$(fhgcfg -f "${config_file}" -g gpi.socket_path -v "/tmp")
    numa_socket=0
    gpi_socket="$gpi_socket/S-gpi-space.$(id -u).${numa_socket}"
fi
cfg="$cfg -s plugin.gpi.socket=${gpi_socket}"
cfg="$cfg -s plugin.gpi.startmode=$(fhgcfg -f "${config_file}" -g plugin.gpi.startmode -v wait)"

if [ -z "$shm_size" ] ; then
    shm_size=$(fhgcfg -f "${config_file}" -g plugin.gpi_compat.shm_size -v 536870912)
fi

# config values (gpi_compat plugin)
cfg="$cfg -s plugin.gpi_compat.shm_size=$shm_size"

# config values (gui plugin)
cfg="$cfg -s plugin.gui.url=$gui"

# config values (wfe plugin)
cfg="$cfg -s plugin.wfe.library_path=${lib_path}"

plugins=$(fhgcfg -f "${config_file}" -g kernel.plugins)

plugin_load_flags=""
for p in $(echo $plugins | tr ',' ' '); do
    if [ x"$gpi_enabled" == x"false" ] ; then
        if echo $p | grep -q 'gpi' ; then
            continue
        fi
    fi
    plugin_load_flags="$plugin_load_flags $p"
done

cmd="${bin} $cfg $plugin_load_flags"

export FHGLOG_to_file="${logprefix}.log"
log "Running $cmd on node $hostname" >/dev/null 2>&1
if [ x"$daemonize" = x"true" ] ; then
    $cmd >"${logprefix}.out" 2>"${logprefix}.err" </dev/null &
else
    $cmd
fi
