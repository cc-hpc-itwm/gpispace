#!/bin/bash
### avoid strange behaviour with temporary inconsistency
### on Panasas Filesystems:
###
###     the test -r was sucessful but the source didn't
###     source anything
###
###

gui=
force=false
debug=false
verbose=false
daemonize=false
backlog=1
identity=0
name_prefix="drts"
master=
gpi_socket=
lib_path=
kvs_url=
count=
capabilities=""
state_dir="$HOME/.sdpa/state"
config_file="$HOME/.sdpa/configs/sdpa.rc"
logdir=
shm_size=
numa_socket=
DEFAULT_PLUGIN_DRTS_MAX_RECONNECT="128"
DEFAULT_KERNEL_LOAD_LAZY="true"
DEFAULT_PLUGIN_GPI_STARTMODE="wait"

function usage ()
{
    cat >&2 <<EOF
usage: $(basename "$0") [options]

    -h: print this help
    -v: verbose
    -f: force: kill still running processes
    -i ident (=$identiy): identity
    -m master (=$master): master to connect to
    -n name prefix: name to prefix before hostname and identity
    -g ip:port (=$gui): gui address
    -b N (=$backlog): set the backlog
    -S path (=$gpi_socket): gpi socket path
    -l path: library path
    -k kvs-url (=$kvs_url): url to the key-value-store
    -c count: start this many processes (0==#cores)
    -C capability: start with this capability (can be specified more than once
    -D daemonize
    -L logfile
    -s state-dir
    -F config file
    -M shared memory size, if not specified or empty, GPI is disabled
    -N numa socket
EOF
}

while getopts ":hvfg:m:i:b:S:l:k:Dc:C:L:s:n:M:F:N:" opt; do
    case $opt in
        h)
            usage
            exit 0
            ;;
        v)
            verbose=true
            ;;
        f)
            force=true
            ;;
        g)
            gui=$OPTARG
            ;;
        m)
            master=$OPTARG
            ;;
        i)
            if [ $OPTARG -le 0 ] ; then
                echo "identity must be greater than 0!" >&2
                exit 2
            fi
            identity=$OPTARG
            ;;
        b)
            if [ -z "$OPTARG" ]
            then
                echo >&2 "backlog must not be empty"
                exit 2
            fi
            if [ $OPTARG -le 0 ]
            then
                echo >&2 "backlog must not be less-or-equal 0"
                exit 2
            fi
            backlog=$OPTARG
            ;;
        S)
            gpi_socket=$OPTARG
            ;;
        l)
            lib_path=$OPTARG
            ;;
        k)
            kvs_url=$OPTARG
            ;;
        D)
            daemonize=true
            ;;
        c)
            count="$OPTARG"
            ;;
        C)
            if [ -z "$capabilities" ] ; then
                capabilities="$OPTARG"
            else
                capabilities="$capabilities,$OPTARG"
            fi
            ;;
        L)
            logdir="$OPTARG"
            ;;
        s)
            state_dir="$OPTARG"
            ;;
        F)
            config_file="$OPTARG"
            ;;
        n)
            name_prefix="$OPTARG"
            ;;
        M)
            shm_size=$OPTARG
            ;;
        N)
            numa_socket=$OPTARG
            ;;
        \?)
            echo "invalid option: -$OPTARG" >&2
            echo "try: $0 -h" >&2
            exit 1
            ;;
    esac
done

# read sdpa state if it exists

if [ -r "${state_dir}/sdpa.env" ] ; then
    source "${state_dir}/sdpa.env"
else
    echo >&2 "needs to be executed under SDPA"
    exit 4
fi

if [ ! -r "${config_file}" ] ; then
    echo >&2 "config file '${config_file}' does not exist, aborting."
    exit 4
fi

if [ -z "$gui" ]
then
    echo >&2 "gui url is required, please specify -g"
    exit 4
fi

if [ -z "$kvs_url" ]
then
    echo >&2 "kvs url is required, please specify -k"
    exit 4
fi

if [ -z "$master" ] ; then
    log "E: no master specified!"
    exit 1
fi

if [ -z "$shm_size" ] ; then
    gpi_enabled=false
else
    gpi_enabled=true
fi

if [ x"$identity" = x"0" ] ; then
# quick hack to easily start multiple instances
    if [ -n "$count" ] ; then
        if [ $count -eq 0 ] ; then
            count=$(grep ^processor /proc/cpuinfo | wc -l)
        fi
        opts=
        opts="$opts -m $master"
        opts="$opts -k $kvs_url"
        opts="$opts -b $backlog"
        if [ -n "$gpi_socket" ] ; then
            opts="$opts -S $gpi_socket"
        fi
        opts="$opts -g $gui"
        if [ -n "${lib_path}" ]
        then
            opts="$opts -l ${lib_path}"
        fi
        opts="$opts -s $state_dir"
        opts="$opts -F $config_file"
        opts="$opts -n $name_prefix"
        if [ -n "$shm_size" ]
        then
            opts="$opts -M $shm_size"
        fi
        if [ -n "$numa_socket" ]
        then
            opts="$opts -N $numa_socket"
        fi

        for cap in ${capabilities//,/ } ; do
            opts="$opts -C $cap"
        done

        if [ x"$force" = x"true" ] ; then
            opts="$opts -f"
        fi

        ec=0
        for i in $(seq 1 $count) ; do
            $0 -i $i $opts -D &
        done
        for i in $(jobs -p) ; do
            wait $i
            err=$?
            if [ $err -eq 1 ] ; then
                ec=$(( ec + 1 ))
            fi
        done
        if [ $ec -ne 0 ] ; then
            exit 1
        else
            exit 0
        fi
    fi
fi

name="${name_prefix}-$(hostname -s)-${identity}"
if [ -n "${numa_socket}" ]
then
    name="${name}.${numa_socket}"
fi

if [ -z "$logdir" ]
then
    logdir="${state_dir}/log"
fi
logprefix="${logdir}/${name}"

bin="$(which drts-kernel)"
if [ ! -x "$bin" ] ; then
  log "# could not find drts-kernel in the path!"
  exit 1
fi

# check if still running
still_running=$(ps -C drts-kernel -o pid=)
for p in $still_running ; do
    name_opt=$(cat /proc/$p/cmdline | tr '\0' '\n' | grep -A1 -e '^-n$' | tail -n 1)

    if [ "$name_opt" = "${name}" ] ; then
        if [ "$force" = "true" ] ; then
            log "W: $name is still running, terminating it"
            kill -TERM "$p"
            sleep 3
            kill -KILL "$p" &>/dev/null
        else
            log "E: $name still running, not starting again"
            exit 2
        fi
    fi
    unset name_opt
done

# config values (kernel)

cfg="$cfg -n $name"
cfg="$cfg -L $SDPA_HOME/libexec/fhg/plugins"
lazy=${DEFAULT_KERNEL_LOAD_LAZY}
if [ x"$lazy" = x"true" ] ; then
    cfg="$cfg -s kernel.load.lazy=1"
else
    cfg="$cfg -s kernel.load.lazy=0"
fi

if [ x"$gpi_enabled" = x"true" ] ; then
    cfg="$cfg --gpi_enabled"

    fake_gpi_capability="GPI-PGAS"

    if [ -z "$capabilities" ] ; then
      capabilities="${fake_gpi_capability}"
    else
      capabilities="$capabilities,${fake_gpi_capability}"
    fi

    # config values (gpi plugin)
    if [ -z "$gpi_socket" ] ; then
        log "E: GPI socket is not set"
        exit 1
    fi

    cfg="$cfg -s plugin.gpi.socket=${gpi_socket}"
    cfg="$cfg -s plugin.gpi.startmode=${DEFAULT_PLUGIN_GPI_STARTMODE}"

    # config values (gpi_compat plugin)
    cfg="$cfg -s plugin.gpi_compat.shm_size=$shm_size"
fi

# config values (drts plugin)
kvs_host=$(echo "$kvs_url" | cut -d: -f1)
kvs_port=$(echo "$kvs_url" | cut -d: -f2)
cfg="$cfg -s plugin.drts.kvs_host=$kvs_host"
cfg="$cfg -s plugin.drts.kvs_port=$kvs_port"
cfg="$cfg -s plugin.drts.master=$master"
cfg="$cfg -s plugin.drts.backlog=$backlog"
cfg="$cfg -s plugin.drts.max_reconnect_attempts=${DEFAULT_PLUGIN_DRTS_MAX_RECONNECT}"
cfg="$cfg -s plugin.drts.capabilities=${capabilities}"
cfg="$cfg -s plugin.drts.gui_url=$gui"
cfg="$cfg -s plugin.drts.library_path=${lib_path}"
if [ -n "$numa_socket" ]
then
    cfg="$cfg -s plugin.drts.socket=$numa_socket"
fi

cmd="${bin} $cfg"

export FHGLOG_to_file="${logprefix}.log"
log "Running $cmd on node $hostname" >/dev/null 2>&1
if [ x"$daemonize" = x"true" ] ; then
    $cmd --daemonize >"${logprefix}.out" 2>"${logprefix}.err"
else
    exec $cmd
fi
