#!/bin/bash
### avoid strange behaviour with temporary inconsistency
### on Panasas Filesystems:
###
###     the test -r was sucessful but the source didn't
###     source anything
###
###

gui=
force=false
debug=false
verbose=false
backlog=1
identity=0
name_prefix="drts"
master=
gpi_socket=
lib_path=
log_url=
count=
capabilities=""
state_dir="$HOME/.sdpa/state"
logdir=
shm_size=
numa_socket=
DEFAULT_PLUGIN_DRTS_MAX_RECONNECT="128"
DEFAULT_PLUGIN_GPI_STARTMODE="wait"
sdpa_home=

function usage ()
{
    cat >&2 <<EOF
usage: $(basename "$0") [options]

    -h: print this help
    -v: verbose
    -f: force: kill still running processes
    -i ident (=$identiy): identity
    -m master (=$master): master to connect to
    -n name prefix: name to prefix before hostname and identity
    -g ip:port (=$gui): gui address
    -b N (=$backlog): set the backlog
    -S path (=$gpi_socket): gpi socket path
    -L path: library path
    -c count: start this many processes (0==#cores)
    -C capability: start with this capability (can be specified more than once
    -s state-dir
    -M shared memory size, if not specified or empty, GPI is disabled
    -N numa socket
    -H sdpa-home
EOF
}

while getopts ":hvfg:l:m:i:b:S:k:K:c:C:L:s:n:M:N:H:" opt; do
    case $opt in
        h)
            usage
            exit 0
            ;;
        v)
            verbose=true
            ;;
        f)
            force=true
            ;;
        g)
            gui=$OPTARG
            ;;
        l)
            log_url=$OPTARG
            ;;
        m)
            master=$OPTARG
            ;;
        i)
            if [ $OPTARG -le 0 ] ; then
                echo "identity must be greater than 0!" >&2
                exit 2
            fi
            identity=$OPTARG
            ;;
        b)
            if [ -z "$OPTARG" ]
            then
                echo >&2 "backlog must not be empty"
                exit 2
            fi
            if [ $OPTARG -le 0 ]
            then
                echo >&2 "backlog must not be less-or-equal 0"
                exit 2
            fi
            backlog=$OPTARG
            ;;
        S)
            gpi_socket=$OPTARG
            ;;
        c)
            count="$OPTARG"
            ;;
        C)
            if [ -z "$capabilities" ] ; then
                capabilities="$OPTARG"
            else
                capabilities="$capabilities,$OPTARG"
            fi
            ;;
        L)
            if [ -z "${lib_path}" ]
            then
                lib_path="$OPTARG"
            else
                lib_path="${lib_path}:${OPTARG}"
            fi
            ;;
        s)
            state_dir="$OPTARG"
            ;;
        n)
            name_prefix="$OPTARG"
            ;;
        M)
            shm_size=$OPTARG
            ;;
        N)
            numa_socket=$OPTARG
            ;;
        H)
            sdpa_home="$OPTARG"
            ;;
        \?)
            echo "invalid option: -$OPTARG" >&2
            echo "try: $0 -h" >&2
            exit 1
            ;;
    esac
done

if [ -n "${log_url}" ]
then
    export FHGLOG_to_server="${log_url}"
fi

if [ -z "${sdpa_home}" ]
then
    echo >&2 "sdpa-home is empty, please specify -H"
    exit 4
fi

if [ -z "$gui" ]
then
    echo >&2 "gui url is required, please specify -g"
    exit 4
fi

if [ -z "$master" ] ; then
    echo >&2 "E: no master specified!"
    exit 1
fi

if [ -z "$shm_size" ] ; then
    gpi_enabled=false
else
    gpi_enabled=true
fi

if [ x"$identity" = x"0" ] ; then
# quick hack to easily start multiple instances
    if [ -n "$count" ] ; then
        if [ $count -eq 0 ] ; then
            count=$(grep ^processor /proc/cpuinfo | wc -l)
        fi
        opts=
        opts="$opts -H $sdpa_home"
        opts="$opts -m $master"
        opts="$opts -b $backlog"
        if [ -n "$gpi_socket" ] ; then
            opts="$opts -S $gpi_socket"
        fi
        opts="$opts -g $gui"
        if [ -n "${lib_path}" ]
        then
            opts="$opts -L ${lib_path}"
        fi
        opts="$opts -s $state_dir"
        opts="$opts -n $name_prefix"
        if [ -n "$shm_size" ]
        then
            opts="$opts -M $shm_size"
        fi
        if [ -n "$numa_socket" ]
        then
            opts="$opts -N $numa_socket"
        fi
        if [ -n "${log_url}" ]
        then
            opts="$opts -l ${log_url}"
        fi
        if $verbose
        then
            opts="$opts -v"
        fi

        for cap in ${capabilities//,/ } ; do
            opts="$opts -C $cap"
        done

        if [ x"$force" = x"true" ] ; then
            opts="$opts -f"
        fi

        ec=0
        for i in $(seq 1 $count) ; do
            $0 -i $i $opts &
        done
        for i in $(jobs -p) ; do
            wait $i
            err=$?
            if [ $err -eq 1 ] ; then
                ec=$(( ec + 1 ))
            fi
        done
        if [ $ec -ne 0 ] ; then
            exit 1
        else
            exit 0
        fi
    fi
fi

name="${name_prefix}-$(hostname -s)-${identity}"
if [ -n "${numa_socket}" ]
then
    name="${name}.${numa_socket}"
fi

if [ -z "$logdir" ]
then
    logdir="${state_dir}/log"
fi
logprefix="${logdir}/${name}"

exec 1> >(tee "${logprefix}.out")
exec 2> >(tee "${logprefix}.err" >&2)

bin="${sdpa_home}/bin/drts-kernel"
if [ ! -x "$bin" ] ; then
  echo >&2 "# could not find drts-kernel in '${sdpa_home}/bin'!"
  exit 1
fi

# check if still running
still_running=$(ps -C drts-kernel -o uid=,pid= | grep -e "^\s\+$(id -u)" | awk '{print $2}')
for p in $still_running ; do
    name_opt=$(cat /proc/$p/cmdline 2>/dev/null | tr '\0' '\n' | grep -A1 -e '^-n$' | tail -n 1)

    if [ "$name_opt" = "${name}" ] ; then
        if [ "$force" = "true" ] ; then
            echo >&2 "W: $name is still running, terminating it"
            kill -TERM "$p"
            sleep 3
            kill -KILL "$p" &>/dev/null
        else
            echo >&2 "E: $name still running, not starting again"
            exit 2
        fi
    fi
    unset name_opt
done

# config values (kernel)

arguments=
arguments="${arguments} --arguments -n $name"
arguments="${arguments} --arguments -L $sdpa_home/libexec/fhg/plugins"

if [ x"$gpi_enabled" = x"true" ] ; then
    arguments="${arguments} --arguments --gpi_enabled"

    fake_gpi_capability="GPI"

    if [ -z "$capabilities" ] ; then
      capabilities="${fake_gpi_capability}"
    else
      capabilities="$capabilities,${fake_gpi_capability}"
    fi

    # config values (gpi plugin)
    if [ -z "$gpi_socket" ] ; then
        echo >&2 "E: GPI socket is not set"
        exit 1
    fi

    arguments="${arguments} --arguments -s plugin.gpi.socket=${gpi_socket}"
    arguments="${arguments} --arguments -s plugin.gpi.startmode=${DEFAULT_PLUGIN_GPI_STARTMODE}"

    # config values (gpi_compat plugin)
    arguments="${arguments} --arguments -s plugin.gpi_compat.shm_size=$shm_size"
fi

# config values (drts plugin)
arguments="${arguments} --arguments -s plugin.drts.master=$master"
arguments="${arguments} --arguments -s plugin.drts.backlog=$backlog"
arguments="${arguments} --arguments -s plugin.drts.max_reconnect_attempts=${DEFAULT_PLUGIN_DRTS_MAX_RECONNECT}"
arguments="${arguments} --arguments -s plugin.drts.capabilities=${capabilities}"
arguments="${arguments} --arguments -s plugin.drts.gui_url=$gui"
arguments="${arguments} --arguments -s plugin.drts.library_path=${lib_path}"
if [ -n "$numa_socket" ]
then
    arguments="${arguments} --arguments -s plugin.drts.socket=$numa_socket"
fi

echo >&2 "I: starting worker: ${name} on host $(hostname) with parent ${master}"

mkdir -p "${state_dir}/fifos"
startup_messages_raw=$(${sdpa_home}/bin/start-and-fork \
  --fifo-directory "${state_dir}/fifos" \
  --end-sentinel-value OKAY \
  --startup-messages-fifo-option --startup-messages-fifo \
  \
  --command "${bin}" \
  ${arguments} \
  --environment LD_LIBRARY_PATH="${sdpa_home}/lib:${sdpa_home}/libexec/sdpa:${LD_LIBRARY_PATH}" \
  --environment FHGLOG_level=$(${verbose} && echo TRACE || echo INFO) \
  --environment FHGLOG_to_file="${logprefix}.log"
)
ec=${?}

old_IFS=${IFS}
IFS=$'\n'
startup_messages=(${startup_messages_raw})
IFS=${old_IFS}

if [ ${ec} -ne 0 ]
then
  exit ${ec}
fi

if [ ${#startup_messages[@]} != 1 ]; then
  echo >2 "could not start ${name}: expected 1 lines of startup messages"
  exit 1
fi
