#!/bin/bash

function usage ()
{
    cat >&2 <<EOF
usage: $(basename $0) [options]

  -h: this help
  -n: dry run
  -A path: add a path to the list of application search paths
  -f: node file to use
  -S: state directory to use
  -F: config file
  -m: amount of gpi memory to use
  -M: disable use of the memory layer
  -s: default amount of shared memory to use (=0)
  -d: do not delete logfiles
  -C: capability specification
  -G: number of segments

        format:
           <CAP>[+CAP1...][#socket][:N[xM][,shm]]

        examples:
           INIT:1x1,0
              exactly *one* INIT worker

           LOAD:2,16*2**20
              2 LOAD worker/node

           WRITE:2x4,16*2**20
              2 WRITE workers/node but on at most 4 nodes

           WRITE+LOAD:2
              2 workers/node with capabilities WRITE *and* LOAD
EOF
}

# catch CTRL-C and qdel the job
on_ctrlC()
{
        echo >&2 "Canceled..."
        sdpa stop
        exit 0
}

log()
{
    echo >&2 "$*"
}

info()
{
    log "I: $*"
}

warn()
{
    log "W: $*"
}

error()
{
    ec=$1; shift
    log "E: $*"
    exit $ec
}

dry_run_p=false
dry_run()
{
    if $dry_run_p ; then
        log "would run: $@"
    else
        "$@"
    fi
}

# helper function to execute something remotely
function rexec ()
{
    local node="$1"; shift
    local err
    local rc
    local ssh_opts="-q -x -T -n -C -4 -c arcfour,blowfish-cbc -o CheckHostIP=no -o StrictHostKeyChecking=no"
    local cmd="ssh $ssh_opts $node LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" $@"
    err=$($cmd </dev/null 2>&1)
    rc=$?
    if [ $rc -ne 0 ] ; then
        echo "$err" >&2
        return $rc
    else
        if [ -n "$err" ] ; then
            echo "$err"
        fi
        return 0
    fi
}

parse_capability()
{
    cap_spec="$1"; shift

    cap_spec_regex='^[^:#]+(#[0-9]+)?(:[0-9]+(x[0-9]+)?(,[^,]+)?)?$'

    if ! echo "$cap_spec" | grep -q -E "$cap_spec_regex" ; then
        error 1 "Invalid capability specification: $cap_spec"
    fi

    num_per_node=${def_num_proc}
    max_nodes=0
    shm_size="$def_shm_mem"

    capability_with_socket=$(echo "$cap_spec" | cut -d: -f1)
    capability=$(echo "$capability_with_socket" | cut -d# -f1)
    socket=$(echo "$capability_with_socket" | cut -s -d# -f 2)
    rest=$(echo "$cap_spec" | cut -s -d: -f 2)
    if [ -n "$rest" ] ; then
        amount_spec=$(echo "$rest" | cut -d, -f 1)
        rest=$(echo "$rest" | cut -s -d, -f 2-)
        num_per_node=$(echo "$amount_spec" | cut -dx -f 1)

        max_nodes=$(echo "$amount_spec" | cut -s -dx -f 2)
        if [ $num_per_node -eq 0 ] ; then
            warn "Invalid number of workers per node in capability specification!"
            warn "          input: $cap_spec"
            warn "   num_per_node: $num_per_node"
            error 1 "positive integer expected"
        fi
        if [ -z $max_nodes ] ; then
            max_nodes=0
        fi

        if [ -n "$rest" ] ; then
            shm_size=$(echo "$rest" | cut -d, -f 1)
        fi

    fi

    shm_size=$(( $shm_size ))

    if [ -z "${socket}" ]
    then
        socket=-1
    fi

    echo "$capability $num_per_node $max_nodes $shm_size $socket"
    return 0
}

# Execute function on_ctrlC() receiving SIGINT signal
#
trap 'on_ctrlC' SIGINT

DEFAULT_KVS_PORT=2439

nodefile=
state_dir="$HOME/.sdpa/state"
config_file="$HOME/.sdpa/configs/sdpa.rc"
gpi_enabled=true
delete_logfiles=true
app_path="${SDPA_APP_PATH}"
number_of_groups=1
kvs_port=
log_port=

# guess memory sizes
tot_mem=$(( $(grep ^MemTotal: /proc/meminfo | awk '{print $2}') * 1024 ))
avl_mem=$(( ($tot_mem * 80) / 100 ))
gpi_mem=0
gpi_socket=
def_shm_mem=0
def_num_proc=1
def_gpi_socket="/tmp/S-gpi-space.$(id -u)"

if [ ${#@} -eq 0 ] ; then
    usage
    exit 0
fi

shiftcount=0
while getopts ":hnf:S:m:s:C:F:p:MA:dG:" opt; do
    case $opt in
        h)
            usage
            exit 0
            ;;
        n)
            dry_run_p=true
            shiftcount=$(( shiftcount + 1 ))
            ;;
        f)
            nodefile="$OPTARG"
            shiftcount=$(( shiftcount + 2 ))
            ;;
        S)
            state_dir="$OPTARG"
            shiftcount=$(( shiftcount + 2 ))
            ;;
        m)
            gpi_mem=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        s)
            def_shm_mem=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        C)
            new_cap=$(parse_capability "$OPTARG")
            capabilities=( "${capabilities[@]}" $new_cap )
            shiftcount=$(( shiftcount + 2 ))
            ;;
        F)
            config_file="$OPTARG"
            shiftcount=$(( shiftcount + 2 ))
            ;;
        p)
            def_num_proc=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        M)
            gpi_enabled=false
            shiftcount=$(( shiftcount + 1 ))
            ;;
        A)
            if [ -n "${app_path}" ] ; then
                app_path="${app_path}:$OPTARG"
            else
                app_path="$OPTARG"
            fi
            shiftcount=$(( shiftcount + 2 ))
            ;;
        d)
            delete_logfiles=false
            shiftcount=$((shiftcount + 1))
            ;;
        G)
            number_of_groups=$OPTARG
            shiftcount=$((shiftcount + 2))
            ;;
        \?)
            echo >&2 "invalid option: $OPTARG"
            exit 1
            ;;
    esac
done

shift $shiftcount

for arg ; do
    new_cap=$(parse_capability "$arg")
    capabilities=( "${capabilities[@]}" $new_cap )
done

if [ -z "$nodefile" ] ; then
    error 1 "nodefile is missing"
fi

if [ -z "$SDPA_HOME" ] ; then
    error 2 "SDPA_HOME is not set!"
fi

if [ $number_of_groups -le 0 ] ; then
    error 2 "number of groups must be positive: found: $number_of_groups"
fi

if [ "${nodefile:0:1}" != "/" ]; then
    nodefile="$PWD/$nodefile"
fi

if [ ! -r "$nodefile" ] ; then
    error 2 "Could not read nodefile: $nodefile"
fi

if [ -z "${state_dir}" ] ; then
    error 1 "state directory not set"
fi

sdpa=$(which sdpa)
if [ $? -ne 0 ] ; then
    error 2 "could not locate 'sdpa' executable!"
fi

export SDPA_PERFORM_UNATTENDED_SETUP=1
if [ ! -e "${config_file}" ] ; then
    info "I: sdpa config does not exist, performing automated SDPA setup"

    dry_run "${sdpa}" -c "${config_file}" setup </dev/null || {
        mv "$HOME/.sdpa/configs/sdpa.rc" "$HOME/.sdpa/configs/sdpa.rc~"
        error 2 "I was unable to setup the SDPA environment for you."
    }
fi

script_start_drts="${SDPA_HOME}/libexec/sdpa/scripts/start-drts"
if [ ! -x "${script_start_drts}" ] ; then
    error 2 "utility script '${script_start_drts}' is not executable"
fi

script_start_agent="${SDPA_HOME}/libexec/sdpa/scripts/start-agent"
if [ ! -x "${script_start_agent}" ] ; then
    error 2 "utility script '${script_start_agent}' is not executable"
fi

script_start_orchestrator="${SDPA_HOME}/libexec/sdpa/scripts/start-orch"
if [ ! -x "${script_start_orchestrator}" ] ; then
    error 2 "utility script '${script_start_orchestrator}' is not executable"
fi

script_start_gpi="${SDPA_HOME}/libexec/sdpa/scripts/start-gpi"
if [ ! -x "${script_start_gpi}" ] ; then
    error 2 "utility script '${script_start_gpi}' is not executable"
fi

hosts=( $(cat "$nodefile" | uniq) )

if [ ${#hosts[@]} -eq 0 ] ; then
    error 1 "hostfile empty"
fi

master=${hosts[0]}
num_hosts=${#hosts[@]}

if [ $number_of_groups -gt $num_hosts ] ; then
    error 2 "number of groups must not be larger than number of hosts: $number_of_groups > $num_hosts"
fi

info "using nodefile: $nodefile"

info "using SHM mem: ${def_shm_mem} bytes per process (by default)"

dry_run rexec $master /usr/bin/env "${sdpa}" -s "${state_dir}" -c "${config_file}" init "$nodefile" </dev/null || {
    error 2 "could not initialize SDPA!"
}

if $delete_logfiles ; then
    find "${state_dir}/log" -type f -delete
fi

if [ -z "$kvs_port" ]
then
    kvs_port="${DEFAULT_KVS_PORT}"
fi

if [ -z "${log_port}" ]
then
    log_url=$(fhgcfg -f "${config_file}" -g "log.server.url")
    log_port=$(echo "$log_url" | grep -o -- ':[[:digit:]]\+' | tr -d ':')
    if [ -z "$log_port" ] ; then
        error 2 "setup incomplete, log port was not set"
    fi
fi

if [ -z "${gpi_socket}" ]
then
    gpi_socket="$def_gpi_socket"
fi

log "starting base sdpa components on $master..."

dry_run rexec $master ${sdpa} -s "${state_dir}" -c "${config_file}" start kvs ${kvs_port}
dry_run rexec $master "${script_start_orchestrator}" \
    -s "$state_dir" \
    -P "$state_dir/orchestrator.pid" \
    -D \
    -k "${master}:${kvs_port}" \
    -n "orchestrator"

if $gpi_enabled ; then
    # compute memory sizes
    if [ ${gpi_mem} -eq 0 ] ; then
        gpi_mem=$(( avl_mem * 50 / 100 ))
    fi

    info "using GPI mem: ${gpi_mem} bytes per node"

    "${script_start_gpi}" -s "$state_dir" \
                          -F "${config_file}" \
                          -D \
                          -f \
                          -P "$state_dir/gpi-space.pid" \
                          -m "$gpi_mem" \
                          -k "${master}" \
                          -K "$kvs_port" \
                          -l "${master}" \
                          -S "${gpi_socket}" \
                          -L "${log_port}"
fi

# for each capability:
#    for each host
#       - check maximum worker limit, break
#       - start additional workers, up to N

pids=()
max_background_tasks=8

function wait_on_pids ()
{
    local pid=
    for pid in ${pids[@]} ; do
        wait $pid
    done
    pids=()
}

function wait_if_necessary ()
{
    if [ ${#pids[@]} -ge ${max_background_tasks} ] ; then
        wait_on_pids
    fi
}

segment_host_index=()
segment_size=()
segment_master=()

function assign_segments
{
    if [ $number_of_groups -eq 1 ] ; then
        segment_host_index[0]=0
        segment_size[0]=${num_hosts}
        segment_master=("agent-${master}-0")
    else
        local i=
        local hosts_per_group=$(( ${num_hosts} / ${number_of_groups} ))
        local remaining_hosts=$(( ${num_hosts} % ${number_of_groups} ))
        local host=
        local offset=0
        for ((i=0 ; i < $number_of_groups ; ++i)) ; do
            segment_host_index[$i]=${offset}
            segment_size[$i]=${hosts_per_group}
            host=${hosts[$offset]}
            segment_master[$i]="agent-${host}-1"

            offset=$((offset + hosts_per_group))
        done

        # add remaining hosts to last group
        segment_size[$((number_of_groups - 1))]=$((hosts_per_group + remaining_hosts))
    fi
}

function start_agent
{
    local host="$1" ; shift
    local name="$1" ; shift
    local parent="$1" ; shift

    info "starting agent: ${name} on host ${host} with parent ${parent}"

    dry_run rexec ${host} "${script_start_agent}" \
        -D \
        -n "${name}" \
        -m "${parent}" \
        -s "${state_dir}" \
        -k "${master}:${kvs_port}" \
        -F "${config_file}" &
    pids+=( $! )
}

function start_agents
{
    start_agent ${master} "agent-${master}-0" "orchestrator"
    ec=$?

    if [ ${#segment_master[@]} -eq 1 ] ; then
        return $ec
    fi

    local i=
    for ((i = 0 ; i < ${#segment_master[@]} ; ++i)) ; do
        host_idx=${segment_host_index[$i]}
        host=${hosts[${host_idx}]}
        name="agent-${host}-1"

        start_agent "${host}" "${name}" "agent-${master}-0"
        wait_if_necessary
    done
}

function start_workers_for_capability
{
    local segment="$1"      ; shift
    local capability="$1"   ; shift
    local num_per_node="$1" ; shift
    local max_nodes="$1"    ; shift
    local shm_size="$1"     ; shift
    local socket="$1"       ; shift

    human_max="global max: $max_nodes"
    if [ $max_nodes -eq 0 ] ; then
        human_max="unlimited"
    elif [ $max_nodes -eq 1 ] ; then
        human_max="unique"
    fi
    info "starting $capability workers (segment $segment, $num_per_node/host, $human_max, $shm_size SHM)..."

    num_nodes=0
    caps_arg=$(echo "$capability" | tr '+' '\n' | xargs -n1 echo '-C')

    parent=${segment_master[$segment]}
    group_start=${segment_host_index[$segment]}
    group_size=${segment_size[$segment]}
    group_end=$((group_start + group_size))

    local i=
    for ((i=${group_start} ; i < ${group_end} ; ++i)) ; do
        host=${hosts[$i]}

        local name="$capability"

        argv=()
        argv+=(-D)
        argv+=(-c $num_per_node)
        argv+=(-n "$name")
        argv+=(-m "$parent")
        argv+=(-k "$master:${kvs_port}")
        argv+=($caps_arg)
        argv+=(-s "$state_dir")
        argv+=(-F "$config_file")
        if $gpi_enabled ; then
            argv+=(-M "$shm_size")
            argv+=(-S "$gpi_socket")
        fi
        if [ $socket -ne -1 ] ; then
            argv+=(-N "$socket")
        fi
        if [ -n "${app_path}" ]
        then
            argv+=(-l "${app_path}")
        fi

        dry_run rexec $host "$script_start_drts" "${argv[@]}" &

        pids+=( $! )

        wait_if_necessary

        num_nodes=$(( num_nodes + 1 ))

        if [ $num_nodes -eq $max_nodes ] ; then
            break
        fi
    done
}

function start_workers
{
    local seg=
    for (( seg=0 ; seg < ${number_of_groups} ; ++seg )) ; do
        sizeof_capstruct=5
        local i=
        for (( i=0 ; i < ${#capabilities[@]} ; i += $sizeof_capstruct )) ; do
            capability=${capabilities[   $(( i+0 )) ]}
            num_per_node=${capabilities[ $(( i+1 )) ]}
            max_nodes=${capabilities[    $(( i+2 )) ]}
            shm_size=${capabilities[     $(( i+3 )) ]}
            socket=${capabilities[       $(( i+4 )) ]}
            start_workers_for_capability $seg "$capability" "$num_per_node" "$max_nodes" "$shm_size" "$socket"
        done
    done
}

assign_segments
start_agents
wait_on_pids

start_workers
wait_on_pids
