#!/bin/bash

function usage ()
{
    cat >&2 <<EOF
usage: $(basename $0) [options]

  -h: this help
  -n: dry run
  -A path: add a path to the list of application search paths
  -f: node file to use
  -S: state directory to use
  -F: config file
  -m: amount of gpi memory to use
  -M: disable use of the memory layer
  -s: default amount of shared memory to use (=0)
  -c: ignored (accepted for backward compatibility)
  -C: capability specification

        format:
           <CAP>[+CAP1...][:N[xM][,shm]]

        examples:
           INIT:1x1,0
              exactly *one* INIT worker

           LOAD:2,16*2**20
              2 LOAD worker/node

           WRITE:2x4,16*2**20
              2 WRITE workers/node but on at most 4 nodes
EOF
}

# catch CTRL-C and qdel the job
on_ctrlC()
{
        echo >&2 "Canceled..."
        sdpa stop
        exit 0
}

log()
{
    echo >&2 "$*"
}

info()
{
    log "I: $*"
}

warn()
{
    log "W: $*"
}

error()
{
    ec=$1; shift
    log "E: $*"
    exit $ec
}

dry_run_p=false
dry_run()
{
    if $dry_run_p ; then
        log "would run: $@"
    else
        "$@"
    fi
}

# helper function to execute something remotely
function rexec ()
{
    local node="$1"; shift
    local err
    local rc
    local ssh_opts="-q -x -T -n -C -4 -c arcfour,blowfish-cbc -o CheckHostIP=no -o StrictHostKeyChecking=no"
    local cmd="ssh $ssh_opts $node $@"
    err=$($cmd </dev/null 2>&1)
    rc=$?
    if [ $rc -ne 0 ] ; then
        echo "$err" >&2
        return $rc
    else
        if [ -n "$err" ] ; then
            echo "$err"
        fi
        return 0
    fi
}

parse_capability()
{
    cap_spec="$1"; shift

    cap_spec_regex='^[^:]+(:[0-9]+(x[0-9]+)?(,[^,]+)?)?$'

    if ! echo "$cap_spec" | grep -q -E "$cap_spec_regex" ; then
        error 1 "Invalid capability specification: $cap_spec"
    fi

    num_per_node=${def_num_proc}
    max_nodes=0
    shm_size="$def_shm_mem"

    capability=$(echo "$cap_spec" | cut -d: -f1)
    rest=$(echo "$cap_spec" | cut -s -d: -f 2)
    if [ -n "$rest" ] ; then
        amount_spec=$(echo "$rest" | cut -d, -f 1)
        rest=$(echo "$rest" | cut -s -d, -f 2-)
        num_per_node=$(echo "$amount_spec" | cut -dx -f 1)

        max_nodes=$(echo "$amount_spec" | cut -s -dx -f 2)
        if [ $num_per_node -eq 0 ] ; then
            warn "Invalid number of workers per node in capability specification!"
            warn "          input: $cap_spec"
            warn "   num_per_node: $num_per_node"
            error 1 "positive integer expected"
        fi
        if [ -z $max_nodes ] ; then
            max_nodes=0
        fi

        if [ -n "$rest" ] ; then
            shm_size=$(echo "$rest" | cut -d, -f 1)
        fi

    fi

    shm_size=$(( $shm_size ))

    echo "$capability $num_per_node $max_nodes $shm_size"
    return 0
}

# Execute function on_ctrlC() receiving SIGINT signal
#
#trap 'on_ctrlC' SIGINT

nodefile="$PBS_NODEFILE"
state_dir="$HOME/.sdpa/state"
config_file="$HOME/.sdpa/configs/sdpa.rc"
gpi_enabled=true
app_path="${SDPA_APP_PATH}"

# guess memory sizes
tot_mem=$(( $(grep ^MemTotal: /proc/meminfo | awk '{print $2}') * 1024 ))
avl_mem=$(( ($tot_mem * 80) / 100 ))
gpi_mem=0
def_shm_mem=0
def_num_proc=1

if [ ${#@} -eq 0 ] ; then
    usage
    exit 0
fi

shiftcount=0
while getopts ":hnf:S:m:s:c:C:F:p:MA:" opt; do
    case $opt in
        h)
            usage
            exit 0
            ;;
        n)
            dry_run_p=true
            shiftcount=$(( shiftcount + 1 ))
            ;;
        f)
            nodefile="$OPTARG"
            shiftcount=$(( shiftcount + 2 ))
            ;;
        S)
            state_dir="$OPTARG"
            shiftcount=$(( shiftcount + 2 ))
            ;;
        m)
            gpi_mem=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        s)
            def_shm_mem=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        c)
            shiftcount=$(( shiftcount + 2 ))
            ;;
        C)
            new_cap=$(parse_capability "$OPTARG")
            capabilities=( "${capabilities[@]}" $new_cap )
            shiftcount=$(( shiftcount + 2 ))
            ;;
        F)
            config_file="$OPTARG"
            shiftcount=$(( shiftcount + 2 ))
            ;;
        p)
            def_num_proc=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        M)
            gpi_enabled=false
            shiftcount=$(( shiftcount + 1 ))
            ;;
        A)
            if [ -n "${app_path}" ] ; then
                app_path="${app_path}:$OPTARG"
            else
                app_path="$OPTARG"
            fi
            shiftcount=$(( shiftcount + 2 ))
            ;;
        \?)
            echo >&2 "invalid option: $OPTARG"
            exit 1
            ;;
    esac
done

shift $shiftcount

for arg ; do
    new_cap=$(parse_capability "$arg")
    capabilities=( "${capabilities[@]}" $new_cap )
done

if [ -z "$nodefile" ] ; then
    error 1 "nodefile is missing"
fi

if [ -z "$SDPA_HOME" ] ; then
    error 2 "SDPA_HOME is not set!"
fi

if [ "${nodefile:0:1}" != "/" ]; then
    nodefile="$PWD/$nodefile"
fi

if [ ! -r "$nodefile" ] ; then
    error 2 "Could not read nodefile: $nodefile"
fi

if [ -z "${state_dir}" ] ; then
    error 1 "state directory not set"
fi

sdpa=$(which sdpa)
if [ $? -ne 0 ] ; then
    error 2 "could not locate 'sdpa' executable!"
fi

export SDPA_PERFORM_UNATTENDED_SETUP=1
if [ ! -e "${config_file}" ] ; then
    info "I: sdpa config does not exist, performing automated SDPA setup"

    dry_run "${sdpa}" -c "${config_file}" setup </dev/null || {
        mv "$HOME/.sdpa/configs/sdpa.rc" "$HOME/.sdpa/configs/sdpa.rc~"
        error 2 "I was unable to setup the SDPA environment for you."
    }
fi

hosts=( $(cat "$nodefile" | uniq) )

if [ ${#hosts[@]} -eq 0 ] ; then
    error 1 "hostfile empty"
fi

master=${hosts[0]}
num_hosts=${#hosts[@]}

info "using nodefile: $nodefile"

info "using SHM mem: ${def_shm_mem} bytes per process (by default)"

dry_run rexec $master /usr/bin/env SDPA_APP_PATH="${app_path}" LD_LIBRARY_PATH="$LD_LIBRARY_PATH" "${sdpa}" -s "${state_dir}" -c "${config_file}" init "$nodefile" </dev/null || {
    error 2 "could not initialize SDPA!"
}

if $gpi_enabled ; then
    # compute memory sizes
    if [ ${gpi_mem} -eq 0 ] ; then
        gpi_mem=$(( avl_mem * 50 / 100 ))
    fi

    socket_path=$(fhgcfg -f "${config_file}" -g "gpi.socket_path" -v "/tmp")

    # set memory sizes - choose reasonable defaults (depending on local machines)
    dry_run fhgcfg -f "${config_file}" -a "gpi.memory_size" -v "$gpi_mem"
    dry_run fhgcfg -f "${config_file}" -a "gpi.socket_path" -v "$socket_path"
    dry_run fhgcfg -f "${config_file}" -a "gpi.enabled" -v "true"

    info "using GPI mem: ${gpi_mem} bytes per node"
else
    dry_run fhgcfg -f "${config_file}" -a "gpi.enabled" -v "false"
fi

# set up topology
dry_run fhgcfg -f "${config_file}" -a "topology.per-node" -v 1
dry_run fhgcfg -f "${config_file}" -a "topology.with-mediator" -v "false"

scratch_dir=$(fhgcfg -f "${config_file}" -g sdpa.scratch_dir)
if [ -z "$scratch_dir" ] ; then
    scratch_dir="$HOME/.sdpa/scratch"
fi

log "starting base sdpa components on $master..."

dry_run rexec $master ${sdpa} -s "${state_dir}" -c "${config_file}" start kvs
dry_run rexec $master ${sdpa} -s "${state_dir}" -c "${config_file}" start gpi
dry_run rexec $master ${sdpa} -s "${state_dir}" -c "${config_file}" start orch
dry_run rexec $master ${sdpa} -s "${state_dir}" -c "${config_file}" start agg

# for each capability:
#    for each host
#       - check maximum worker limit, break
#       - start additional workers, up to N

function start_workers_for_capability
{
    local capability="$1"   ; shift
    local num_per_node="$1" ; shift
    local max_nodes="$1"    ; shift
    local shm_size="$1"     ; shift

    human_max="global max: $max_nodes"
    if [ $max_nodes -eq 0 ] ; then
        human_max="unlimited"
    elif [ $max_nodes -eq 1 ] ; then
        human_max="unique"
    fi
    info "starting $capability workers ($num_per_node/host, $human_max, $shm_size SHM)..."

    num_nodes=0
    start_drts="${SDPA_HOME}/libexec/sdpa/scripts/start-drts"
    caps_arg=$(echo "$capability" | tr '+' '\n' | xargs -n1 echo '-C')

    for host in ${hosts[@]} ; do
        id=1

        for (( j = 0 ; j < $num_per_node ; j += 1 )) ; do

            info "start $capability on $host ($j of $num_per_node)"

            dry_run rexec $host "$start_drts" -D -i ${id} -n "$capability" \
                                              -m aggregator $caps_arg \
                                              -s "$state_dir" \
                                              -F "$config_file" \
                                              -M "$shm_size"
            id=$(( id + 1 ))
        done

        num_nodes=$(( num_nodes + 1 ))

        if [ $num_nodes -eq $max_nodes ] ; then
            break
        fi
    done
}

sizeof_capstruct=4
count=0
for (( i=0 ; i < ${#capabilities[@]} ; i += $sizeof_capstruct )) ; do
    capability=${capabilities[   $(( i+0 )) ]}
    num_per_node=${capabilities[ $(( i+1 )) ]}
    max_nodes=${capabilities[    $(( i+2 )) ]}
    shm_size=${capabilities[     $(( i+3 )) ]}

    start_workers_for_capability "$capability" "$num_per_node" "$max_nodes" "$shm_size" &
    count=$((count+1))
    if [ $count -gt 2 ] ; then
      count=0
      wait
    fi
done
wait
