#!/bin/bash

kvs_port=2439

DEFAULT_LOG_PORT="$(( (65535 - 30000 + $(id -u) * 2) % 65535 + 1024 + 0))"
DEFAULT_GUI_PORT="$(( (65535 - 30000 + $(id -u) * 2) % 65535 + 1024 + 1))"
log_url="$(hostname -s):${DEFAULT_LOG_PORT}"
gui_url="$(hostname -s):${DEFAULT_GUI_PORT}"

function usage ()
{
    cat >&2 <<EOF
usage: $(basename $0) [options]

  -h: this help
  -v: be verbose
  -n: dry run
  -A path: add a path to the list of application search paths
  -f: node file to use
  -S: state directory to use
  -m: amount of gpi memory to use
  -M: disable use of the memory layer
  -s: default amount of shared memory to use (=0)
  -d: do not delete logfiles
  -C: capability specification
  -G: number of segments
  -x: GPI binary to execute

        This binary has to point to the 'gpi-space' application found
        in '\$SDPA_HOME/bin/gpi-space', but has to reside in the GPI
        privileged folder in case you are executing on a cluster. One
        also has to put dependencies besides the application:

             PRIV_DIR=<gpi-privileged-dir>
             mkdir -p "\$PRIV_DIR"/gpi-space.app/{bin,lib}
             cp "\$SDPA_HOME/bin/gpi-space" "\$PRIV_DIR/gpi-space.app/bin"
             "\$SDPA_HOME/bin/sdpa" bundle -o "\$PRIV_DIR/gpi-space.app/lib" "\$PRIV_DIR/gpi-space.app/bin/gpi-space"

        Please contact your local administrator responsible for GPI in
        case you don't have permissions for that folder.

  -k: kvs port (=$kvs_port)
  -l: log url (=${log_url})
  -g: gui url (=${gui_url})

        format:
           <CAP>[+CAP1...][#socket][:N[xM][,shm]]

        examples:
           INIT:1x1,0
              exactly *one* INIT worker

           LOAD:2,16*2**20
              2 LOAD worker/node

           WRITE:2x4,16*2**20
              2 WRITE workers/node but on at most 4 nodes

           WRITE+LOAD:2
              2 workers/node with capabilities WRITE *and* LOAD
EOF
}

# catch CTRL-C and qdel the job
on_ctrlC()
{
        echo >&2 "Canceled..."
        "${sdpa}" -s "${state_dir}" stop
        exit 0
}

log()
{
    echo >&2 "$*"
}

info()
{
    log "I: $*"
}

warn()
{
    log "W: $*"
}

error()
{
    ec=$1; shift
    log "E: $*"
    exit $ec
}

assert_not_empty()
{
    local var="$1"; shift
    local val=$(eval echo "\${$var}")

    if [ -z "$val" ]
    then
        error 2 "'${var}' must not be empty"
    fi
}

dry_run_p=false
dry_run()
{
    if $dry_run_p ; then
        log "would run: $@"
    else
        "$@"
    fi
}

# helper function to execute something remotely
function rexec ()
{
    local node="$1"; shift
    local err
    local rc
    local ssh_opts="-q -x -T -n -C -4 -c arcfour,blowfish-cbc -o CheckHostIP=no -o StrictHostKeyChecking=no"
    local cmd="ssh $ssh_opts $node /usr/bin/env LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" $@"
    err=$($cmd </dev/null 2>&1)
    rc=$?
    if [ $rc -ne 0 ] ; then
        echo "$err" >&2
        return $rc
    else
        if [ -n "$err" ] ; then
            echo "$err"
        fi
        return 0
    fi
}

parse_capability()
{
    cap_spec="$1"; shift

    cap_spec_regex='^[^:#]+(#[0-9]+)?(:[0-9]+(x[0-9]+)?(,[^,]+)?)?$'

    if ! echo "$cap_spec" | grep -q -E "$cap_spec_regex" ; then
        error 1 "Invalid capability specification: $cap_spec"
    fi

    num_per_node=${def_num_proc}
    max_nodes=0
    shm_size="$def_shm_mem"

    capability_with_socket=$(echo "$cap_spec" | cut -d: -f1)
    capability=$(echo "$capability_with_socket" | cut -d# -f1)
    socket=$(echo "$capability_with_socket" | cut -s -d# -f 2)
    rest=$(echo "$cap_spec" | cut -s -d: -f 2)
    if [ -n "$rest" ] ; then
        amount_spec=$(echo "$rest" | cut -d, -f 1)
        rest=$(echo "$rest" | cut -s -d, -f 2-)
        num_per_node=$(echo "$amount_spec" | cut -dx -f 1)

        max_nodes=$(echo "$amount_spec" | cut -s -dx -f 2)
        if [ $num_per_node -eq 0 ] ; then
            warn "Invalid number of workers per node in capability specification!"
            warn "          input: $cap_spec"
            warn "   num_per_node: $num_per_node"
            error 1 "positive integer expected"
        fi
        if [ -z $max_nodes ] ; then
            max_nodes=0
        fi

        if [ -n "$rest" ] ; then
            shm_size=$(echo "$rest" | cut -d, -f 1)
        fi
    fi

    if [ -z $socket ] ; then
        socket=-1
    fi

    shm_size=$(( $shm_size ))

    if [ -z "${socket}" ]
    then
        socket=-1
    fi

    echo "$capability $num_per_node $max_nodes $shm_size $socket"
    return 0
}

# wait_for_port_on_host timeout host port
function wait_for_port_on_host ()
{
    local deadline="${1}"; shift
    local host="${1}"; shift
    local port="${1}"; shift

    local check_port=$(which nc 2>/dev/null)
    if [ $? -ne 0 ]
    then
        error 1 "could not locate tool 'nc', cannot wait for '${host}:${port}'"
    fi

    until [ ${deadline} -eq 0 ]
    do
        ${check_port} -w 1 "${host}" "${port}" </dev/null
        if [ $? -eq 0 ]
        then
            return 0
        fi
        deadline=$((deadline - 1))
    done
}

function wait_for_process ()
{
    local deadline="${1}"; shift
    local name="${1}"; shift
    local kvs_host="${1}"; shift
    local kvs_port="${1}"; shift

    local host_port=()

    until [ $deadline -eq 0 ]
    do
        host_port=( $("${sdpa_home}/bin/fhgkvsc" -H "${kvs_host}" -P "${kvs_port}" -g p2p.peer | grep -B 2 "$name" | head -n 2 | awk '{print $3}') )
        if [ ${#host_port[@]} -eq 2 ]
        then
            if wait_for_port_on_host 1 "${host_port[0]}" "${host_port[1]}"
            then
                return 0
            fi
        fi
        sleep 1
        deadline=$((deadline - 1))
    done
}

# Execute function on_ctrlC() receiving SIGINT signal
#
trap 'on_ctrlC' SIGINT

nodefile=
verbose=false
state_dir="$HOME/.sdpa/state"
gpi_enabled=true
delete_logfiles=true
app_path=
number_of_groups=1
kvs_timeout=15

# guess memory sizes
tot_mem=$(( $(grep ^MemTotal: /proc/meminfo | awk '{print $2}') * 1024 ))
avl_mem=$(( ($tot_mem * 80) / 100 ))
gpi_exe=
gpi_mem=0
gpi_socket=
def_shm_mem=0
def_num_proc=1
def_gpi_socket="/tmp/S-gpi-space.$(id -u)"

if [ ${#@} -eq 0 ] ; then
    usage
    exit 0
fi

shiftcount=0
while getopts ":hvnf:S:m:s:C:p:MA:dG:k:x:l:g:H:" opt; do
    case $opt in
        h)
            usage
            exit 0
            ;;
        v)
            verbose=true
            shiftcount=$((shiftcount + 1))
            ;;
        n)
            dry_run_p=true
            shiftcount=$(( shiftcount + 1 ))
            ;;
        f)
            nodefile="$OPTARG"
            assert_not_empty nodefile
            shiftcount=$(( shiftcount + 2 ))
            ;;
        S)
            state_dir="$OPTARG"
            assert_not_empty state_dir
            shiftcount=$(( shiftcount + 2 ))
            ;;
        m)
            gpi_mem=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        s)
            def_shm_mem=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        C)
            new_cap=$(parse_capability "$OPTARG")
            capabilities=( "${capabilities[@]}" $new_cap )
            shiftcount=$(( shiftcount + 2 ))
            ;;
        p)
            def_num_proc=$(( $OPTARG ))
            shiftcount=$(( shiftcount + 2 ))
            ;;
        M)
            gpi_enabled=false
            shiftcount=$(( shiftcount + 1 ))
            ;;
        A)
            if [ -n "${app_path}" ] ; then
                app_path="${app_path}:$OPTARG"
            else
                app_path="$OPTARG"
            fi
            shiftcount=$(( shiftcount + 2 ))
            ;;
        d)
            delete_logfiles=false
            shiftcount=$((shiftcount + 1))
            ;;
        G)
            number_of_groups=$OPTARG
            shiftcount=$((shiftcount + 2))
            ;;
        k)
            kvs_port=$OPTARG
            assert_not_empty kvs_port
            shiftcount=$((shiftcount + 2))
            ;;
        x)
            gpi_exe="$OPTARG"
            assert_not_empty gpi_exe
            shiftcount=$((shiftcount + 2))
            ;;
        l)
            log_url="$OPTARG"
            assert_not_empty log_url
            shiftcount=$((shiftcount + 2))
            ;;
        g)
            gui_url="$OPTARG"
            assert_not_empty gui_url
            shiftcount=$((shiftcount + 2))
            ;;
        H)
            sdpa_home="$OPTARG"
            assert_not_empty sdpa_home
            shiftcount=$((shiftcount + 2))
            ;;
        \?)
            echo >&2 "invalid option: $OPTARG"
            exit 1
            ;;
    esac
done

shift $shiftcount

for arg ; do
    new_cap=$(parse_capability "$arg")
    capabilities=( "${capabilities[@]}" $new_cap )
done

# sanity checks

if [ -z "$nodefile" ] ; then
    error 1 "nodefile is missing (-f)"
fi

if [ -z "$sdpa_home" ] ; then
    error 2 "sdpa home is not set, please specify -H"
fi

if [ $number_of_groups -le 0 ] ; then
    error 2 "number of groups must be positive: found: $number_of_groups"
fi

if [ "${nodefile:0:1}" != "/" ]; then
    nodefile="$PWD/$nodefile"
fi

if [ ! -r "$nodefile" ] ; then
    error 2 "Could not read nodefile: $nodefile"
fi

log_host=${log_url%:*}
log_port=${log_url#*:}

gui_host=${gui_url%:*}
gui_port=${gui_url#*:}

if [ -z "${gpi_socket}" ]
then
    gpi_socket="$def_gpi_socket"
fi

hosts=( $(cat "$nodefile" | uniq) )

if [ ${#hosts[@]} -eq 0 ] ; then
    error 1 "hostfile empty"
fi

master=${hosts[0]}
num_hosts=${#hosts[@]}

if $gpi_enabled ; then
    if [ -z "${gpi_exe}" ]
    then
        error 2 "No virtual memory binary was specified (-x), to disable the virtual memory specify -M"
    fi
    if [ ! -x "${gpi_exe}" ]
    then
        error 2 "GPI binary ($gpi_exe) is not executable!"
    fi
fi

if [ $number_of_groups -gt $num_hosts ] ; then
    error 2 "number of groups must not be larger than number of hosts: $number_of_groups > $num_hosts"
fi


sdpa="${sdpa_home}/bin/sdpa"
if [ $? -ne 0 ] ; then
    error 2 "could not locate 'sdpa' executable!"
fi

script_start_drts="${sdpa_home}/libexec/sdpa/scripts/start-drts"
if [ ! -x "${script_start_drts}" ] ; then
    error 2 "utility script '${script_start_drts}' is not executable"
fi

script_start_agent="${sdpa_home}/libexec/sdpa/scripts/start-agent"
if [ ! -x "${script_start_agent}" ] ; then
    error 2 "utility script '${script_start_agent}' is not executable"
fi

script_start_orchestrator="${sdpa_home}/libexec/sdpa/scripts/start-orch"
if [ ! -x "${script_start_orchestrator}" ] ; then
    error 2 "utility script '${script_start_orchestrator}' is not executable"
fi

script_start_gpi="${sdpa_home}/libexec/sdpa/scripts/start-gpi"
if [ ! -x "${script_start_gpi}" ] ; then
    error 2 "utility script '${script_start_gpi}' is not executable"
fi

info "using nodefile: $nodefile"

dry_run rexec $master /usr/bin/env "${sdpa}" -s "${state_dir}" init "$nodefile" </dev/null || {
    error 2 "could not initialize SDPA!"
}

if $delete_logfiles ; then
    find "${state_dir}/log" -type f -delete
fi

log "starting base sdpa components on $master..."
info "sending log events to: ${log_url}"
info "sending execution events to: ${gui_url}"

if $verbose
then
    opt_verbose_flag="-v"
else
    opt_verbose_flag=""
fi

dry_run rexec $master ${sdpa} -s "${state_dir}" start kvs ${kvs_port}
ec=$?
if [ $ec -ne 0 ]
then
    "${sdpa}" -s "${state_dir}" stop
    error 3 "could not start kvs"
fi

if ! wait_for_port_on_host ${kvs_timeout} "${master}" "${kvs_port}"
then
    "${sdpa}" -s "${state_dir}" stop
    error 3 "could not start kvs: failed after ${kvs_timeout} seconds"
fi

dry_run rexec $master "${script_start_orchestrator}" \
    $opt_verbose_flag \
    -s "$state_dir" \
    -P "$state_dir/orchestrator.pid" \
    -D \
    -k "${master}:${kvs_port}" \
    -l "${log_host}:${log_port}" \
    -H "${sdpa_home}" \
    -n "orchestrator"
ec=$?
if [ $ec -ne 0 ]
then
    "${sdpa}" -s "${state_dir}" stop
    error 3 "could not start orchestrator"
fi

if ! wait_for_process ${kvs_timeout} "orchestrator" "${master}" "${kvs_port}"
then
    "${sdpa}" -s "${state_dir}" stop
    error 3 "could not start orchestrator after ${kvs_timeout} seconds"
fi

if $gpi_enabled ; then
    # compute memory sizes
    if [ ${gpi_mem} -eq 0 ] ; then
        gpi_mem=$(( avl_mem * 50 / 100 ))
    fi

    info "using SHM mem: ${def_shm_mem} bytes per process (by default)"
    info "using GPI mem: ${gpi_mem} bytes per node"
    info "starting GPI using: '$gpi_exe' on '${gpi_socket}'"

    dry_run "${script_start_gpi}" \
        -s "$state_dir" \
        -x "${gpi_exe}" \
        -D \
        -f \
        -P "$state_dir/gpi-space.pid" \
        -m "$gpi_mem" \
        -k "${master}" -K "$kvs_port" \
        -l "${log_host}" -L "${log_port}" \
        -S "${gpi_socket}"

    ec=$?
    if [ $ec -ne 0 ]
    then
        "${sdpa}" -s "${state_dir}" stop
        error 3 "could not start gpi-space"
    fi
fi

# for each capability:
#    for each host
#       - check maximum worker limit, break
#       - start additional workers, up to N

pids=()
max_background_tasks=8

function wait_on_pids ()
{
    local pid=
    local ec=0
    for pid in ${pids[@]} ; do
        wait $pid
        ec+=$?
    done
    pids=()
    return $ec
}

function wait_if_necessary ()
{
    if [ ${#pids[@]} -ge ${max_background_tasks} ] ; then
        wait_on_pids
    fi
}

segment_host_index=()
segment_size=()
segment_master=()

function assign_segments
{
    if [ $number_of_groups -eq 1 ] ; then
        segment_host_index[0]=0
        segment_size[0]=${num_hosts}
        segment_master=("agent-${master}-0")
    else
        local i=
        local hosts_per_group=$(( ${num_hosts} / ${number_of_groups} ))
        local remaining_hosts=$(( ${num_hosts} % ${number_of_groups} ))
        local host=
        local offset=0
        for ((i=0 ; i < $number_of_groups ; ++i)) ; do
            segment_host_index[$i]=${offset}
            segment_size[$i]=${hosts_per_group}
            host=${hosts[$offset]}
            segment_master[$i]="agent-${host}-1"

            offset=$((offset + hosts_per_group))
        done

        # add remaining hosts to last group
        segment_size[$((number_of_groups - 1))]=$((hosts_per_group + remaining_hosts))
    fi
}

function start_agent
{
    local host="$1" ; shift
    local name="$1" ; shift
    local parent="$1" ; shift

    info "starting agent: ${name} on host ${host} with parent ${parent}"

    dry_run rexec ${host} "${script_start_agent}" \
        $opt_verbose_flag \
        -D \
        -n "${name}" \
        -m "${parent}" \
        -s "${state_dir}" \
        -k "${master}:${kvs_port}" \
        -l "${log_host}:${log_port}" \
        -H "${sdpa_home}" \
        -g "${gui_host}:${gui_port}" &
    pids+=( $! )
}

function start_agents
{
    start_agent ${master} "agent-${master}-0" "orchestrator"
    ec=$?

    if [ ${#segment_master[@]} -eq 1 ] ; then
        return $ec
    fi

    local i=
    for ((i = 0 ; i < ${#segment_master[@]} ; ++i)) ; do
        host_idx=${segment_host_index[$i]}
        host=${hosts[${host_idx}]}
        name="agent-${host}-1"

        start_agent "${host}" "${name}" "agent-${master}-0"
        wait_if_necessary
        ec=$?
        if [ $ec -ne 0 ]
        then
            "${sdpa}" -s "${state_dir}" stop
            error 3 "at least one agent could not be started!"
        fi
    done
}

function start_workers_for_capability
{
    local segment="$1"      ; shift
    local capability="$1"   ; shift
    local num_per_node="$1" ; shift
    local max_nodes="$1"    ; shift
    local shm_size="$1"     ; shift
    local socket="$1"       ; shift

    human_max="global max: $max_nodes"
    if [ $max_nodes -eq 0 ] ; then
        human_max="unlimited"
    elif [ $max_nodes -eq 1 ] ; then
        human_max="unique"
    fi
    info "starting $capability workers (segment $segment, $num_per_node/host, $human_max, $shm_size SHM)..."

    num_nodes=0
    caps_arg=$(echo "$capability" | tr '+' '\n' | xargs -n1 echo '-C')

    parent=${segment_master[$segment]}
    group_start=${segment_host_index[$segment]}
    group_size=${segment_size[$segment]}
    group_end=$((group_start + group_size))

    local i=
    for ((i=${group_start} ; i < ${group_end} ; ++i)) ; do
        host=${hosts[$i]}

        local name="${capability/[+#.]/_}"

        argv=($opt_verbose_flag)
        argv+=(-D)
        argv+=(-c $num_per_node)
        argv+=(-n "$name")
        argv+=(-m "$parent")
        argv+=(-k "$master:${kvs_port}")
        argv+=(-g "${gui_host}:${gui_port}")
        argv+=(-l "${log_host}:${log_port}")
        argv+=($caps_arg)
        argv+=(-s "$state_dir")
        if $gpi_enabled ; then
            argv+=(-M "$shm_size")
            argv+=(-S "$gpi_socket")
        fi
        if [ $socket -ne -1 ] ; then
            argv+=(-N "$socket")
        fi
        if [ -n "${app_path}" ]
        then
            argv+=(-L "${app_path}")
        fi
        argv+=(-H "${sdpa_home}")

        dry_run rexec $host "$script_start_drts" "${argv[@]}" &

        pids+=( $! )

        wait_if_necessary
        ec=$?
        if [ $ec -ne 0 ]
        then
            "${sdpa}" -s "${state_dir}" stop
            error 3 "at least one worker could not be started!"
        fi

        num_nodes=$(( num_nodes + 1 ))

        if [ $num_nodes -eq $max_nodes ] ; then
            break
        fi
    done
}

function start_workers
{
    local seg=
    for (( seg=0 ; seg < ${number_of_groups} ; ++seg )) ; do
        sizeof_capstruct=5
        local i=
        for (( i=0 ; i < ${#capabilities[@]} ; i += $sizeof_capstruct )) ; do
            capability=${capabilities[   $(( i+0 )) ]}
            num_per_node=${capabilities[ $(( i+1 )) ]}
            max_nodes=${capabilities[    $(( i+2 )) ]}
            shm_size=${capabilities[     $(( i+3 )) ]}
            socket=${capabilities[       $(( i+4 )) ]}
            start_workers_for_capability $seg "$capability" "$num_per_node" "$max_nodes" "$shm_size" "$socket"
        done
    done
}

assign_segments
start_agents
wait_on_pids
ec=$?
if [ $ec -ne 0 ]
then
    "${sdpa}" -s "${state_dir}" stop
    error 3 "at least one agent could not be started!"
fi

start_workers
wait_on_pids
ec=$?
if [ $ec -ne 0 ]
then
    "${sdpa}" -s "${state_dir}" stop
    error 3 "at least one worker could not be started!"
fi
