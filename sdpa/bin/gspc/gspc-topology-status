#!/bin/bash

GSPC_API_COMMAND_SHORT_DESCRIPTION="examine the current status of a GPI-Space topology"
GSPC_API_COMMAND_LEVEL=2

. "${GSPC_EXEC_PATH}/gspc-sh-setup" || { echo >&2 "must be run by 'gspc'" ; exit 64; }

function usage()
{
    cat <<EOF
usage: topology-status [-h|--help] [options]

Options:

   --kvs-host <host>     specify the host of the KVS
   --kvs-port <port>     specify the port of the KVS
EOF
}

TEMP=`getopt -o hq --long help,quiet,kvs-host:,kvs-port: -n 'topology' -- "$@"`

if [ $? != 0 ] ; then echo >&2 "try '-h' or '--help'. Terminating..." ; exit 1 ; fi

eval set -- "$TEMP"

kvs_host=
kvs_port=
quiet=false

while true ; do
    case "$1" in
        -h|--help) usage; exit 0 ;;
        --kvs-host)
            kvs_host="$2"
            shift ; shift
            ;;
        --kvs-port)
            kvs_port="$2"
            shift ; shift
            ;;
        -q|--quiet)
            quiet=true
            shift
            ;;
        --) shift; break ;;
        *) gspc_log_error topology "Internal error on argument: '$1'"; exit 1 ;;
    esac
done

function action_status ()
{
    local to_check=("$@")
    local component_info=()

    component_info=($(gspc_call topology --kvs-host "$kvs_host" --kvs-port "$kvs_port" list --no-header "${to_check[@]}"))
    ec=$?
    if [ $ec -ne 0 ] ; then
        return $ec
    fi

    color_up=""
    color_dn=""
    color_off=""

    columns=1
    if gspc_is_color_enabled status 1 ; then
        color_up="$GSPC_COLOR_GREEN"
        color_dn="$GSPC_COLOR_RED"
        color_off="$GSPC_COLOR_OFF"
    fi
    if gspc_isatty 1 ; then
        # format from below: '[ID] <20-chars> ?'
        columns=$(( $(tput cols) / 27 ))
        columns=$((columns > 0 ? columns : 1))
    fi

    local bg_pid=()
    local bg_pid_name=()

    for ((i=0 ; i < ${#component_info[@]} ; i+=4))
    do
        host="${component_info[i+0]}"
        port="${component_info[i+1]}"
        pid="${component_info[i+2]}"
        name="${component_info[i+3]}"

        gspc check-port "$host" "$port" &

        bg_pid+=( $! )
        bg_pid_name+=( "$name" )
    done

    num_to_check=${#to_check[@]}
    num_up=0
    num_dn=0
    col=0
    for ((i=0 ; i < ${#bg_pid[@]} ; ++i))
    do
        if wait ${bg_pid[i]}
        then
            state="UP"; color="$color_up"
            num_up+=1
        else
            state="DN"; color="$color_dn"
            num_dn+=1
        fi

        if ! $quiet ; then
            printf "[${color}%-2s${color_off}] %-20s" "$state" "${bg_pid_name[i]}"
        fi
        col=$((col + 1))
        if [ $col -ge $columns ] ; then
            if ! $quiet ; then
                printf "\n"
            fi
            col=0
        else
            if ! $quiet ; then
                printf " "
            fi
        fi
    done
    if [ $col -gt 0 ] ; then
        if ! $quiet ; then
            printf "\n"
        fi
        col=0
    fi

    if [ $num_to_check -gt 0 ] ; then
        if [ $num_up -lt $num_to_check ] ; then
            return 1
        else
            return 0
        fi
    fi

    return $(( num_dn > 0 ? 1 : 0 ))
}

action_status "${@}"
