<defun name="transform_file">
  <struct name="config">
    <field name="chunk_size" type="long"/>
    <field name="input_file" type="string"/>
    <field name="n_chunks" type="long"/>
    <field name="output_file" type="string"/>
    <field name="read_area" type="long"/>
    <field name="write_area" type="long"/>
  </struct>
  <struct name="chunk_read_info">
    <field name="chunk_id" type="long"/>
    <field name="read_slot_id" type="long"/>
    <field name="size" type="long"/>
  </struct>
  <struct name="chunk_write_info">
    <field name="chunk_id" type="long"/>
    <field name="size" type="long"/>
    <field name="write_slot_id" type="long"/>
  </struct>
  <in name="input_file" type="string" place="input_file"/>
  <in name="output_file" type="string" place="output_file"/>
  <in name="chunk_size" type="long" place="chunk_size"/>
  <in name="input_n_read_slots" type="long" place="input_n_read_slots"/>
  <in name="input_n_write_slots" type="long" place="input_n_write_slots"/>
  <out name="done" type="control" place="done"/>
  <net>
    <template name="dup">
      <properties name="pnetc">
        <properties name="warning">
          <property key="inline-many-output-ports">
            off
          </property>
        </properties>
      </properties>
      <in name="in" type="T" place="x"/>
      <out name="one" type="T" place="a"/>
      <out name="two" type="T" place="b"/>
      <net>
        <place name="x" type="T"/>
        <place name="a" type="T"/>
        <place name="b" type="T"/>
        <transition name="dup">
          <defun>
            <in name="x" type="T"/>
            <out name="a" type="T"/>
            <out name="b" type="T"/>
            <expression>
              ${a} := ${x}; ${b} := ${x}
            </expression>
          </defun>
          <connect-in port="x" place="x"/>
          <connect-out port="a" place="a"/>
          <connect-out port="b" place="b"/>
        </transition>
      </net>
    </template>
    <template name="triple">
      <properties name="pnetc">
        <properties name="warning">
          <property key="inline-many-output-ports">
            off
          </property>
        </properties>
      </properties>
      <in name="in" type="T" place="x"/>
      <out name="one" type="T" place="one"/>
      <out name="two" type="T" place="two"/>
      <out name="three" type="T" place="three"/>
      <net>
        <place name="x" type="T"/>
        <place name="one" type="T"/>
        <place name="two" type="T"/>
        <place name="three" type="T"/>
        <transition name="triple">
          <defun>
            <in name="x" type="T"/>
            <out name="one" type="T"/>
            <out name="two" type="T"/>
            <out name="three" type="T"/>
            <expression>
              ${one} := ${x}; ${two} := ${x}; ${three} := ${x}
            </expression>
          </defun>
          <connect-in port="x" place="x"/>
          <connect-out port="one" place="one"/>
          <connect-out port="two" place="two"/>
          <connect-out port="three" place="three"/>
        </transition>
      </net>
    </template>
    <specialize name="dup_counter" use="dup">
      <type-map replace="T" with="long"/>
    </specialize>
    <specialize name="dup_control" use="dup">
      <type-map replace="T" with="control"/>
    </specialize>
    <specialize name="triple_counter" use="triple">
      <type-map replace="T" with="long"/>
    </specialize>
    <place name="input_file" type="string"/>
    <place name="output_file" type="string"/>
    <place name="chunk_size" type="long"/>
    <place name="input_n_read_slots" type="long"/>
    <place name="input_n_write_slots" type="long"/>
    <place name="config" type="config"/>
    <place name="n_read_slots" type="long"/>
    <place name="n_write_slots" type="long"/>
    <place name="n_chunks" type="long"/>
    <place name="n_write_slots_cnt" type="long"/>
    <place name="n_write_slots_gen" type="long"/>
    <place name="n_read_slots_gen" type="long"/>
    <place name="n_read_slots_cnt" type="long"/>
    <place name="n_chunks_left" type="long"/>
    <place name="n_chunks_gen" type="long"/>
    <place name="write_slot_id" type="long"/>
    <place name="chunk_id" type="long"/>
    <place name="chunk_written" type="control"/>
    <place name="all_chunks_done" type="control"/>
    <place name="all_chunks_done_write" type="control"/>
    <place name="all_chunks_done_read" type="control"/>
    <place name="chunk_read_info" type="chunk_read_info"/>
    <place name="read_slot_id" type="long"/>
    <place name="chunk_write_info" type="chunk_write_info"/>
    <place name="write_slots_released" type="control"/>
    <place name="read_slots_released" type="control"/>
    <place name="done" type="control"/>
    <transition name="init" inline="true">
      <defun>
        <in name="input_file" type="string"/>
        <in name="output_file" type="string"/>
        <in name="chunk_size" type="long"/>
        <in name="input_n_read_slots" type="long"/>
        <in name="input_n_write_slots" type="long"/>
        <out name="config" type="config"/>
        <out name="n_read_slots" type="long"/>
        <out name="n_write_slots" type="long"/>
        <out name="n_chunks" type="long"/>
        <module name="create_config" function="config create_config (input_file, output_file, chunk_size, input_n_read_slots, input_n_write_slots, n_chunks, n_read_slots, n_write_slots)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="util/memory.hpp"/>
          <cinclude href="cstdio"/>
          <cinclude href="sstream"/>
          <cinclude href="cmath"/>
          <code>
            <![CDATA[
          #define DIVRU(a,b) ((a)+(b)-1) / (b)

          MLOG (INFO, "Get the size of the file " << input_file);
          FILE *pf;
          if((pf = fopen(input_file.c_str(), "r"))== NULL)
          {
          std::ostringstream oss;
          oss<<"  Could not open the file " <<input_file << "!";
          MLOG(ERROR, oss.str());
          throw std::runtime_error(oss.str());
          }

          fseek(pf, 0L, SEEK_END);
          long input_file_size = ftell(pf);
          fclose(pf);

          // truncate output file

          ::pnetc::type::config::config config;
          printf ("Size of %s is: %ld bytes.\n", input_file.c_str(),input_file_size);
          if(input_file_size<=0)
          {
          throw std::runtime_error("invalid size for the input file!!!" );
          }

          n_chunks = DIVRU(input_file_size,chunk_size);
          MLOG (INFO, "The file should be splitted into " <<n_chunks<<" chunks, where chunk_size ="<<chunk_size<<"!");

          long n_nodes = fvmGetNodeCount();
          MLOG (INFO, "The number of nodes used by GPI: "<<n_nodes);

          size_t size_read_area = DIVRU(chunk_size*input_n_read_slots,n_nodes);
          size_t size_write_area = DIVRU(chunk_size*input_n_write_slots,n_nodes);

          MLOG (INFO, "Size of the read area to be allocated: "<<size_read_area);
          MLOG (INFO, "Size of thewrite area to be allocated: "<<size_write_area);

          namespace vm = ::transform_file::util::memory::global;

          config.input_file  = input_file;
          config.output_file = output_file;

          config.read_area  = vm::alloc(size_read_area, "read_area");
          config.write_area = vm::alloc(size_write_area, "write_area");
          config.n_chunks   = n_chunks;
          config.chunk_size = chunk_size;

          n_read_slots  = input_n_read_slots;
          n_write_slots = input_n_write_slots;

          LOG (INFO, "The config is: " << config);

          return config;

          ]]>
          </code>
        </module>
      </defun>
      <connect-in port="input_file" place="input_file"/>
      <connect-in port="output_file" place="output_file"/>
      <connect-in port="chunk_size" place="chunk_size"/>
      <connect-in port="input_n_read_slots" place="input_n_read_slots"/>
      <connect-in port="input_n_write_slots" place="input_n_write_slots"/>
      <connect-out port="config" place="config"/>
      <connect-out port="n_read_slots" place="n_read_slots"/>
      <connect-out port="n_write_slots" place="n_write_slots"/>
      <connect-out port="n_chunks" place="n_chunks"/>
    </transition>
    <transition name="dup_n_write_slots" inline="true">
      <use name="dup_counter"/>
      <connect-in port="in" place="n_write_slots"/>
      <connect-out port="one" place="n_write_slots_gen"/>
      <connect-out port="two" place="n_write_slots_cnt"/>
    </transition>
    <transition name="dup_n_read_slots" inline="true">
      <use name="dup_counter"/>
      <connect-in port="in" place="n_read_slots"/>
      <connect-out port="one" place="n_read_slots_gen"/>
      <connect-out port="two" place="n_read_slots_cnt"/>
    </transition>
    <transition name="dup_n_chunks" inline="true">
      <use name="dup_counter"/>
      <connect-in port="in" place="n_chunks"/>
      <connect-out port="one" place="n_chunks_gen"/>
      <connect-out port="two" place="n_chunks_left"/>
    </transition>
    <transition name="generate_write_slots" inline="true">
      <defun name="sequence">
        <in name="amount" type="long" place="N"/>
        <out name="out" type="long" place="id"/>
        <net>
          <struct name="state">
            <field name="id" type="long"/>
            <field name="max" type="long"/>
          </struct>
          <template name="dup">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="a"/>
            <out name="two" type="T" place="b"/>
            <net>
              <place name="x" type="T"/>
              <place name="a" type="T"/>
              <place name="b" type="T"/>
              <transition name="dup">
                <defun>
                  <in name="x" type="T"/>
                  <out name="a" type="T"/>
                  <out name="b" type="T"/>
                  <expression>
                    ${a} := ${x}; ${b} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="a" place="a"/>
                <connect-out port="b" place="b"/>
              </transition>
            </net>
          </template>
          <template name="triple">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="one"/>
            <out name="two" type="T" place="two"/>
            <out name="three" type="T" place="three"/>
            <net>
              <place name="x" type="T"/>
              <place name="one" type="T"/>
              <place name="two" type="T"/>
              <place name="three" type="T"/>
              <transition name="triple">
                <defun>
                  <in name="x" type="T"/>
                  <out name="one" type="T"/>
                  <out name="two" type="T"/>
                  <out name="three" type="T"/>
                  <expression>
                    ${one} := ${x}; ${two} := ${x}; ${three} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="one" place="one"/>
                <connect-out port="two" place="two"/>
                <connect-out port="three" place="three"/>
              </transition>
            </net>
          </template>
          <specialize name="dup_counter" use="dup">
            <type-map replace="T" with="long"/>
          </specialize>
          <specialize name="dup_control" use="dup">
            <type-map replace="T" with="control"/>
          </specialize>
          <specialize name="triple_counter" use="triple">
            <type-map replace="T" with="long"/>
          </specialize>
          <place name="N" type="long"/>
          <place name="state" type="state"/>
          <place name="id" type="long"/>
          <place name="check_break" type="state"/>
          <place name="credit_check_break" type="control">
            <token>
              <value>
                []
              </value>
            </token>
          </place>
          <transition name="init">
            <defun>
              <in name="N" type="long"/>
              <in name="credit_check_break" type="control"/>
              <out name="state" type="state"/>
              <expression>
                ${state.id} := 0L; ${state.max} := ${N}
              </expression>
            </defun>
            <connect-in port="N" place="N"/>
            <connect-in port="credit_check_break" place="credit_check_break"/>
            <connect-out port="state" place="check_break"/>
          </transition>
          <transition name="break">
            <defun>
              <in name="state" type="state"/>
              <out name="credit_check_break" type="control"/>
              <expression>
                ${credit_check_break} := []
              </expression>
              <condition>
                ${state.id} :ge: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="credit_check_break" place="credit_check_break"/>
          </transition>
          <transition name="not_break">
            <properties name="fhg">
              <properties name="pnetv">
                <property key="firings_limit">
                  1
                </property>
              </properties>
            </properties>
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <out name="credit_check_break" type="control"/>
              <expression>
                ${credit_check_break} := []
              </expression>
              <condition>
                ${state.id} :lt: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="state" place="state"/>
            <connect-out port="credit_check_break" place="credit_check_break"/>
          </transition>
          <transition name="step">
            <defun>
              <in name="state" type="state"/>
              <in name="credit_check_break" type="control"/>
              <out name="state" type="state"/>
              <out name="id" type="long"/>
              <expression>
                ${id} := ${state.id}; ${state.id} := ${state.id} + 1
              </expression>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-in port="credit_check_break" place="credit_check_break"/>
            <connect-out port="state" place="check_break"/>
            <connect-out port="id" place="id"/>
          </transition>
        </net>
      </defun>
      <connect-in port="amount" place="n_write_slots_gen"/>
      <connect-out port="out" place="write_slot_id"/>
    </transition>
    <transition name="generate_read_slots" inline="true">
      <defun name="sequence">
        <in name="amount" type="long" place="N"/>
        <out name="out" type="long" place="id"/>
        <net>
          <struct name="state">
            <field name="id" type="long"/>
            <field name="max" type="long"/>
          </struct>
          <template name="dup">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="a"/>
            <out name="two" type="T" place="b"/>
            <net>
              <place name="x" type="T"/>
              <place name="a" type="T"/>
              <place name="b" type="T"/>
              <transition name="dup">
                <defun>
                  <in name="x" type="T"/>
                  <out name="a" type="T"/>
                  <out name="b" type="T"/>
                  <expression>
                    ${a} := ${x}; ${b} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="a" place="a"/>
                <connect-out port="b" place="b"/>
              </transition>
            </net>
          </template>
          <template name="triple">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="one"/>
            <out name="two" type="T" place="two"/>
            <out name="three" type="T" place="three"/>
            <net>
              <place name="x" type="T"/>
              <place name="one" type="T"/>
              <place name="two" type="T"/>
              <place name="three" type="T"/>
              <transition name="triple">
                <defun>
                  <in name="x" type="T"/>
                  <out name="one" type="T"/>
                  <out name="two" type="T"/>
                  <out name="three" type="T"/>
                  <expression>
                    ${one} := ${x}; ${two} := ${x}; ${three} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="one" place="one"/>
                <connect-out port="two" place="two"/>
                <connect-out port="three" place="three"/>
              </transition>
            </net>
          </template>
          <specialize name="dup_counter" use="dup">
            <type-map replace="T" with="long"/>
          </specialize>
          <specialize name="dup_control" use="dup">
            <type-map replace="T" with="control"/>
          </specialize>
          <specialize name="triple_counter" use="triple">
            <type-map replace="T" with="long"/>
          </specialize>
          <place name="N" type="long"/>
          <place name="state" type="state"/>
          <place name="id" type="long"/>
          <place name="check_break" type="state"/>
          <place name="credit_check_break" type="control">
            <token>
              <value>
                []
              </value>
            </token>
          </place>
          <transition name="init">
            <defun>
              <in name="N" type="long"/>
              <in name="credit_check_break" type="control"/>
              <out name="state" type="state"/>
              <expression>
                ${state.id} := 0L; ${state.max} := ${N}
              </expression>
            </defun>
            <connect-in port="N" place="N"/>
            <connect-in port="credit_check_break" place="credit_check_break"/>
            <connect-out port="state" place="check_break"/>
          </transition>
          <transition name="break">
            <defun>
              <in name="state" type="state"/>
              <out name="credit_check_break" type="control"/>
              <expression>
                ${credit_check_break} := []
              </expression>
              <condition>
                ${state.id} :ge: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="credit_check_break" place="credit_check_break"/>
          </transition>
          <transition name="not_break">
            <properties name="fhg">
              <properties name="pnetv">
                <property key="firings_limit">
                  1
                </property>
              </properties>
            </properties>
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <out name="credit_check_break" type="control"/>
              <expression>
                ${credit_check_break} := []
              </expression>
              <condition>
                ${state.id} :lt: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="state" place="state"/>
            <connect-out port="credit_check_break" place="credit_check_break"/>
          </transition>
          <transition name="step">
            <defun>
              <in name="state" type="state"/>
              <in name="credit_check_break" type="control"/>
              <out name="state" type="state"/>
              <out name="id" type="long"/>
              <expression>
                ${id} := ${state.id}; ${state.id} := ${state.id} + 1
              </expression>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-in port="credit_check_break" place="credit_check_break"/>
            <connect-out port="state" place="check_break"/>
            <connect-out port="id" place="id"/>
          </transition>
        </net>
      </defun>
      <connect-in port="amount" place="n_read_slots_gen"/>
      <connect-out port="out" place="read_slot_id"/>
    </transition>
    <transition name="generate_chunk_ids" inline="true">
      <defun name="sequence">
        <in name="amount" type="long" place="N"/>
        <out name="out" type="long" place="id"/>
        <net>
          <struct name="state">
            <field name="id" type="long"/>
            <field name="max" type="long"/>
          </struct>
          <template name="dup">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="a"/>
            <out name="two" type="T" place="b"/>
            <net>
              <place name="x" type="T"/>
              <place name="a" type="T"/>
              <place name="b" type="T"/>
              <transition name="dup">
                <defun>
                  <in name="x" type="T"/>
                  <out name="a" type="T"/>
                  <out name="b" type="T"/>
                  <expression>
                    ${a} := ${x}; ${b} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="a" place="a"/>
                <connect-out port="b" place="b"/>
              </transition>
            </net>
          </template>
          <template name="triple">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="one"/>
            <out name="two" type="T" place="two"/>
            <out name="three" type="T" place="three"/>
            <net>
              <place name="x" type="T"/>
              <place name="one" type="T"/>
              <place name="two" type="T"/>
              <place name="three" type="T"/>
              <transition name="triple">
                <defun>
                  <in name="x" type="T"/>
                  <out name="one" type="T"/>
                  <out name="two" type="T"/>
                  <out name="three" type="T"/>
                  <expression>
                    ${one} := ${x}; ${two} := ${x}; ${three} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="one" place="one"/>
                <connect-out port="two" place="two"/>
                <connect-out port="three" place="three"/>
              </transition>
            </net>
          </template>
          <specialize name="dup_counter" use="dup">
            <type-map replace="T" with="long"/>
          </specialize>
          <specialize name="dup_control" use="dup">
            <type-map replace="T" with="control"/>
          </specialize>
          <specialize name="triple_counter" use="triple">
            <type-map replace="T" with="long"/>
          </specialize>
          <place name="N" type="long"/>
          <place name="state" type="state"/>
          <place name="id" type="long"/>
          <place name="check_break" type="state"/>
          <place name="credit_check_break" type="control">
            <token>
              <value>
                []
              </value>
            </token>
          </place>
          <transition name="init">
            <defun>
              <in name="N" type="long"/>
              <in name="credit_check_break" type="control"/>
              <out name="state" type="state"/>
              <expression>
                ${state.id} := 0L; ${state.max} := ${N}
              </expression>
            </defun>
            <connect-in port="N" place="N"/>
            <connect-in port="credit_check_break" place="credit_check_break"/>
            <connect-out port="state" place="check_break"/>
          </transition>
          <transition name="break">
            <defun>
              <in name="state" type="state"/>
              <out name="credit_check_break" type="control"/>
              <expression>
                ${credit_check_break} := []
              </expression>
              <condition>
                ${state.id} :ge: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="credit_check_break" place="credit_check_break"/>
          </transition>
          <transition name="not_break">
            <properties name="fhg">
              <properties name="pnetv">
                <property key="firings_limit">
                  1
                </property>
              </properties>
            </properties>
            <defun>
              <in name="state" type="state"/>
              <out name="state" type="state"/>
              <out name="credit_check_break" type="control"/>
              <expression>
                ${credit_check_break} := []
              </expression>
              <condition>
                ${state.id} :lt: ${state.max}
              </condition>
            </defun>
            <connect-in port="state" place="check_break"/>
            <connect-out port="state" place="state"/>
            <connect-out port="credit_check_break" place="credit_check_break"/>
          </transition>
          <transition name="step">
            <defun>
              <in name="state" type="state"/>
              <in name="credit_check_break" type="control"/>
              <out name="state" type="state"/>
              <out name="id" type="long"/>
              <expression>
                ${id} := ${state.id}; ${state.id} := ${state.id} + 1
              </expression>
            </defun>
            <connect-in port="state" place="state"/>
            <connect-in port="credit_check_break" place="credit_check_break"/>
            <connect-out port="state" place="check_break"/>
            <connect-out port="id" place="id"/>
          </transition>
        </net>
      </defun>
      <connect-in port="amount" place="n_chunks_gen"/>
      <connect-out port="out" place="chunk_id"/>
    </transition>
    <transition name="dup_all_chunks_done" inline="true">
      <use name="dup_control"/>
      <connect-in port="in" place="all_chunks_done"/>
      <connect-out port="one" place="all_chunks_done_write"/>
      <connect-out port="two" place="all_chunks_done_read"/>
    </transition>
    <transition name="check_all_chunks_done" inline="true">
      <defun name="check_update_counter">
        <in name="trigger" type="control" place="trigger"/>
        <out name="done" type="control" place="done"/>
        <tunnel name="counter" type="long" place="counter"/>
        <net>
          <template name="dup">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="a"/>
            <out name="two" type="T" place="b"/>
            <net>
              <place name="x" type="T"/>
              <place name="a" type="T"/>
              <place name="b" type="T"/>
              <transition name="dup">
                <defun>
                  <in name="x" type="T"/>
                  <out name="a" type="T"/>
                  <out name="b" type="T"/>
                  <expression>
                    ${a} := ${x}; ${b} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="a" place="a"/>
                <connect-out port="b" place="b"/>
              </transition>
            </net>
          </template>
          <template name="triple">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="one"/>
            <out name="two" type="T" place="two"/>
            <out name="three" type="T" place="three"/>
            <net>
              <place name="x" type="T"/>
              <place name="one" type="T"/>
              <place name="two" type="T"/>
              <place name="three" type="T"/>
              <transition name="triple">
                <defun>
                  <in name="x" type="T"/>
                  <out name="one" type="T"/>
                  <out name="two" type="T"/>
                  <out name="three" type="T"/>
                  <expression>
                    ${one} := ${x}; ${two} := ${x}; ${three} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="one" place="one"/>
                <connect-out port="two" place="two"/>
                <connect-out port="three" place="three"/>
              </transition>
            </net>
          </template>
          <specialize name="dup_counter" use="dup">
            <type-map replace="T" with="long"/>
          </specialize>
          <specialize name="dup_control" use="dup">
            <type-map replace="T" with="control"/>
          </specialize>
          <specialize name="triple_counter" use="triple">
            <type-map replace="T" with="long"/>
          </specialize>
          <place name="counter" type="long" virtual="true"/>
          <place name="trigger" type="control"/>
          <place name="done" type="control"/>
          <transition name="decrement_counter">
            <defun>
              <in name="counter" type="long"/>
              <in name="trigger" type="control"/>
              <out name="counter" type="long"/>
              <expression>
                ${counter} := ${counter}-1
              </expression>
              <condition>
                ${counter}:gt:0L
              </condition>
            </defun>
            <connect-in port="counter" place="counter"/>
            <connect-in port="trigger" place="trigger"/>
            <connect-out port="counter" place="counter"/>
          </transition>
          <transition name="stop">
            <defun>
              <in name="counter" type="long"/>
              <out name="done" type="control"/>
              <expression/>
              <condition>
                ${counter}:eq:0L
              </condition>
            </defun>
            <connect-in port="counter" place="counter"/>
            <connect-out port="done" place="done"/>
          </transition>
        </net>
      </defun>
      <place-map virtual="counter" real="n_chunks_left"/>
      <connect-in port="trigger" place="chunk_written"/>
      <connect-out port="done" place="all_chunks_done"/>
    </transition>
    <transition name="load_chunk" inline="true">
      <defun>
        <in name="chunk_id" type="long"/>
        <in name="read_slot_id" type="long"/>
        <in name="config" type="config"/>
        <out name="chunk_read_info" type="chunk_read_info"/>
        <module name="load_chunk" function="chunk_read_info read_and_load_chunk (read_slot_id, chunk_id, config)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="util/memory.hpp"/>
          <cinclude href="iostream"/>
          <cinclude href="stdio.h"/>
          <cinclude href="cmath"/>
          <code>
            <![CDATA[
          MLOG (INFO, "Reading the chunk "<<chunk_id<<" from the file " << config.input_file<<" ...");

          FILE *file_ptr;
          int num;

          if((file_ptr = fopen(config.input_file.c_str(), "r"))== NULL)
          {
          std::ostringstream oss;
          oss<<"  Could not open the file " << config.input_file << "!";
          MLOG(ERROR, oss.str());
          throw std::runtime_error(oss.str());
          }

          long offset = chunk_id * config.chunk_size;
          if( (fseek(file_ptr, offset, SEEK_SET)) != 0)
          {
          printf("Error in seek operation: errno \n");
          exit(1);
          }

          size_t size = sizeof(char)*config.chunk_size;

          // copy it first into the shared memory
          // call put and global put into the read_area
          char* buffer = static_cast<char *> (fvmGetShmemPtr());

          // copy the file into the buffer:
          size_t result = fread (buffer,1,size,file_ptr);

          waitComm ( fvmPutGlobalData
          ( static_cast<fvmAllocHandle_t> (config.read_area)
          , read_slot_id*config.chunk_size
          , result
          , 0
          , 0
          )
          );

          LOG ( INFO, "The chunk "<<chunk_id<<" was successfully into the virtual memory");

          pnetc::type::chunk_read_info::chunk_read_info c_r_info;

          c_r_info.read_slot_id = read_slot_id;
          c_r_info.chunk_id = chunk_id;
          c_r_info.size = result;

          fclose(file_ptr);
          return c_r_info;
          ]]>
          </code>
        </module>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="read_slot_id" place="read_slot_id"/>
      <connect-in port="chunk_id" place="chunk_id"/>
      <connect-out port="chunk_read_info" place="chunk_read_info"/>
    </transition>
    <transition name="transform_chunk" inline="true">
      <defun>
        <in name="write_slot_id" type="long"/>
        <in name="chunk_read_info" type="chunk_read_info"/>
        <in name="config" type="config"/>
        <out name="chunk_write_info" type="chunk_write_info"/>
        <out name="read_slot_id" type="long"/>
        <module name="handle_chunk" function="chunk_write_info transform_words (write_slot_id, chunk_read_info, config, read_slot_id)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="ctype.h"/>
          <code>
            <![CDATA[
          LOG (INFO, "Transform the chunk now ...");

          pnetc::type::chunk_write_info::chunk_write_info c_w_info;

          waitComm ( fvmGetGlobalData
          ( static_cast<fvmAllocHandle_t> (config.read_area)
          , chunk_read_info.read_slot_id*config.chunk_size
          , chunk_read_info.size
          , 0
          , 0
          )
          );

          char * chunk = static_cast<char *> (fvmGetShmemPtr());

          // transform chunk
          for( int k=0; k<chunk_read_info.size; k++ )
          if( isalpha(*(chunk+k)) )
          *(chunk+k) = toupper(*(chunk+k));

          c_w_info.write_slot_id = write_slot_id;
          c_w_info.chunk_id = chunk_read_info.chunk_id;
          c_w_info.size = chunk_read_info.size;

          waitComm ( fvmPutGlobalData
          ( static_cast<fvmAllocHandle_t> (config.write_area)
          , write_slot_id*config.chunk_size
          , c_w_info.size
          , 0
          , 0
          )
          );

          // release the read_slot_id
          read_slot_id = chunk_read_info.read_slot_id;

          return c_w_info;
          ]]>
          </code>
        </module>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="write_slot_id" place="write_slot_id"/>
      <connect-in port="chunk_read_info" place="chunk_read_info"/>
      <connect-out port="read_slot_id" place="read_slot_id"/>
      <connect-out port="chunk_write_info" place="chunk_write_info"/>
    </transition>
    <transition name="write" inline="true">
      <defun>
        <in name="chunk_write_info" type="chunk_write_info"/>
        <in name="config" type="config"/>
        <out name="write_slot_id" type="long"/>
        <out name="chunk_written" type="control"/>
        <module name="write_chunk" function="chunk_written write_chunk (chunk_write_info, config, write_slot_id)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="iostream"/>
          <cinclude href="sys/types.h"/>
          <cinclude href="sys/stat.h"/>
          <cinclude href="fcntl.h"/>
          <cinclude href="unistd.h"/>
          <cinclude href="errno.h"/>
          <cinclude href="string.h"/>
          <code>
            <![CDATA[
          LOG (INFO, "Write the chunk " << chunk_write_info.chunk_id << " now ...");

          // get data from vm::write_area
          waitComm( fvmGetGlobalData
          ( static_cast<fvmAllocHandle_t> (config.write_area)
          , chunk_write_info.write_slot_id*config.chunk_size
          , chunk_write_info.size
          , 0
          , 0
          )
          );

          char* ptrChunk = static_cast<char *> (fvmGetShmemPtr());

          std::cout << "************** " << ptrChunk << std::endl;

          // write the data into file at the position
          // chunk_id*config.chunk_size

          int fd = open (config.output_file.c_str (), O_CREAT + O_RDWR);
          if (fd == -1)
          {
          throw std::runtime_error
          ( std::string ("could not open output file '")
          + config.output_file + "' "
          + strerror (errno)
          );
          }
          else
          {
          lseek (fd, chunk_write_info.chunk_id*config.chunk_size, SEEK_SET);
          write (fd, ptrChunk, chunk_write_info.size);
          close (fd);
          }

          write_slot_id = chunk_write_info.write_slot_id;
          return control ();
          ]]>
          </code>
        </module>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="chunk_write_info" place="chunk_write_info"/>
      <connect-out port="write_slot_id" place="write_slot_id"/>
      <connect-out port="chunk_written" place="chunk_written"/>
    </transition>
    <transition name="release_write_slots" inline="true">
      <defun name="release_tokens">
        <in name="counter" type="long" place="counter"/>
        <in name="trigger" type="control" place="trigger"/>
        <in name="deposit" type="long" place="deposit"/>
        <out name="done" type="control" place="done"/>
        <net>
          <template name="dup">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="a"/>
            <out name="two" type="T" place="b"/>
            <net>
              <place name="x" type="T"/>
              <place name="a" type="T"/>
              <place name="b" type="T"/>
              <transition name="dup">
                <defun>
                  <in name="x" type="T"/>
                  <out name="a" type="T"/>
                  <out name="b" type="T"/>
                  <expression>
                    ${a} := ${x}; ${b} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="a" place="a"/>
                <connect-out port="b" place="b"/>
              </transition>
            </net>
          </template>
          <template name="triple">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="one"/>
            <out name="two" type="T" place="two"/>
            <out name="three" type="T" place="three"/>
            <net>
              <place name="x" type="T"/>
              <place name="one" type="T"/>
              <place name="two" type="T"/>
              <place name="three" type="T"/>
              <transition name="triple">
                <defun>
                  <in name="x" type="T"/>
                  <out name="one" type="T"/>
                  <out name="two" type="T"/>
                  <out name="three" type="T"/>
                  <expression>
                    ${one} := ${x}; ${two} := ${x}; ${three} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="one" place="one"/>
                <connect-out port="two" place="two"/>
                <connect-out port="three" place="three"/>
              </transition>
            </net>
          </template>
          <specialize name="dup_counter" use="dup">
            <type-map replace="T" with="long"/>
          </specialize>
          <specialize name="dup_control" use="dup">
            <type-map replace="T" with="control"/>
          </specialize>
          <specialize name="triple_counter" use="triple">
            <type-map replace="T" with="long"/>
          </specialize>
          <place name="counter" type="long"/>
          <place name="trigger" type="control"/>
          <place name="deposit" type="long"/>
          <place name="done" type="control"/>
          <transition name="decrement_counter">
            <defun>
              <in name="counter" type="long"/>
              <in name="trigger" type="control"/>
              <in name="deposit" type="long"/>
              <out name="counter" type="long"/>
              <expression>
                ${counter} := ${counter}-1
              </expression>
              <condition>
                ${counter}:gt:0L
              </condition>
            </defun>
            <connect-read port="trigger" place="trigger"/>
            <connect-in port="counter" place="counter"/>
            <connect-in port="deposit" place="deposit"/>
            <connect-out port="counter" place="counter"/>
          </transition>
          <transition name="stop">
            <defun>
              <in name="counter" type="long"/>
              <out name="done" type="control"/>
              <expression/>
              <condition>
                ${counter}:eq:0L
              </condition>
            </defun>
            <connect-in port="counter" place="counter"/>
            <connect-out port="done" place="done"/>
          </transition>
        </net>
      </defun>
      <connect-in port="counter" place="n_write_slots_cnt"/>
      <connect-in port="trigger" place="all_chunks_done_write"/>
      <connect-in port="deposit" place="write_slot_id"/>
      <connect-out port="done" place="write_slots_released"/>
    </transition>
    <transition name="release_read_slots" inline="true">
      <defun name="release_tokens">
        <in name="counter" type="long" place="counter"/>
        <in name="trigger" type="control" place="trigger"/>
        <in name="deposit" type="long" place="deposit"/>
        <out name="done" type="control" place="done"/>
        <net>
          <template name="dup">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="a"/>
            <out name="two" type="T" place="b"/>
            <net>
              <place name="x" type="T"/>
              <place name="a" type="T"/>
              <place name="b" type="T"/>
              <transition name="dup">
                <defun>
                  <in name="x" type="T"/>
                  <out name="a" type="T"/>
                  <out name="b" type="T"/>
                  <expression>
                    ${a} := ${x}; ${b} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="a" place="a"/>
                <connect-out port="b" place="b"/>
              </transition>
            </net>
          </template>
          <template name="triple">
            <properties name="pnetc">
              <properties name="warning">
                <property key="inline-many-output-ports">
                  off
                </property>
              </properties>
            </properties>
            <in name="in" type="T" place="x"/>
            <out name="one" type="T" place="one"/>
            <out name="two" type="T" place="two"/>
            <out name="three" type="T" place="three"/>
            <net>
              <place name="x" type="T"/>
              <place name="one" type="T"/>
              <place name="two" type="T"/>
              <place name="three" type="T"/>
              <transition name="triple">
                <defun>
                  <in name="x" type="T"/>
                  <out name="one" type="T"/>
                  <out name="two" type="T"/>
                  <out name="three" type="T"/>
                  <expression>
                    ${one} := ${x}; ${two} := ${x}; ${three} := ${x}
                  </expression>
                </defun>
                <connect-in port="x" place="x"/>
                <connect-out port="one" place="one"/>
                <connect-out port="two" place="two"/>
                <connect-out port="three" place="three"/>
              </transition>
            </net>
          </template>
          <specialize name="dup_counter" use="dup">
            <type-map replace="T" with="long"/>
          </specialize>
          <specialize name="dup_control" use="dup">
            <type-map replace="T" with="control"/>
          </specialize>
          <specialize name="triple_counter" use="triple">
            <type-map replace="T" with="long"/>
          </specialize>
          <place name="counter" type="long"/>
          <place name="trigger" type="control"/>
          <place name="deposit" type="long"/>
          <place name="done" type="control"/>
          <transition name="decrement_counter">
            <defun>
              <in name="counter" type="long"/>
              <in name="trigger" type="control"/>
              <in name="deposit" type="long"/>
              <out name="counter" type="long"/>
              <expression>
                ${counter} := ${counter}-1
              </expression>
              <condition>
                ${counter}:gt:0L
              </condition>
            </defun>
            <connect-read port="trigger" place="trigger"/>
            <connect-in port="counter" place="counter"/>
            <connect-in port="deposit" place="deposit"/>
            <connect-out port="counter" place="counter"/>
          </transition>
          <transition name="stop">
            <defun>
              <in name="counter" type="long"/>
              <out name="done" type="control"/>
              <expression/>
              <condition>
                ${counter}:eq:0L
              </condition>
            </defun>
            <connect-in port="counter" place="counter"/>
            <connect-out port="done" place="done"/>
          </transition>
        </net>
      </defun>
      <connect-in port="counter" place="n_read_slots_cnt"/>
      <connect-in port="trigger" place="all_chunks_done_read"/>
      <connect-in port="deposit" place="read_slot_id"/>
      <connect-out port="done" place="read_slots_released"/>
    </transition>
    <transition name="finalize">
      <defun>
        <in name="config" type="config"/>
        <in name="all_chunks_done_write" type="control"/>
        <in name="all_chunks_done_read" type="control"/>
        <out name="done" type="control"/>
        <module name="transformation_done" function="done finalize_transform_file (config)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="util/memory.hpp"/>
          <code>
            <![CDATA[
          LOG (INFO, "finalize: " << config);

          namespace vmem = ::transform_file::util::memory::global;

          vmem::free(config.read_area);
          vmem::free(config.write_area);

          return control();
          ]]>
          </code>
        </module>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-in port="all_chunks_done_write" place="write_slots_released"/>
      <connect-in port="all_chunks_done_read" place="read_slots_released"/>
      <connect-out port="done" place="done"/>
    </transition>
  </net>
</defun>
