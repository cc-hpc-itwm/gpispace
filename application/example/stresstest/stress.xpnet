<defun>
  <in name="N" type="long" place="Nin"/>
  <in name="config" type="config" place="config"/>
  <in name="trigger" type="long" place="id"/>
  <out name="done" type="control" place="out"/>

  <net>
    <place name="Nin" type="long"/>

    <transition name="scatter_N" inline="true">
      <use name="dup_long"/>
      <connect-in port="in" place="Nin"/>
      <connect-out port="one" place="N"/>
      <connect-out port="two" place="wait"/>
    </transition>

    <place name="id" type="long"/>
    <place name="N" type="long"/>
    <place name="wait" type="long"/>
    <place name="pending" type="long"/>
    <place name="config" type="config"/>
    <place name="done" type="control"/>
    <place name="out" type="control"/>

    <transition name="generate" inline="true">
      <include-function href="sequence.xml"/>
      <connect-in place="N" port="amount"/>
      <connect-out port="out" place="pending"/>
    </transition>

    <transition name="run">
      <defun>
        <in name="id" type="long"/>
        <in name="i" type="long"/>
        <in name="config" type="config"/>
        <out name="done" type="control"/>
        <module name="stresstest" function="done run (config, id, i)">
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="stdexcept"/>
          <cinclude href="string.h"/>
          <cinclude href="boost/random.hpp"/>
          <cinclude href="limits"/>
          <cinclude href="sstream"/>
          <code><![CDATA[
            MLOG (INFO, "run (" << id << ", " << i << ")");

            const fvmAllocHandle_t & handle (config.handle);
            const fvmAllocHandle_t & scratch  (config.scratch);
            const size_t size (config.num_long * sizeof (long));
            const int rank (fvmGetRank());

            if (config.verify_all_mem)
            {
              memset (fvmGetShmemPtr(), rank, fvmGetShmemSize());
            }
            else if (config.verify)
            {
              memset (fvmGetShmemPtr(), rank, size);
            }

            if (config.communicate)
            {
              waitComm (fvmGetGlobalData (handle, 0, size, 0, config.scratch));
            }

            if (config.verify)
            {
              MLOG (INFO, "verifiying " << config.num_long << " values with seed " << config.seed);

              long* a (static_cast<long*> (fvmGetShmemPtr()));

              boost::uniform_int<long> rand ( std::numeric_limits<long>::min()
                                            , std::numeric_limits<long>::max()
                                            );

              boost::mt19937 engine (config.seed);

              for (unsigned long k (0); k < config.num_long; ++k, ++a)
              {
                const long v (rand(engine));

                if (*a != v)
                {
                  std::ostringstream s;

                  s << "BUMMER! wrong value read"
                    << " expected in slot " << k << " the value " << v
                    << " but got the value " << *a
                    ;

                  throw std::runtime_error (s.str());
                }
              }
            }

            if (config.verify_all_mem && fvmGetShmemSize() > size)
            {
              MLOG ( INFO
                   , "verifiying mem behind data ("
                   << fvmGetShmemSize() - size
                   << " bytes)"
                   << " to contain the value " << rank
                   );

              char * a ((char *)fvmGetShmemPtr() + size);

              for (size_t i (size); i < fvmGetShmemSize(); ++i, ++a)
              {
                if (*a != rank)
                {
                  std::ostringstream s;

                  s << "BUMMER! memory behind data corrupted: "
                    << " expected in slot " << i << " the value " << rank
                    << " but got the value " << *a
                  ;

                  throw std::runtime_error (s.str());
                }
              }
            }

            usleep (config.sleeptime);

            return we::type::literal::control();
          ]]></code>
        </module>
      </defun>
      <connect-in port="i" place="pending"/>
      <connect-read port="id" place="id"/>
      <connect-read port="config" place="config"/>
      <connect-out port="done" place="done"/>
    </transition>

    <transition name="wait">
      <use name="wait_control"/>
      <connect-in port="trigger" place="done"/>
      <connect-out port="done" place="all_done"/>
      <place-map real="wait" virtual="wait"/>
    </transition>

    <place name="all_done" type="control"/>

    <transition name="cleanup">
      <defun>
        <in name="wait" type="long"/>
        <in name="config" type="config"/>
        <in name="id" type="long"/>
        <in name="trigger" type="control"/>
        <out name="done" type="control"/>
        <expression>
          ${done} := []
        </expression>
        <condition>${wait} :eq: 0</condition>
      </defun>
      <connect-in port="wait" place="wait"/>
      <connect-in port="config" place="config"/>
      <connect-in port="id" place="id"/>
      <connect-in port="trigger" place="all_done"/>
      <connect-out port="done" place="out"/>
    </transition>
  </net>
</defun>
