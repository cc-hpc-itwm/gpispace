<defun name="atomic">
  <in name="n_A" type="long" place="n_A" />
  <in name="n_B" type="long" place="n_B" />

  <!-- shared_file -->
  <in name="shared_file" type="string" place="shared_file" />

  <out name="done" type="control" place="done" />

  <net>
    <!-- input/output places -->
    <place name="n_A" type="long" />
    <place name="n_B" type="long" />

    <place name="shared_file" type="string" />

    <place name="done" type="control" />

    <!-- template specializations -->
    <include-template href="dup.xml" />
    <specialize name="dup_long" use="dup">
      <type-map replace="T" with="long" />
    </specialize>

    <include-template href="wait.xml" />
    <specialize name="wait_control" use="wait">
      <type-map replace="T" with="control" />
    </specialize>

    <!-- initialization -->

    <transition name="init_places_a" inline="true">
      <use name="dup_long" />
      <connect-in port="in" place="n_A"/>
      <connect-out port="one" place="generate_A"/>
      <connect-out port="two" place="wait_A"/>
    </transition>

    <transition name="init_places_b" inline="true">
      <use name="dup_long" />
      <connect-in port="in" place="n_B"/>
      <connect-out port="one" place="generate_B"/>
      <connect-out port="two" place="wait_B"/>
    </transition>

    <!-- related to path for capability A -->

    <place name="generate_A" type="long" />
    <place name="wait_A" type="long" />

    <transition name="generate_a"  inline="true">
      <include-function href="sequence.xml"/>
      <connect-in  port="amount" place="generate_A" />
      <connect-out port="out"    place="a" />
    </transition>

    <place name="a" type="long" />

    <transition name="run_A">
      <defun>
	<require key="A" mandatory="false"/>
	<require key="ATOMIC" />
	<in name="id" type="long" />
	<in name="filename" type="string" />
	<out name="done" type="control" />
	<module name="atomic_test" function="done A (id,filename)">
          <cinclude href="fhglog/minimal.hpp"/>
	  <cinclude href="unistd.h" />
	  <cinclude href="stdio.h" />
	  <code><![CDATA[
	  	LOG(INFO, ">>> running  A(" << id << ", " << filename << ")");

		FILE * pFile = fopen(filename.c_str(),"r");

		if(!pFile) // file does not exist
		{
			pFile = fopen(filename.c_str(),"w");
			fputc('1', pFile);
			fclose(pFile);
		}
		else
		{
			int i;
			fscanf(pFile, "%d", &i);
			i++;
			fclose(pFile);

			pFile = fopen(filename.c_str(),"w");
			fprintf(pFile, "%d", i);
			fclose(pFile);
		}

	  	LOG(INFO, "<<< finished A(" << id << ", " << filename << ")");

                return we::type::literal::control();
	  ]]></code>
	</module>
      </defun>
      <connect-in port="id" place="a" />
      <connect-read port="filename" place="shared_file" />
      <connect-out port="done" place="done_run_a" />
    </transition>

    <place name="done_run_a" type="control" />

    <transition name="wait_until_A_is_complete" inline="true">
      <use name="wait_control"/>
      <place-map virtual="wait" real="wait_A" />
      <connect-in  port="trigger" place="done_run_a" />
      <connect-out port="done"    place="done_A" />
    </transition>

    <place name="done_A" type="control" />

    <!-- path A complete -->

    <!-- related to path for capability B -->

    <place name="generate_B" type="long" />
    <place name="wait_B" type="long" />

    <transition name="generate_b" inline="true">
      <include-function href="sequence.xml"/>
      <connect-in  port="amount" place="generate_B" />
      <connect-out port="out"    place="b" />
    </transition>

    <place name="b" type="long" />

    <transition name="run_B">
      <defun>
	<require key="B" mandatory="false"/>
	<require key="ATOMIC" />
	<in name="id" type="long" />
	<in name="filename" type="string" />
	<out name="done" type="control" />
	<module name="atomic_test" function="done B(id, filename)">
		<cinclude href="fhglog/minimal.hpp" />
		<cinclude href="unistd.h" />
		<cinclude href="stdio.h" />
        <code><![CDATA[
	  		LOG(INFO, ">>> running  B(" << id << ", " << filename << ")");

			FILE * pFile = fopen(filename.c_str(),"r");

			if(!pFile) // file does not exist
			{
				pFile = fopen(filename.c_str(),"w");
				fputc('1', pFile);
				fclose(pFile);
			}
			else
			{
				int i = 0;
				fscanf(pFile, "%d", &i);
				i++;
				fclose(pFile);

				pFile = fopen(filename.c_str(),"w");
				fprintf(pFile, "%d", i);
				fclose(pFile);
			}

	  		LOG(INFO, "<<< finished B(" << id << ", " << filename << ")");

                        return we::type::literal::control();
	  ]]></code>
	</module>
      </defun>
      <connect-in port="id" place="b" />
      <connect-read port="filename" place="shared_file" />
      <connect-out port="done" place="done_run_b" />
    </transition>

    <place name="done_run_b" type="control" />

    <transition name="wait_until_B_is_complete" inline="true">
      <use name="wait_control"/>
      <place-map virtual="wait" real="wait_B" />
      <connect-in  port="trigger" place="done_run_b" />
      <connect-out port="done"    place="done_B" />
    </transition>

    <place name="done_B" type="control" />

    <!-- path B complete -->

    <!-- everything done, remove tokens -->

    <transition name="finalize">
      <defun>
	<in name="done_A" type="control" />
	<in name="done_B" type="control" />
	<in name="shared_file" type="string" />
	<out name="done" type="control" />
	<expression>
	  ${done} := []
	</expression>
      </defun>
      <connect-in  port="done_A" place="done_A" />
      <connect-in  port="done_B" place="done_B" />
      <connect-in  port="shared_file" place="shared_file" />
      <connect-out port="done"   place="done" />
    </transition>
  </net>
</defun>
