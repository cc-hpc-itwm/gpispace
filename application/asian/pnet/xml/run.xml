<defun>
  <struct name="state">
    <field name="its" type="long"/>
    <field name="param" type="param"/>
  </struct>

  <struct name="wait">
    <field name="n" type="long"/>
  </struct>

  <in name="param" type="param" place="param"/>
  <out name="sums" type="sums" place="sums"/>

  <net>
    <place name="param" type="param"/>
    <place name="sums" type="sums"/>

    <transition name="init">
      <defun>
        <in name="param" type="param"/>
        <out name="state" type="state"/>
        <out name="wait" type="wait"/>
        <out name="accu" type="sums"/>
        <expression>
          ${state.param} := ${param};
          ${state.its} := 0L;
          ${wait.n} := (${param.iterations_per_run} + ${param.n} - 1L)
                       div ${param.iterations_per_run};
          ${accu.sum1} := 0.0;
          ${accu.sum2} := 0.0;
          ${accu.param} := ${param};
        </expression>
      </defun>
      <connect-in port="param" place="param"/>
      <connect-out port="state" place="state"/>
      <connect-out port="wait" place="wait"/>
      <connect-out port="accu" place="accu"/>
    </transition>

    <place name="state" type="state"/>
    <place name="wait" type="wait"/>
    <place name="accu" type="sums"/>

    <transition name="generate">
      <properties name="fhg">
        <properties name="pnetv">
	  <property key="firings_limit">1</property>
	</properties>
      </properties>
      <defun>
        <in name="state" type="state"/>
        <out name="state" type="state"/>
        <out name="param" type="param"/>
        <expression>
          ${param} := ${state.param};
          ${state.its} := ${state.its} + ${state.param.iterations_per_run}
        </expression>
      </defun>
      <condition>
        ${state.its} :lt: ${state.param.n}
      </condition>
      <connect-in port="state" place="state"/>
      <connect-out port="state" place="state"/>
      <connect-out port="param" place="param_to_run"/>
    </transition>

    <place name="param_to_run" type="param"/>

    <transition name="run">
      <defun>
        <in name="param" type="param"/>
        <out name="sums" type="sums"/>
        <module name="asian" function="sums run (param)">
          <cinclude href="run_impl.hpp"/>
          <ld flag="-lprocess"/>
          <code><![CDATA[
            return ::asian::run (param);
          ]]></code>
        </module>
      </defun>
      <connect-in port="param" place="param_to_run"/>
      <connect-out port="sums" place="sums_part"/>
    </transition>

    <place name="sums_part" type="sums"/>

    <transition name="accum">
      <defun>
        <out name="wait" type="wait"/>
        <in name="wait" type="wait"/>
        <in name="sums" type="sums"/>
        <in name="accu" type="sums"/>
        <out name="accu" type="sums"/>
        <expression>
          ${wait.n} := ${wait.n} - 1L;
          ${accu.sum1} := ${accu.sum1} + ${sums.sum1};
          ${accu.sum2} := ${accu.sum2} + ${sums.sum2};
        </expression>
      </defun>
      <condition>
        ${wait.n} :gt: 0L
      </condition>
      <connect-out port="wait" place="wait"/>
      <connect-in port="accu" place="accu"/>
      <connect-out port="accu" place="accu"/>
      <connect-in port="sums" place="sums_part"/>
      <connect-in port="wait" place="wait"/>
    </transition>

    <transition name="done">
      <defun>
        <in name="state" type="state"/>
        <in name="accu" type="sums"/>
        <in name="wait" type="wait"/>
        <out name="accu" type="sums"/>
        <expression/>
      </defun>
      <condition>
        ${wait.n} :le: 0L
      </condition>
      <connect-in port="state" place="state"/>
      <connect-in port="wait" place="wait"/>
      <connect-in port="accu" place="accu"/>
      <connect-out port="accu" place="sums"/>
    </transition>

  </net>
</defun>
