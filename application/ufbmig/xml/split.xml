<defun>
  <in name="config" type="config" place="config"/>
  <in name="interval" type="interval" place="interval"/>
  <out name="interval_tagged" type="interval_tagged_with_id" place="splitted"/>
  <tunnel name="wait" type="long" place="wait"/>

  <net>
    <place name="config" type="config"/>
    <place name="interval" type="interval"/>
    <place name="splitted" type="interval_tagged_with_id"/>

    <struct name="intervals">
      <field name="interval" type="interval"/>
      <field name="sizes" type="stack"/>
      <field name="useds" type="stack"/>
      <field name="ids" type="stack"/>
    </struct>

    <transition name="split">
      <defun>
        <in name="config" type="config"/>
        <in name="interval" type="interval"/>
        <out name="intervals" type="intervals"/>
        <module name="ufbmig_calc" function="intervals split (config, interval)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="algorithm"/>
          <cinclude href="stdexcept"/>
          <code><![CDATA[
            if (interval.used <= 0)
              {
                throw std::runtime_error
                  ("STRANGE: empty interval given to split");
              }

            waitComm ( fvmGetGlobalData
                       ( static_cast<fvmAllocHandle_t> (config.handle.data.update)
                       , interval.offset
                       , interval.used
                       , 0
                       , 0
                       )
                     );

            char * update_descr = static_cast<char *> (fvmGetShmemPtr());

            std::sort (update_descr, update_descr + interval.used);

            waitComm ( fvmPutGlobalData
                       ( static_cast<fvmAllocHandle_t> (config.handle.data.update)
                       , interval.offset
                       , interval.used
                       , 0
                       , 0
                       )
                     );

            char x (update_descr[0]);

            ::pnetc::type::intervals::intervals intervals;

            intervals.interval = interval;
            intervals.sizes.push_front (1L);
            intervals.useds.push_front (1L);
            intervals.ids.push_front (static_cast<long>(x - 'a'));

            for (long i (1); i < interval.used; ++i)
              {
                const char & y (update_descr[i]);

                if (y != x)
                  {
                    x = y;

                    intervals.sizes.push_front (1L);
                    intervals.useds.push_front (1L);
                    intervals.ids.push_front (static_cast<long>(x - 'a'));
                  }
                else
                  {
                    intervals.sizes.front() = boost::get<long>(intervals.sizes.front()) + 1L;
                    intervals.useds.front() = boost::get<long>(intervals.useds.front()) + 1L;
                  }
              }

            intervals.sizes.front() = boost::get<long>(intervals.sizes.front()) + interval.size - interval.used;

            {
              std::ostringstream oss;

              for (long i (interval.used); i < interval.size; ++i)
                {
                  oss << ".";
                }

              LOG ( INFO
                  , "SPLITTED "
                  << std::string (update_descr, update_descr + interval.used)
                  << oss.str()
                  << " into " << intervals
                  );
            }

            return intervals;
          ]]></code>
        </module>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-in port="interval" place="interval"/>
      <connect-out port="intervals" place="update_wait"/>
    </transition>

    <place name="update_wait" type="intervals"/>

    <transition name="update_wait">
      <defun>
        <in name="intervals" type="intervals"/>
        <out name="intervals" type="intervals"/>
        <in name="wait" type="long"/>
        <out name="wait" type="long"/>
        <expression>
          ${wait} := ${wait} - 1L + stack_size (${intervals.sizes})
        </expression>
      </defun>
      <connect-in port="intervals" place="update_wait"/>
      <connect-out port="intervals" place="pre_intervals"/>
      <connect-in port="wait" place="wait"/>
      <connect-out port="wait" place="wait"/>
    </transition>

    <place name="pre_intervals" type="intervals"/>

    <transition name="select">
      <defun>
        <in name="intervals" type="intervals"/>
        <out name="intervals" type="intervals"/>
        <in name="credit_intervals" type="control"/>
        <expression/>
      </defun>
      <connect-in port="intervals" place="pre_intervals"/>
      <connect-out port="intervals" place="intervals"/>
      <connect-in port="credit_intervals" place="credit_intervals"/>
    </transition>

    <place name="intervals" type="intervals"/>
    <place name="credit_intervals" type="control">
      <token><value>[]</value></token>
    </place>
    <place name="wait" type="long" virtual="true"/>

    <transition name="empty">
      <defun>
        <in name="intervals" type="intervals"/>
        <out name="credit_intervals" type="control"/>
        <expression>
          ${credit_intervals} := []
        </expression>
        <condition>
          stack_empty (${intervals.sizes})
        </condition>
      </defun>
      <connect-in port="intervals" place="intervals"/>
      <connect-out port="credit_intervals" place="credit_intervals"/>
    </transition>

    <transition name="not_empty">
      <defun>
        <in name="intervals" type="intervals"/>
        <out name="intervals" type="intervals"/>
        <out name="credit_intervals" type="control"/>
        <expression>
          ${credit_intervals} := []
        </expression>
        <condition>
          !stack_empty (${intervals.sizes})
        </condition>
      </defun>
      <connect-in port="intervals" place="intervals"/>
      <connect-out port="intervals" place="nonempty_intervals"/>
      <connect-out port="credit_intervals" place="credit_intervals"/>
    </transition>

    <place name="nonempty_intervals" type="intervals"/>

    <transition name="take">
      <defun>
        <in name="intervals" type="intervals"/>
        <out name="intervals" type="intervals"/>
        <out name="interval" type="interval_tagged_with_id"/>
        <expression>
          ${interval.interval} := ${intervals.interval};
          ${interval.interval.size} := stack_top (${intervals.sizes});
          ${interval.interval.used} := stack_top (${intervals.useds});
          ${interval.id} := stack_top (${intervals.ids});

          ${intervals.interval.offset} :=
            ${intervals.interval.offset} + stack_top (${intervals.sizes});

          ${intervals.sizes} := stack_pop (${intervals.sizes});
          ${intervals.useds} := stack_pop (${intervals.useds});
          ${intervals.ids} := stack_pop (${intervals.ids});
        </expression>
      </defun>
      <connect-in port="intervals" place="nonempty_intervals"/>
      <connect-out port="intervals" place="pre_intervals"/>
      <connect-out port="interval" place="splitted"/>
    </transition>

  </net>

</defun>
