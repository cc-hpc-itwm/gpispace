<defun name="kdm">

  <include-structs href="types.xml"/>

  <in name="config_file" type="string" place="config_file"/>
  <in name="memsizeGPI" type="long" place="memsizeGPI"/>

  <out name="done" type="control" place="done"/>

  <net>

    <place name="config_file" type="string" />
    <place name="memsizeGPI" type="long" />

    <place name="done" type="control"/>
    <place name="config_initialized" type="config"/>

    <place name="store_bunch_put" type="store_bunch"/>
    <place name="store_bunch_get" type="store_bunch"/>
    <place name="store_volume" type="store_volume"/>

    <place name="bunch_store_assoc_offset" type="map"/>

    <place name="volumes_left" type="long"/>

    <!-- ****************************************************************** -->

    <transition name="init_config" inline="true">
      <include-function href="init/config.xml"/>
      <connect-in port="config_file" place="config_file"/>
      <connect-in port="memsizeGPI" place="memsizeGPI"/>
      <connect-out port="config" place="config_initialized"/>
      <connect-out port="assoc" place="bunch_store_assoc_offset"/>
      <connect-out port="volumes_left" place="volumes_left"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="config_generate_store" type="config"/>
    <place name="config_generate_item" type="config"/>
    <place name="config_loadTT" type="config"/>
    <place name="config" type="config"/>

    <include-template href="4.xml"/>
    <specialize name="dist_config" use="quad">
      <type-map replace="T" with="config"/>
    </specialize>

    <transition name="dist_config" inline="true">
      <use name="dist_config"/>
      <connect-in port="in" place="config_initialized"/>
      <connect-out port="one" place="config"/>
      <connect-out port="two" place="config_generate_store"/>
      <connect-out port="three" place="config_generate_item"/>
      <connect-out port="four" place="config_loadTT"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="loadTT" inline="true">
      <include-function href="loadTT.xml"/>
      <connect-in port="config" place="config_loadTT"/>
      <connect-out port="config" place="config_process"/>
    </transition>

    <place name="config_process" type="config"/>

    <!-- ****************************************************************** -->

    <transition name="generate_store" inline="true">
      <include-function href="generate/store.xml"/>
      <connect-in port="config" place="config_generate_store"/>
      <connect-out port="store_bunch" place="store_bunch_put"/>
      <connect-out port="store_volume" place="store_volume"/>
      <connect-out port="number_store_volume" place="number_store_volume"/>
      <connect-out port="number_store_bunch" place="number_store_bunch"/>
    </transition>

    <place name="number_store_volume" type="long"/>
    <place name="number_store_bunch" type="long"/>

    <transition name="generate_item" inline="true">
      <include-function href="generate/item.xml"/>
      <place-map virtual="store_bunch_put" real="store_bunch_put"/>
      <place-map virtual="store_bunch_get" real="store_bunch_get"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <place-map virtual="assoc" real="bunch_store_assoc_offset"/>
      <connect-in port="config" place="config_generate_item"/>
      <connect-out port="volume_state" place="volume_state"/>
      <connect-out port="volume_with_store" place="volume_with_store"/>
      <connect-out port="bunch_with_store" place="bunch_with_store"/>
    </transition>

    <place name="volume_state" type="volume_state"/>
    <place name="volume_with_store" type="volume_with_store"/>
    <place name="bunch_with_store" type="bunch_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="load_bunch" inline="true">
      <include-function href="load/bunch.xml"/>
      <connect-read port="config" place="config"/>
      <connect-in port="bunch_with_store" place="bunch_with_store"/>
      <connect-out port="bunch_loaded" place="bunch_loaded"/>
    </transition>

    <place name="bunch_loaded" type="bunch_loaded"/>

    <!-- ****************************************************************** -->

    <transition name="initialize_volume" inline="true">
      <include-function href="init/volume.xml"/>
      <connect-read port="config" place="config"/>
      <connect-in port="volume_with_store" place="volume_with_store"/>
      <connect-out port="volume_in_progress" place="volume_in_progress"/>
    </transition>

    <place name="volume_in_progress" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="assign">
      <defun>

        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>

        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>

        <expression>
          ${volume.assigned.bunch.id} := ${bunch.bunch.bunch.id};
          ${volume.assigned.store.id} := ${bunch.bunch.store.id};

          ${bunch.bunch.volumes.seen.id}
            := bitset_insert ( ${bunch.bunch.volumes.seen.id}
                             , ${volume.volume.volume.id}
                             )
        </expression>

        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          !bitset_is_element (${bunch.bunch.volumes.seen.id}, ${volume.volume.volume.id})
        </condition>
      </defun>

      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="bunch" place="bunch_loaded"/>

      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="volume" place="volume_to_process"/>
    </transition>

    <place name="volume_to_process" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="process">
      <require key="GPI" />
      <require key="CPU" />
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <module name="kdmfull" function="process (config, volume)"/>
      </defun>
      <connect-read port="config" place="config_process"/>
      <connect-in port="volume" place="volume_to_process"/>
      <connect-out port="volume" place="volume_processed"/>
    </transition>

    <place name="volume_processed" type="volume_in_progress"/>

    <include-template href="dup.xml"/>
    <specialize name="dup_volume_in_progress" use="dup">
      <type-map replace="T" with="volume_in_progress"/>
    </specialize>

    <place name="update_bunch_state" type="volume_in_progress"/>

    <!-- ****************************************************************** -->

    <transition name="update_volume_state">
      <defun>
        <in name="processed" type="volume_in_progress"/>
        <in name="credit_volume_done" type="control"/>
        <out name="processed" type="volume_in_progress"/>
        <in name="state" type="volume_state"/>
        <out name="state" type="volume_state"/>
        <expression>
          ${state.bunches.left} := ${state.bunches.left} - 1L;
        </expression>
        <condition>${state.volume} :eq: ${processed.volume.volume}</condition>
      </defun>
      <connect-in port="processed" place="volume_processed"/>
      <connect-in port="state" place="volume_state"/>
      <connect-out port="state" place="check_volume_done"/>
      <connect-out port="processed" place="wait_update_bunch_state"/>
      <connect-in port="credit_volume_done" place="credit_volume_done"/>
    </transition>

    <place name="wait_update_bunch_state" type="volume_in_progress"/>
    <place name="check_volume_done" type="volume_state"/>
    <place name="credit_volume_done" type="control">
      <token><value>[]</value></token>
    </place>

    <!-- ****************************************************************** -->

    <transition name="unassign">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="bunch" type="bunch_loaded"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="volume" type="volume_in_progress"/>
        <expression>
          ${bunch.wait} := ${bunch.wait} - 1L;

          ${volume.assigned.bunch.id} := -1L;
          ${volume.assigned.store.id} := -1L;
        </expression>
        <condition>
          ${bunch.bunch.bunch.offset.id} :eq: ${volume.volume.volume.offset.id}
        </condition>
        <condition>
          ${bunch.bunch.bunch.id} :eq: ${volume.assigned.bunch.id}
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="bunch" place="bunch_loaded"/>
      <connect-in port="volume" place="update_bunch_state"/>
      <connect-out port="volume" place="volume_in_progress"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="bunch_done">
      <defun>
        <in name="bunch" type="bunch_loaded"/>
        <out name="store" type="store_bunch"/>
        <expression>
          ${store} := ${bunch.bunch.store}
        </expression>
        <condition>
          ${bunch.wait} :le: 0L
        </condition>
      </defun>
      <connect-in port="bunch" place="bunch_loaded"/>
      <connect-out port="store" place="store_bunch_put"/>
    </transition>

    <!-- ****************************************************************** -->

    <transition name="volume_done">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="processed" type="volume_in_progress"/>
        <out name="processed" type="volume_in_progress"/>
        <out name="state" type="volume_state"/>
        <out name="credit_volume_done" type="control"/>
        <expression>
          ${credit_volume_done} := []
        </expression>
        <condition>
          ${state.bunches.left} :le: 0L
        </condition>
      </defun>
      <connect-in port="state" place="check_volume_done"/>
      <connect-out port="state" place="volume_done"/>
      <connect-in port="processed" place="wait_update_bunch_state"/>
      <connect-out port="processed" place="update_bunch_state"/>
      <connect-out port="credit_volume_done" place="credit_volume_done"/>
    </transition>

    <transition name="not_volume_done">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="processed" type="volume_in_progress"/>
        <out name="processed" type="volume_in_progress"/>
        <out name="state" type="volume_state"/>
        <out name="credit_volume_done" type="control"/>
        <expression>
          ${credit_volume_done} := []
        </expression>
        <condition>
          ${state.bunches.left} :gt: 0L
        </condition>
      </defun>
      <connect-in port="state" place="check_volume_done"/>
      <connect-out port="state" place="volume_state"/>
      <connect-in port="processed" place="wait_update_bunch_state"/>
      <connect-out port="processed" place="update_bunch_state"/>
      <connect-out port="credit_volume_done" place="credit_volume_done"/>
    </transition>

    <place name="volume_done" type="volume_state"/>

    <transition name="reduce_start">
      <defun>
        <in name="state" type="volume_state"/>
        <in name="volume" type="volume_in_progress"/>
        <out name="sum" type="volume_in_reduction"/>
        <expression>
          ${sum.volume} := ${volume.volume};
          ${sum.left} := ${state.copies} - 1L;
        </expression>
        <condition>
          ${state.volume} :eq: ${volume.volume.volume}
        </condition>
      </defun>
      <connect-in port="state" place="volume_done"/>
      <connect-in port="volume" place="volume_in_progress"/>
      <connect-out port="sum" place="volume_in_reduction"/>
    </transition>

    <place name="volume_in_reduction" type="volume_in_reduction"/>

    <transition name="reduce_pair">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <in name="vol" type="volume_in_progress"/>
        <out name="pair" type="pair_to_reduce"/>
        <expression>
          ${pair.sum} := ${sum};
          ${pair.vol} := ${vol.volume}
        </expression>
        <condition>
          ${sum.volume.volume} :eq: ${vol.volume.volume}
        </condition>
      </defun>
      <connect-in port="vol" place="volume_in_progress"/>
      <connect-in port="sum" place="volume_in_reduction"/>
      <connect-out port="pair" place="pair_to_reduce"/>
    </transition>

    <place name="pair_to_reduce" type="pair_to_reduce"/>

    <transition name="reduce">
      <require key="GPI" />
      <require key="CPU" />
      <defun>
        <in name="config" type="config"/>
        <in name="pair" type="pair_to_reduce"/>
        <out name="pair" type="pair_to_reduce"/>
        <module name="kdmfull" function="reduce (config, pair)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="pair" place="pair_to_reduce"/>
      <connect-out port="pair" place="pair_reduced"/>
    </transition>

    <place name="pair_reduced" type="pair_to_reduce"/>

    <transition name="reduce_unpair">
      <defun>
        <in name="pair" type="pair_to_reduce"/>
        <out name="sum" type="volume_in_reduction"/>
        <out name="volume" type="volume_with_store"/>
        <expression>
          ${sum} := ${pair.sum};
          ${sum.left} := ${sum.left} - 1L;
          ${volume} := ${pair.vol}
        </expression>
      </defun>
      <connect-in port="pair" place="pair_reduced"/>
      <connect-out port="sum" place="volume_in_reduction"/>
      <connect-out port="volume" place="volume_written"/>
    </transition>

    <transition name="reduce_done">
      <defun>
        <in name="sum" type="volume_in_reduction"/>
        <out name="volume" type="volume_with_store"/>
        <expression>
          ${volume} := ${sum.volume}
        </expression>
        <condition>
          ${sum.left} :le: 0L
        </condition>
      </defun>
      <connect-in port="sum" place="volume_in_reduction"/>
      <connect-out port="volume" place="volume_to_be_written"/>
    </transition>

    <place name="volume_to_be_written" type="volume_with_store"/>

    <!-- ****************************************************************** -->

    <transition name="write">
      <require key="GPI" />
      <require key="WRITE" />
      <defun>
        <in name="config" type="config"/>
        <in name="volume" type="volume_with_store"/>
        <out name="volume" type="volume_with_store"/>
        <module name="kdmfull" function="write (config, volume)"/>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="volume" place="volume_to_be_written"/>
      <connect-out port="volume" place="volume_written"/>
    </transition>

    <place name="volume_written" type="volume_with_store"/>

    <transition name="post_write">
      <defun>
        <in name="volume_written" type="volume_with_store"/>
        <out name="volume" type="volume"/>
        <out name="store" type="store_volume"/>
        <expression>
          ${volume} := ${volume_written.volume};
          ${store} := ${volume_written.store}
        </expression>
      </defun>
      <connect-in port="volume_written" place="volume_written"/>
      <connect-out port="volume" place="volume_to_be_finalized"/>
      <connect-out port="store" place="store_volume"/>
    </transition>

    <!-- ****************************************************************** -->

    <place name="volume_to_be_finalized" type="volume"/>

    <include-template href="wait.xml"/>
    <specialize name="wait_volume" use="wait">
      <type-map replace="T" with="volume"/>
    </specialize>

    <transition name="wait_volume">
      <use name="wait_volume"/>
      <place-map virtual="wait" real="volumes_left"/>
      <connect-in port="trigger" place="volume_to_be_finalized"/>
      <connect-out port="done" place="volumes_done"/>
    </transition>

    <place name="volumes_done" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="eat_store" inline="true">
      <include-function href="eat/store.xml"/>
      <place-map virtual="store_bunch" real="store_bunch_get"/>
      <place-map virtual="store_volume" real="store_volume"/>
      <connect-in port="number_store_volume" place="number_store_volume"/>
      <connect-in port="number_store_bunch" place="number_store_bunch"/>
      <connect-in port="trigger" place="volumes_done"/>
      <connect-out port="done" place="done_eat_store"/>
    </transition>

    <place name="done_eat_store" type="control"/>

    <transition name="cleanup">
      <defun>
        <in name="config" type="config"/>
        <in name="assoc" type="map"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <expression></expression>
      </defun>
      <connect-in port="config" place="config_process"/>
      <connect-in port="assoc" place="bunch_store_assoc_offset"/>
      <connect-in port="trigger" place="done_eat_store"/>
      <connect-out port="trigger" place="done_cleanup"/>
    </transition>

    <place name="done_cleanup" type="control"/>

    <!-- ****************************************************************** -->

    <transition name="finalize">
      <require key="GPI" />
      <require key="finalize" />
      <defun>
        <in name="config" type="config"/>
        <in name="trigger" type="control"/>
        <out name="trigger" type="control"/>
        <module name="kdmfull" function="trigger finalize (config)"/>
      </defun>
      <connect-in port="config" place="config"/>
      <connect-in port="trigger" place="done_cleanup"/>
      <connect-out port="trigger" place="done"/>
   </transition>
  </net>
</defun>
