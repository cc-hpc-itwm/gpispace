<!-- tiberiu.rotaru@itwm.fraunhofer.de -->
<defun name="mapreduce">
  <include-structs href="types.xpnet"/>

  <in name="input_file" type="string" place="input_file"/>
  <in name="output_file" type="string" place="output_file"/>
  <in name="read_chunk_size" type="long" place="read_chunk_size"/>
  <in name="map_chunk_size" type="long" place="map_chunk_size"/>
  <in name="n_part" type="long" place="input_n_part"/>
  <in name="partition_slot_size" type="long" place="partition_slot_size"/>
  <in name="reduce_slot_size" type="long" place="reduce_slot_size"/>
  <in name="input_n_read_slots" type="long" place="input_n_read_slots"/>
  <in name="input_n_map_slots" type="long" place="input_n_map_slots"/>
  <out name="done" type="control" place="done"/>

  <net>
    <place name="input_file" type="string"/>
    <place name="output_file" type="string"/>
    <place name="read_chunk_size" type="long"/>
    <place name="map_chunk_size" type="long"/>
    <place name="input_n_read_slots" type="long"/>
    <place name="input_n_map_slots" type="long"/>

    <place name="config" type="config"/>
    <place name="n_read_slots" type="long"/>
    <place name="n_map_slots" type="long"/>
    <place name="n_part_slots" type="long"/>

    <place name="n_chunks" type="long"/>

    <place name="input_n_part" type="long"/>
    <place name="partition_slot_size" type="long"/>
    <place name="reduce_slot_size" type="long"/>

    <place name="done" type="control"/>

    <!-- template specializations -->
    <include-template href="dup.xml" />
    <specialize name="dup_counter" use="dup">
      <type-map replace="T" with="long" />
    </specialize>

    <!-- template specializations -->
    <include-template href="triple.xml" />
    <specialize name="triple_counter" use="triple">
      <type-map replace="T" with="long" />
    </specialize>

    <specialize name="triple_control" use="triple">
      <type-map replace="T" with="control"/>
    </specialize>

     <specialize name="dup_control" use="dup">
      <type-map replace="T" with="control"/>
    </specialize>

    <transition name="init" inline="true">
      <require key="GPI" />
      <require key="INI" />
      <defun>
        <in name="input_file" type="string"/>
        <in name="output_file" type="string"/>
        <in name="read_chunk_size" type="long"/>
        <in name="map_chunk_size" type="long"/>
        <in name="input_n_read_slots" type="long"/>
        <in name="input_n_map_slots" type="long"/>
        <in name="n_part" type="long"/>
        <in name="partition_slot_size" type="long"/>
		<in name="reduce_slot_size" type="long"/>
        <out name="config" type="config"/>
        <out name="n_read_slots" type="long"/>
        <out name="n_map_slots" type="long"/>
        <out name="n_part_slots" type="long"/>
        <out name="n_chunks" type="long"/>

        <module name="create_config" function="config create_config(input_file, output_file,
        															read_chunk_size, map_chunk_size,
                                               						input_n_read_slots, input_n_map_slots,
                                               						n_chunks, n_read_slots, n_map_slots,
                                               						n_part, partition_slot_size,
                                               						n_part_slots, reduce_slot_size)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="cstdio"/>
          <cinclude href="sstream"/>
          <cinclude href="fstream"/>
          <cinclude href="cmath"/>
          <code><![CDATA[

	  		  	if(map_chunk_size<read_chunk_size)
			  	{
			  		throw std::runtime_error("The size of the map chunk size should be larger than the size of the read chunk size!" );
			  	}

	  		  	/*if(partition_slot_size<map_chunk_size)
			  	{
			  		throw std::runtime_error("The size of the partition slot should be larger than the size of the map chunk size!" );
			  	}*/

			  	if(reduce_slot_size<partition_slot_size)
			  	{
			  		throw std::runtime_error("The size of the reduce slot should be larger than the size of the partition slot!" );
			  	}

			  	if(n_part<3)
			  	{
			  		throw std::runtime_error("Please, indicate a number larger than 2 for the number of partitions!" );
			  	}

	          	//MLOG (INFO, "Get the size of the file " << input_file);
	          	FILE *pf;
	          	if((pf = fopen(input_file.c_str(), "r"))== NULL)
	          	{
	          		std::ostringstream oss;
	          		oss<<"  Could not open the file " <<input_file << "!";
	          		MLOG(ERROR, oss.str());
	          		throw std::runtime_error(oss.str());
	          	}

	          	fseek(pf, 0L, SEEK_END);
	          	long input_file_size = ftell(pf);
	          	fclose(pf);

	          	::pnetc::type::config::config config;
	          	printf ("Size of %s is: %ld bytes.\n", input_file.c_str(),input_file_size);
	          	if(input_file_size<=0)
	          	{
	          		throw std::runtime_error("invalid size for the input file!!!" );
	          	}

			  	// take a reserve of chunk slots-> write_to_buff in chunks only complete words!
			  	n_chunks = ::mapreduce::util::ceil(input_file_size,read_chunk_size);

	          	//MLOG (INFO, "The file should be splitted into " <<n_chunks<<" chunks, where read_chunk_size ="<<read_chunk_size<<"!");

	          	long n_nodes = fvmGetNodeCount();
	          	//MLOG (INFO, "The number of nodes used by GPI: "<<n_nodes);

	          	size_t size_read_area  = ::mapreduce::util::ceil(read_chunk_size*input_n_read_slots,n_nodes);
	          	size_t size_map_area = ::mapreduce::util::ceil(map_chunk_size*input_n_map_slots,n_nodes);
	          	size_t size_partition_area = ::mapreduce::util::ceil(partition_slot_size*n_part,n_nodes);
	          	size_t size_reduce_area = ::mapreduce::util::ceil(reduce_slot_size*n_part,n_nodes);

			  	const int mb = 1024;
	          	MLOG (INFO, "Size of the read area to be allocated: "<<size_read_area/mb<<"mb");
	          	MLOG (INFO, "Size of the map area to be allocated: "<<size_map_area/mb<<"mb");
		  	  	MLOG (INFO, "Size of the partition area to be allocated: "<<size_partition_area/mb<<"mb");
	          	MLOG (INFO, "Size of the reduce area to be allocated: "<<size_reduce_area/mb<<"mb");

	          	size_t total_vm_required  = (size_read_area + size_map_area + size_partition_area + size_reduce_area )/mb;
	          	MLOG (INFO, "The application requires "<<total_vm_required<<"mb of virtual memory in total!");

	          	config.file.input = input_file;
	          	config.file.output = output_file;

				std::ostringstream oss;
				config.handle.read = fvmGlobalAlloc(size_read_area, "mapred.read_area");
			  	if(config.handle.read)
			  	{
			  		config.handle.map = fvmGlobalAlloc(size_map_area, "mapred.map_area");
			  		if(config.handle.map)
			  		{
			  			config.handle.partition = fvmGlobalAlloc(size_partition_area, "mapred.partition_area");
			  			if(config.handle.partition)
			  			{
			  				config.handle.reduce = fvmGlobalAlloc(size_reduce_area, "mapred.reduce_area");
			  				if(!config.handle.reduce)
			  				{
			  					fvmGlobalFree(static_cast<fvmAllocHandle_t>(config.handle.read));
			  					fvmGlobalFree(static_cast<fvmAllocHandle_t>(config.handle.map));
			  					fvmGlobalFree(static_cast<fvmAllocHandle_t>(config.handle.partition));

			  					oss << "Failed to alloc "<< size_reduce_area << " bytes for the reduce slots!";
				  				throw std::runtime_error(oss.str());
			  				}
			  			}
			  			else
			  			{
			  				fvmGlobalFree(static_cast<fvmAllocHandle_t>(config.handle.read));
			  				fvmGlobalFree(static_cast<fvmAllocHandle_t>(config.handle.map));

			  				oss << "Failed to alloc "<< size_partition_area << " bytes for the partition slots!";
				  			throw std::runtime_error(oss.str());
			  			}
			  		}
			  		else
			  		{
			  			// free the already allocated virtual memory
			  			fvmGlobalFree(static_cast<fvmAllocHandle_t>(config.handle.read));
			  			oss << "Failed to alloc "<< size_map_area << " bytes for the map slots!";
				  		throw std::runtime_error(oss.str());
			  		}
			  	}
			  	else
			  	{
					oss << "Failed to alloc "<< size_read_area << " bytes for the reduce slots!";
				  	throw std::runtime_error (oss.str());
			  	}

	          	MLOG(INFO, "The number of chunks is: "<<n_chunks);
	          	config.num.chunks = n_chunks;
	          	config.num.part = n_part; // number of partitions

	          	config.size.chunk.read = read_chunk_size;
	          	config.size.chunk.map = map_chunk_size;
	          	config.size.partition.slot = partition_slot_size;
	          	config.size.reduce.slot = reduce_slot_size;

	          	n_read_slots = input_n_read_slots;
	          	n_map_slots = input_n_map_slots;
			  	n_part_slots = n_part;

	          	LOG (INFO, "The config is: " << config);

	          	return config;
          ]]></code>
        </module>

      </defun>
      <connect-in  port="input_file" place="input_file"/>
      <connect-in  port="output_file"  place="output_file"/>
      <connect-in  port="read_chunk_size" place="read_chunk_size"/>
      <connect-in  port="map_chunk_size" place="map_chunk_size"/>
      <connect-in  port="n_part" place="input_n_part"/>
      <connect-in  port="partition_slot_size" place="partition_slot_size"/>
      <connect-in  port="reduce_slot_size" place="reduce_slot_size"/>
      <connect-in  port="input_n_read_slots" place="input_n_read_slots"/>
      <connect-in  port="input_n_map_slots" place="input_n_map_slots"/>
      <connect-out port="config" place="config"/>
      <connect-out port="n_read_slots" place="n_read_slots"/>
      <connect-out port="n_map_slots" place="n_map_slots"/>
      <connect-out port="n_part_slots" place="n_part_slots"/>
      <connect-out port="n_chunks" place="n_chunks"/>
    </transition>

    <!-- begin generate partition info tokens, put this into some subnet later -->
    <place name="n_part_slots_cnt" type="long"/>
    <place name="n_part_slots_gen" type="long"/>
    <transition name="dup_n_part_slots" inline="true">
      <use name="dup_counter" />
      <connect-in port="in" place="n_part_slots"/>
      <connect-out port="one" place="n_part_slots_gen"/>
      <connect-out port="two" place="n_part_slots_cnt"/>
    </transition>

    <place name="part_id" type="long"/>
    <transition name="generate_part_ids" inline="true">
      <include-function href="sequence.xml"/>
      <connect-in port="amount" place="n_part_slots_gen"/>
      <connect-out port="out" place="part_id"/>
    </transition>

    <place name="partition_info" type="partition_info"/>
    <place name="reduce_info" type="reduce_info"/>
    <transition name="gen_part_info" inline="true">
      <defun>
        <in name="part_id" type="long"/>
        <out name="partition_info" type="partition_info"/>
        <out name="reduce_info" type="reduce_info"/>
        <expression>
		  	${partition_info.part_id}:=${part_id};
		  	${partition_info.part_used}:=0L;
            ${reduce_info.part_id}:=${part_id};
		  	${reduce_info.red_used}:=0L;
		  	${reduce_info.old_red_used}:=0L;
        </expression>
      </defun>
      <connect-in port="part_id" place="part_id"/>
      <connect-out port="partition_info" place="partition_info"/>
      <connect-out port="reduce_info" place="reduce_info"/>
    </transition>

    <place name="n_map_slots_cnt" type="long"/>
    <place name="n_map_slots_gen" type="long"/>
    <transition name="dup_n_map_slots" inline="true">
      <use name="dup_counter" />
      <connect-in port="in" place="n_map_slots"/>
      <connect-out port="one" place="n_map_slots_gen"/>
      <connect-out port="two" place="n_map_slots_cnt"/>
    </transition>

    <place name="n_read_slots_gen" type="long"/>
    <place name="n_read_slots_cnt" type="long"/>
    <transition name="dup_n_read_slots" inline="true">
      <use name="dup_counter" />
      <connect-in port="in" place="n_read_slots"/>
      <connect-out port="one" place="n_read_slots_gen"/>
      <connect-out port="two" place="n_read_slots_cnt"/>
    </transition>

    <place name="n_chunks_left" type="long"/>
    <place name="n_chunks_gen" type="long"/>

    <transition name="dup_n_chunks" inline="true">
      <use name="dup_counter" />
      <connect-in port="in" place="n_chunks"/>
      <connect-out port="one" place="n_chunks_gen"/>
      <connect-out port="two" place="n_chunks_left"/>
    </transition>

    <place name="map_slot_id" type="long"/>
    <transition name="generate_map_slots" inline="true">
      <include-function href="sequence.xml"/>
      <connect-in port="amount" place="n_map_slots_gen"/>
      <connect-out port="out" place="map_slot_id"/>
    </transition>

    <transition name="generate_read_slots" inline="true">
      <include-function href="sequence.xml"/>
      <connect-in port="amount" place="n_read_slots_gen"/>
      <connect-out port="out" place="read_slot_id"/>
    </transition>

    <place name="chunk_and_slot" type="chunk_and_slot"/>
    <transition name="generate_chunk_and_slots" inline="true">
      <include-function href="generate_chunk_and_slot.xpnet"/>
      <connect-in port="amount" place="n_chunks_gen"/>
      <connect-out port="out" place="chunk_and_slot"/>
      <place-map virtual="slot" real="read_slot_id"/>
    </transition>

    <place name="read_chunk_info" type="read_chunk_info"/>
    <place name="read_slot_id" type="long"/>

    <transition name="load_chunk" inline="true">
      <require key="GPI" />
      <require key="LOAD" />
      <defun>
        <in name="chunk_and_slot" type="chunk_and_slot"/>
        <in name="config" type="config"/>
        <out name="read_chunk_info" type="read_chunk_info"/>

        <module name="load" function="read_chunk_info read_and_load_chunk(chunk_and_slot, config)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="util/memory.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="iostream"/>
          <cinclude href="fstream"/>
          <cinclude href="stdio.h"/>
          <cinclude href="cmath"/>
          <cinclude href="boost/lexical_cast.hpp"/>
          <cinclude href="fstream"/>
          <code><![CDATA[
            // MLOG (INFO, "Read the chunk "<<chunk_and_slot.chunk<<" from the file " << config.file.input<<" into slot " << chunk_and_slot.slot);

            FILE *file_ptr;
	        int num;

	 		size_t avail_shmem(fvmGetShmemSize());

	        if((file_ptr = fopen(config.file.input.c_str(), "r"))== NULL)
	        {
                std::ostringstream oss;
	          	oss<<"  Could not open the file " << config.file.input << "!";
	          	MLOG(ERROR, oss.str());
	          	throw std::runtime_error(oss.str());
            }

	        long offset = chunk_and_slot.chunk * config.size.chunk.read;
	        if( (fseek(file_ptr, offset, SEEK_SET)) != 0)
	        {
                printf("Error in seek operation: errno \n");
	          	exit(1);
            }

            size_t chunk_size = sizeof(char)*config.size.chunk.read;

            // copy it first into the shared memory
            // put into the read_area

            if( config.size.chunk.read > avail_shmem )
	        {
	        	std::stringstream sstr("Not enough shared memory reserved for reading a chunk (required: ");
	        	sstr<<config.size.chunk.read<<", available: "<<avail_shmem<<")";
                throw std::runtime_error( sstr.str() );
            }

	        char* read_buff = static_cast<char*> (fvmGetShmemPtr());
	        bzero(read_buff, chunk_size);

	        // copy the file into the buffer:
	        size_t used = fread (read_buff, 1, chunk_size, file_ptr);

	        //MLOG(INFO, "The content of the chunk "<<chunk_and_slot.chunk<<":\n"<<read_buff);

	        waitComm ( fvmPutGlobalData
	        ( static_cast<fvmAllocHandle_t> (config.handle.read)
	          									, chunk_and_slot.slot*config.size.chunk.read
	          									, used
	          									, 0
	          									, 0
	          								)
	        );

            // LOG ( INFO, "The chunk "<<chunk_and_slot.chunk<<" was successfully put into the virtual memory");

            pnetc::type::read_chunk_info::read_chunk_info c_r_info;

	        c_r_info.read_slot_id = chunk_and_slot.slot;
	        c_r_info.chunk_id = chunk_and_slot.chunk;
	        c_r_info.used = used;

	        fclose(file_ptr);
	        return c_r_info;
          ]]></code>
        </module>
      </defun>
      <connect-read port="config" place="config"/>
      <connect-in port="chunk_and_slot" place="chunk_and_slot"/>
      <connect-out port="read_chunk_info" place="read_chunk_info"/>
    </transition>


    <!-- map with tokenizer -->
    <place name="map_chunk_info" type="map_chunk_info"/>
    <transition name="map_chunk" inline="true">
      <require key="GPI" />
      <require key="MAP" />
      <defun>
        <in name="map_slot_id" type="long"/>
        <in name="read_chunk_info" type="read_chunk_info"/>
        <in name="config" type="config"/>
        <out name="map_chunk_info" type="map_chunk_info"/>
        <out name="read_slot_id" type="long"/>

        <module name="map" function="map_chunk_info map_chunk(map_slot_id, read_chunk_info, config, read_slot_id)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="util/map.hpp"/>
          <cinclude href="util/partition.hpp"/>
          <cinclude href="boost/algorithm/string/split.hpp"/>
          <cinclude href="boost/algorithm/string/iter_find.hpp"/>
          <cinclude href="boost/algorithm/string/classification.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="fstream"/>
          <cinclude href="ctype.h"/>
          <cinclude href="cstdio"/>
          <code><![CDATA[
            LOG (INFO, "Map the chunk "<<read_chunk_info.chunk_id<<" ... ");
            pnetc::type::map_chunk_info::map_chunk_info map_chnk_info;

        	if(config.size.chunk.map<config.size.chunk.read)
		  	{
		  		throw std::runtime_error("The size of the map chunk size should be larger than the size of the read chunk size!" );
		  	}

			long vm_part_offset = read_chunk_info.read_slot_id*config.size.chunk.read;
            char* ptr_shmem = static_cast<char *> (fvmGetShmemPtr());
            waitComm ( fvmGetGlobalData
            ( static_cast<fvmAllocHandle_t> (config.handle.read)
                                                    , vm_part_offset
                                                    , read_chunk_info.used
                                                    , 0
                                                    , 0
                                                )
            );

            ptr_shmem[read_chunk_info.used] = 0;

            char* ptr_next = ptr_shmem;
            std::string key, val;

            int n_part = config.num.part;
            size_t slot_size = config.size.partition.slot;

            std::vector<std::string> arr_part_buffs(n_part, "");
            std::vector<size_t> arr_part_used(n_part, 0);

            bool first_char_is_delim = first_char_is_delim = ::mapreduce::util::is_delimiter(ptr_shmem[0]);
            bool last_char_is_delim = ::mapreduce::util::is_delimiter(ptr_shmem[read_chunk_info.used - 1]);

            int n = 0, part_id;

            std::string str_buff(ptr_shmem);
            boost::char_separator<char> sep(DELIMITERS.c_str());
            boost::tokenizer<boost::char_separator<char> > tok(str_buff, sep);

            for(boost::tokenizer<boost::char_separator<char> >::iterator it = tok.begin(); it != tok.end(); ++it)
            {
                std::string str_pair("");
                std::string curr_item(*it);

                if( config.num.chunks > 1 )
                {
                    if( it ==  tok.begin() && read_chunk_info.chunk_id > 0 )
                    {
                        std::string spec_left_prefix = ::mapreduce::util::make_spec_left_prefix(read_chunk_info.chunk_id);

                        // the first char of the chunk is a separator/delimiter
                        if( first_char_is_delim )
                        {
                            str_pair = ::mapreduce::util::kvpair2str( ::mapreduce::util::key_val_pair_t( spec_left_prefix, " " ));
                            n = str_pair.size();
                            part_id = ::mapreduce::util::hash( str_pair, n_part);
                            arr_part_buffs[part_id] += str_pair;
                            arr_part_used[part_id] += n;
                        }
                        else
                        {
                            str_pair = ::mapreduce::util::kvpair2str( ::mapreduce::util::key_val_pair_t( spec_left_prefix, curr_item)) + SPCH;
                            n = str_pair.size();
                            part_id = ::mapreduce::util::hash( str_pair, n_part);
                            arr_part_buffs[part_id] += str_pair;
                            arr_part_used[part_id] += n;
                            continue;
                        }
                    }

                    if( boost::next(it) ==  tok.end() && read_chunk_info.chunk_id < config.num.chunks-1 )
                    {
                        std::string spec_right_prefix = ::mapreduce::util::make_spec_right_prefix(read_chunk_info.chunk_id);

                        // the last character of the chunk is a delimiter
                        if( last_char_is_delim )
                        {
                            str_pair = ::mapreduce::util::kvpair2str( ::mapreduce::util::key_val_pair_t( spec_right_prefix, " "));
                            n = str_pair.size();
                            part_id = ::mapreduce::util::hash( str_pair, n_part);
                            arr_part_buffs[part_id] += str_pair;
                            arr_part_used[part_id] += n;
                        }
                        else
                        {
                            str_pair = ::mapreduce::util::kvpair2str( ::mapreduce::util::key_val_pair_t( spec_right_prefix, curr_item)) + SPCH;
                            n = str_pair.size();
                            part_id = ::mapreduce::util::hash( str_pair, n_part);
                            arr_part_buffs[part_id] += str_pair;
                            arr_part_used[part_id] += n;
                            continue;
                        }
                    }
                }

                val = "";

                // call here the map function
                ::mapreduce::util::list_key_val_pairs_t list_key_val_pairs = ::mapreduce::util::map(curr_item, val);

                BOOST_FOREACH(::mapreduce::util::key_val_pair_t& key_val_pair, list_key_val_pairs)
                {
                    str_pair = ::mapreduce::util::kvpair2str( ::mapreduce::util::key_val_pair_t(key_val_pair.first, key_val_pair.second)) + SPCH;
                    n = str_pair.size();
                    part_id = ::mapreduce::util::hash( key_val_pair.first, n_part);
                    arr_part_buffs[part_id] += str_pair;
                    arr_part_used[part_id] += n;
                }
              }

              // copy the partition blocks into the corresponding map slot
              /*ptr_next = ptr_shmem;
              for( part_id = 0; part_id<n_part; part_id++ )
              {
				memcpy(ptr_next, arr_part_buffs[part_id].data(), arr_part_used[part_id]);
                ptr_next += arr_part_used[part_id];
              }*/

              size_t last_pos = 0;
              for( part_id = 0; part_id<n_part; part_id++ )
              {
              	 arr_part_used[part_id] = arr_part_buffs[part_id].size();
                 last_pos = ::mapreduce::util::write_to_buff(arr_part_buffs[part_id], ptr_shmem, last_pos, config.size.chunk.map, 0);
              }

              map_chnk_info.map_slot_id = map_slot_id;
              map_chnk_info.chunk_id = read_chunk_info.chunk_id;
              map_chnk_info.used = last_pos; //ptr_next-ptr_shmem;
              map_chnk_info.part_used = ::mapreduce::util::get_string(arr_part_used);

              if(map_chnk_info.used > config.size.chunk.map)
              {
                MLOG(ERROR, "The map operation for the chunk "<<map_chnk_info.chunk_id<<" and the map slot "<<map_chnk_info.map_slot_id
                             <<"cannot continue! (not enough virtual memory allocated for a map slot)");

                throw std::runtime_error("The operation cannot continue; not enough virtual memory allocated to a map slot!");
              }

              waitComm ( fvmPutGlobalData
              ( static_cast<fvmAllocHandle_t> (config.handle.map)
                                                , map_slot_id*config.size.chunk.map
                                                , last_pos //ptr_next-ptr_shmem
                                                , 0
                                                , 0
                                            )
              );

              // release the read_slot_id
              read_slot_id = read_chunk_info.read_slot_id;

              for(int k=0; k<config.num.part; k++ )
                 map_chnk_info.unhandled_part_set.insert(k);

              return map_chnk_info;
          ]]></code>
        </module>
      </defun>
      <connect-in port="map_slot_id" place="map_slot_id"/>
      <connect-read port="config" place="config"/>
      <connect-in port="read_chunk_info" place="read_chunk_info"/>
      <connect-out port="read_slot_id" place="read_slot_id"/>
      <connect-out port="map_chunk_info" place="map_chunk_info"/>
    </transition>

     <place name="map_chunk_info_new" type="map_chunk_info"/>

     <place name="partition_result" type="partition_result"/>
    <transition name="copy_into_partition_slot" inline="true">
      <require key="GPI" />
      <require key="PAR" />
    <defun>
        <in name="map_chunk_info" type="map_chunk_info"/>
        <in name="partition_info" type="partition_info"/>
        <in name="config" type="config"/>
        <out name="partition_result" type="partition_result"/>
        <out name="map_chunk_info_new" type="map_chunk_info"/>
        <module name="store_into_partition_slot" function="store_partition(map_chunk_info, partition_info, config, partition_result, map_chunk_info_new)">
           <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="ctype.h"/>
          <cinclude href="cstdio"/>
          <cinclude href="fstream"/>
          <cinclude href="boost/tokenizer.hpp"/>
          <cinclude href="vector"/>
          <cinclude href="util/partition.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="util/map.hpp"/>
          <code><![CDATA[
            // MLOG (INFO, "storing map chunk " << map_chunk_info.map_slot_id << " into partition " << partition_info.part_id);
            // do partitioning copy from the map_chunk store in map_slot_id
            // the data corresponding to the partition partition_result.partition_info.part_id

            size_t avail_shmem(fvmGetShmemSize());

            // initialize partition_result
            partition_result.map_chunk_info = map_chunk_info;

            partition_result.partition_info = partition_info;
            partition_result.succeeded = 0;

            std::vector<int> arr_part_used = ::mapreduce::util::get_array(map_chunk_info.part_used);
            int part_id = partition_info.part_id;
            // compute the partition offset
            size_t part_offset = 0;
            for(int k=0; k<part_id; k++)
                part_offset += arr_part_used[k];

            char* ptr_shmem = static_cast<char *> (fvmGetShmemPtr());

		  	if( arr_part_used[part_id]>avail_shmem )
		  	{
		  		throw std::runtime_error("The amount of shared memory should be larger than the partition used space!" );
		  	}

            // get the map pairs
            waitComm ( fvmGetGlobalData
            ( static_cast<fvmAllocHandle_t> (config.handle.map)
                                                , map_chunk_info.map_slot_id*config.size.chunk.map + part_offset
                                                , arr_part_used[part_id]
                                                , 0
                                                , 0
                                            )
            );

            size_t size(sizeof(char)*map_chunk_info.used+1);
            ptr_shmem[arr_part_used[part_id]] = 0;

            std::vector<std::string> list_pairs = ::mapreduce::util::get_list_items(ptr_shmem);

            char* ptr_next = ptr_shmem;
            bzero(ptr_shmem, config.size.partition.slot);

            size_t last_pos = 0;
            for(int k=0; k<list_pairs.size(); k++ )
            {
                std::string str_keyval_pair = list_pairs[k];

                ::mapreduce::util::key_val_pair_t kv_pair = ::mapreduce::util::str2kvpair(str_keyval_pair);
                std::string key = kv_pair.first;

                if(!key.empty())
                {
                    // put it into the right partition
                    int part_id = ::mapreduce::util::hash(key, config.num.part);
                    // MLOG(INFO,"The pair "<<str_keyval_pair<<", with the key "<<key<<" goes into partition "<<part_id);

                     if( part_id == partition_info.part_id )
                        last_pos = ::mapreduce::util::write_to_buff(str_keyval_pair, ptr_shmem, last_pos, config.size.partition.slot);
                }
            }

            long vm_part_offset = partition_info.part_id*config.size.partition.slot + partition_info.part_used;
            long needed = last_pos; //ptr_next-ptr_shmem;

            if (needed > config.size.partition.slot)
            {
                MLOG (ERROR, "cannot continue: " << needed << " bytes required, but I only have: " << config.size.partition.slot << " increase partition slot size!");
                throw std::runtime_error ("out of memory: partition slot too small");
            }

            if(partition_info.part_used + needed < config.size.partition.slot)
            {
                if(needed>0) // commit
                {
                    waitComm ( fvmPutGlobalData
	                ( static_cast<fvmAllocHandle_t> (config.handle.partition)
	                                                    , vm_part_offset
	                                                    , needed
	                                                    , 0
	                                                    , 0
	                                                )
	                );
                }

                partition_result.partition_info.part_used += needed;
                partition_result.succeeded = 1;
                partition_result.map_chunk_info.unhandled_part_set.erase(partition_info.part_id);
            }
            else // the partitioning didn't succeed -> should do a reduction first and emptying the partition
            {
                LOG_IF (WARN, partition_info.part_used == 0, "set succeeded to 0 and partition is not used");
                // the rest remains unchanged

                partition_result.succeeded = 0;
            }

	        map_chunk_info_new = partition_result.map_chunk_info;

          ]]></code>
        </module>
        <condition>
          !set_empty(${map_chunk_info.unhandled_part_set})
        </condition>
        <condition>
          set_is_element(${map_chunk_info.unhandled_part_set}, ${partition_info.part_id})
        </condition>
    </defun>
    <connect-in port="map_chunk_info" place="map_chunk_info"/>
    <connect-in port="partition_info" place="partition_info"/>
    <connect-read port="config" place="config"/>
    <connect-out port="partition_result" place="partition_result"/>
    <connect-out port="map_chunk_info_new" place="map_chunk_info_new"/>
    </transition>


		<transition name="update_map_chunk_info" inline="true">
	    	<defun>
	        <in name="map_chunk_info_new" type="map_chunk_info"/>
	        <out name="map_chunk_info" type="map_chunk_info"/>
		    <expression>
		        ${map_chunk_info} := ${map_chunk_info_new}
	        </expression>
	      	</defun>
	         <connect-in port="map_chunk_info_new" place="map_chunk_info_new"/>
	     	<connect-out port="map_chunk_info" place="map_chunk_info"/>
   		</transition>

    <transition name="check_partitions_done" inline="true" >
      <defun>
        <in name="map_chunk_info" type="map_chunk_info" />
        <out name="slot" type="long" />
        <out name="result" type="control" />
        <expression>
          ${slot} := ${map_chunk_info.map_slot_id};
          ${result} := [];
        </expression>
        <condition>
          set_empty(${map_chunk_info.unhandled_part_set})
        </condition>
      </defun>
      <connect-in  port="map_chunk_info" place="map_chunk_info"/>
      <connect-out port="slot" place="map_slot_id"/>
      <connect-out port="result" place="chunk_partitioned"/>
    </transition>



    <place name="chunk_partitioned" type="control"/>
    <transition name="post_partition" inline="true">
      <defun>
        <in name="partition_result" type="partition_result"/>
        <out name="partition_info" type="partition_info"/>

	    <expression>
		  	${partition_info} := ${partition_result.partition_info}
        </expression>
        <condition>
            ${partition_result.succeeded}:gt:0L
        </condition>
      </defun>
      <connect-in port="partition_result" place="partition_result"/>
      <connect-out port="partition_info" place="partition_info"/>
    </transition>

     <place name="partition_copy_result" type="partition_copy_result"/>
    <transition name="copy_partition_into_the_reduce_slot" inline="true">
      <require key="GPI" />
      <require key="PAR" />
      <defun>
        <in name="partition_result" type="partition_result"/>
        <in name="reduce_info" type="reduce_info"/>
        <in name="config" type="config"/>
        <out name="partition_copy_result" type="partition_copy_result"/>
        <module name="copy_partition" function="copy_partition_into_the_reduce_slot(config, partition_result, reduce_info, partition_copy_result)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="util/reduce.hpp"/>
          <cinclude href="boost/utility.hpp"/>
          <cinclude href="boost/thread.hpp"/>
          <cinclude href="boost/bind.hpp"/>
          <cinclude href="fhg/util/show.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="cstdio"/>
          <cinclude href="algorithm"/>

          <code><![CDATA[
			timestamp_t time_start_reduce = ::mapreduce::util::get_timestamp();
			size_t last_pos = 0;

            LOG (INFO, "Copy the partition "<<partition_result.partition_info.part_id<<" (space used: "<<partition_result.partition_info.part_used<<") into the corresponding reduce slot");

            char* ptr_shmem = static_cast<char *> (fvmGetShmemPtr());

            size_t total_size = partition_result.partition_info.part_used + 1 + reduce_info.red_used + 1;
            if( total_size > config.size.reduce.slot )
            {
            	MLOG (ERROR, "The reduce slot is full, call reduce!");
                // throw std::runtime_error ("out of memory: reduce slot too small");

                partition_copy_result.reduce_info = reduce_info;
             	partition_copy_result.partition_info = partition_result.partition_info;
             	partition_copy_result.succeeded = 0;
			}
			else
			{
	            if( partition_result.partition_info.part_used > fvmGetShmemSize() )
	            {
	            	MLOG (ERROR, "cannot store the partition "<<partition_result.partition_info.part_id<<" into the corresponding reduce slot: need " << partition_result.partition_info.part_used << " bytes (partition) but I only have "
	                              << fvmGetShmemSize() << ", increase shm size");
	                throw std::runtime_error ("out of memory: shm too small");
				}

	            if( reduce_info.red_used > fvmGetShmemSize() )
	            {
	            	MLOG (ERROR, "cannot retrieve the reduce slot content into the local shmem: need " << reduce_info.red_used << " bytes (reduce) but I only have "
	                              << fvmGetShmemSize() << ", increase shm size");
	                throw std::runtime_error ("out of memory: shm too small");
				}

				size_t used_size;
	            if(partition_copy_result.partition_info.part_used) //there is something to reduce
	            {
					timestamp_t time_start_get_part = ::mapreduce::util::get_timestamp();

	                long part_offset = partition_result.partition_info.part_id*config.size.partition.slot;
	                waitComm ( fvmGetGlobalData
	                ( static_cast<fvmAllocHandle_t> (config.handle.partition)
	                                                    , part_offset
	                                                    , partition_result.partition_info.part_used
	                                                    , 0
	                                                    , 0
	                                                )
					);

					last_pos = partition_result.partition_info.part_used;

					if( last_pos + reduce_info.red_used > config.size.reduce.slot )
	                {
	                    std::ostringstream osstr;
	                    osstr<<"Cannot write into the reduce slot "<<reduce_info.part_id<<"! (not enough space). Please, increase the reduce slot size, or save it on disk!";
	                    MLOG(ERROR, osstr.str());

		             	partition_copy_result.reduce_info = reduce_info;
		             	partition_copy_result.partition_info = partition_result.partition_info;
		             	partition_copy_result.succeeded = 0;
	                }
	                else
	                {
			             waitComm ( fvmPutGlobalData
			             ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
			                                                , reduce_info.part_id*config.size.reduce.slot + reduce_info.red_used
			                                                , last_pos
			                                                , 0
			                                                , 0
			                                            )
			             );

						 partition_copy_result.reduce_info.part_id = partition_result.partition_info.part_id;
						 partition_copy_result.reduce_info.old_red_used = reduce_info.red_used;
			             partition_copy_result.reduce_info.red_used = reduce_info.red_used + last_pos;

			             MLOG(INFO, "The old size of the reduce slot "<<partition_copy_result.reduce_info.part_id<< " was "<<partition_copy_result.reduce_info.old_red_used);
			             MLOG(INFO, "The new size of the reduce slot "<<partition_copy_result.reduce_info.part_id<< " is "<<partition_copy_result.reduce_info.red_used);

			             partition_copy_result.partition_info = partition_result.partition_info;

			             partition_copy_result.succeeded = 1;
		            }
				}
	            else // partition_info.part_used == 0, nothing to be done
	            {
	             	partition_copy_result.reduce_info = reduce_info;
	             	partition_copy_result.partition_info = partition_result.partition_info;
	             	partition_copy_result.succeeded = 0;

	                MLOG_IF (WARN, partition_result.succeeded, "condition is incorrect");
	                MLOG (ERROR, "The partition "<<partition_result.partition_info.part_id<<" is empty, there is nothing to reduce!");
	            }
            }

            timestamp_t time_end_reduce = ::mapreduce::util::get_timestamp();
			MLOG(INFO, "Copying the partition "<<reduce_info.part_id<<" into the corresponding reduce slot took "<<(time_end_reduce - time_start_reduce)/MS<<"ms");

          ]]></code>
        </module>
        <condition>
            ${partition_result.succeeded}:eq:0L
        </condition>
		<condition>
            ${reduce_info.part_id}:eq:${partition_result.partition_info.part_id}
        </condition>
      </defun>
      <connect-in port="partition_result" place="partition_result"/>
      <connect-in port="reduce_info" place="reduce_info"/>
      <connect-read port="config" place="config"/>
      <connect-out port="partition_copy_result" place="partition_copy_result"/>
    </transition>

    <place name="pre_reduce_info"  type="reduce_info"/>
    <transition name="release_partition" inline="true">
      <defun>
        <in name="partition_copy_result" type="partition_copy_result"/>
        <out name="partition_info" type="partition_info"/>
        <out name="pre_reduce_info" type="reduce_info"/>
        <expression>
        	${partition_info.part_id}:=${partition_copy_result.partition_info.part_id};
        	${partition_info.part_used}:=0L;
        	${pre_reduce_info}:=${partition_copy_result.reduce_info}
        </expression>
        <condition>
            ${partition_copy_result.succeeded}:eq:1L
        </condition>
      </defun>
      <connect-in port="partition_copy_result" place="partition_copy_result"/>
      <connect-out port="partition_info" place="partition_info"/>
      <connect-out port="pre_reduce_info" place="pre_reduce_info"/>
    </transition>

     <transition name="reduce" inline="true">
      <require key="GPI" />
      <require key="RED" />
      <defun>
        <in name="pre_reduce_info" type="reduce_info"/>
        <in name="config" type="config"/>
        <out name="reduce_info" type="reduce_info"/>
        <module name="reduce" function="reduce(config, pre_reduce_info, reduce_info)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="util/time.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="util/reduce.hpp"/>
          <cinclude href="boost/utility.hpp"/>
          <cinclude href="boost/thread.hpp"/>
          <cinclude href="boost/bind.hpp"/>
          <cinclude href="fhg/util/show.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="cstdio"/>
          <cinclude href="algorithm"/>

          <code><![CDATA[
		  	  timestamp_t time_start_reduce = ::mapreduce::util::get_timestamp();
		      MLOG (INFO, "Reduce the partition "<<pre_reduce_info.part_id<<", reduce space used: "<<pre_reduce_info.red_used);

		      size_t last_pos = 0;
		      if( pre_reduce_info.red_used != 0)
		      {
			      // first find out what are the actual sizes of the partitions!
			      char* ptr_shmem = static_cast<char *> (fvmGetShmemPtr());

			      if( pre_reduce_info.red_used > fvmGetShmemSize() )
			      {
			         MLOG (ERROR, "reduce cannot continue: need " << pre_reduce_info.red_used << " bytes (reduce) but I only have "
			                      << fvmGetShmemSize() << ", increase shm size");
			         throw std::runtime_error ("out of memory: shm too small");
			      }

					// read into local_buff from vm the reduce slot reduce_slot.id ((size: pre_reduce_info.red_used)
		            long reduce_offset = pre_reduce_info.part_id*config.size.reduce.slot;
		   			MLOG(INFO, "Get the content of the reduce slot from VM ...");
		            waitComm ( fvmGetGlobalData
		            ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
		                                                , reduce_offset+pre_reduce_info.old_red_used
		                                                , pre_reduce_info.red_used - pre_reduce_info.old_red_used
		                                                , 0
		                                                , 0
		                                            )
		            );

		            ptr_shmem[pre_reduce_info.red_used-pre_reduce_info.old_red_used] = 0;
		            std::vector<std::string> arr_part_items = ::mapreduce::util::get_list_items(ptr_shmem);

					std::vector<std::string>::iterator iter_middle( arr_part_items.begin() );
	                std::advance(iter_middle, arr_part_items.size()/2);
	                boost::thread thread0( boost::bind( &::mapreduce::util::my_sort, arr_part_items.begin(), iter_middle) );
	                boost::thread thread1( boost::bind( &::mapreduce::util::my_sort, iter_middle, arr_part_items.end()) );

		            if( pre_reduce_info.old_red_used == 0 )
					{
					 	thread0.join();
						thread1.join();
						std::inplace_merge( arr_part_items.begin(), iter_middle, arr_part_items.end());

			            MLOG(INFO, "Effectively call reduce on the resulted sorted array ...");
						timestamp_t time_start_red_arr = ::mapreduce::util::get_timestamp();
	                	::mapreduce::util::reduce_arr_buff(pre_reduce_info.part_id, config.size.reduce.slot, arr_part_items, ptr_shmem, last_pos );
	                	timestamp_t time_end_red_arr = ::mapreduce::util::get_timestamp();
	                	MLOG(INFO, "The effective reduce operation took "<<(time_end_red_arr - time_start_red_arr)/MS<<"ms");
		            }
		            else // pre_reduce_info.old_red_used > 0
		            {
						MLOG(INFO, "Get the content of the reduce slot from VM ...");
			            waitComm ( fvmGetGlobalData
			            ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
			                                                , reduce_offset
			                                                , pre_reduce_info.old_red_used
			                                                , 0
			                                                , 0
			                                            )
			            );

			            ptr_shmem[pre_reduce_info.old_red_used] = 0;

						// these items are supposed to be already sorted!
						timestamp_t time_start_parse = ::mapreduce::util::get_timestamp();
						std::vector<std::string> arr_old_red_items = ::mapreduce::util::get_list_items(ptr_shmem);
						timestamp_t time_end_parse = ::mapreduce::util::get_timestamp();
						MLOG(INFO, "parsing and tokenization took "<<(time_end_parse - time_start_parse)/MS<<"ms");

						thread0.join();
						thread1.join();

						std::inplace_merge( arr_part_items.begin(), iter_middle, arr_part_items.end());

	                	timestamp_t time_start_mrg_red_arr = ::mapreduce::util::get_timestamp();
	                	last_pos = ::mapreduce::util::merge_and_reduce_arr_buff(pre_reduce_info.part_id, config.size.reduce.slot, arr_old_red_items, arr_part_items, ptr_shmem );

	                	timestamp_t time_end_mrg_red_arr = ::mapreduce::util::get_timestamp();
	                	MLOG(INFO, "merge and reduce array took "<<(time_end_mrg_red_arr - time_start_mrg_red_arr)/MS<<"ms");

		            }

					if(last_pos>config.size.reduce.slot)
	                {
	                    std::ostringstream osstr;
	                    osstr<<"Cannot write into the reduce slot "<<pre_reduce_info.part_id<<"! (not enough space). Please, increase the reduce slot size!";
	                    throw std::runtime_error(osstr.str());
	                }

	                MLOG(INFO, "Store the new reduce slot into VM ...");

					waitComm ( fvmPutGlobalData
		            ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
		                                                , pre_reduce_info.part_id*config.size.reduce.slot
		                                                , last_pos
		                                                , 0
		                                                , 0
		                                            )
		            );
	            }

	            reduce_info.part_id = pre_reduce_info.part_id;
	            reduce_info.old_red_used = pre_reduce_info.red_used;
	            reduce_info.red_used = last_pos;

            	timestamp_t time_end_reduce = ::mapreduce::util::get_timestamp();
				MLOG(INFO, "The reduce operation took "<<(time_end_reduce - time_start_reduce)/MS<<"ms");

          ]]></code>
        </module>
      </defun>
      <connect-in port="pre_reduce_info" place="pre_reduce_info"/>
      <connect-read port="config" place="config"/>
      <connect-out port="reduce_info" place="reduce_info"/>
    </transition>

	<place name="reduce_result" type="reduce_result"/>

    <transition name="reduce_on_disk" inline="true">
      <require key="GPI" />
      <require key="RED" />
      <defun>
        <in name="partition_copy_result" type="partition_copy_result"/>
        <in name="config" type="config"/>
        <out name="new_reduce_info" type="reduce_info"/>
        <out name="reduce_result" type="reduce_result"/>
        <module name="reduce_and_save" function="reduce_and_save(config, partition_copy_result, new_reduce_info, reduce_result)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="util/reduce.hpp"/>
          <cinclude href="boost/utility.hpp"/>
          <cinclude href="boost/thread.hpp"/>
          <cinclude href="boost/bind.hpp"/>
          <cinclude href="fhg/util/show.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="cstdio"/>
          <cinclude href="algorithm"/>

          <code><![CDATA[
			timestamp_t time_start_reduce = ::mapreduce::util::get_timestamp();

		    MLOG (INFO, "Reduce the partition "<<partition_copy_result.reduce_info.part_id<<", reduce space used: "<<partition_copy_result.reduce_info.red_used);

		    size_t last_pos = 0;
		    if( partition_copy_result.reduce_info.red_used != 0)
		    {
				char* ptr_shmem = static_cast<char *> (fvmGetShmemPtr());

				if( partition_copy_result.reduce_info.red_used > fvmGetShmemSize() )
				{
					MLOG (ERROR, "reduce cannot continue: need " << partition_copy_result.reduce_info.red_used << " bytes (reduce) but I only have "
			                      << fvmGetShmemSize() << ". Please, increase the shared memory size");
			         throw std::runtime_error ("out of memory: shm too small");
				}

				// read into local_buff from vm the reduce slot reduce_slot.id ((size: partition_copy_result.reduce_info.red_used)
				long reduce_offset = partition_copy_result.reduce_info.part_id*config.size.reduce.slot;

	            MLOG(INFO, "Get the content of the reduce slot from VM ...");
	            waitComm ( fvmGetGlobalData
	            ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
	                                                , reduce_offset
	                                                , partition_copy_result.reduce_info.red_used
	                                                , 0
	                                                , 0
	                                            )
	            );

	            ptr_shmem[partition_copy_result.reduce_info.red_used] = 0;

				// do it simple this time, sort the whole content
				// afterwards, consider that the partition and the reduce slot are
				// already sorted and do a simple merge of both arrays

				MLOG(INFO, "Get the list of items corresponding to the reduce slot ...");
	            std::vector<std::string> arr_items = ::mapreduce::util::get_list_items(ptr_shmem);

                // call here merge_and_reduce
				std::string str_part_out_file = ::mapreduce::util::get_part_filename(config.file.output, partition_copy_result.reduce_info.part_id);

	           	MLOG(INFO, "Write the partition "<<partition_copy_result.reduce_info.part_id<<" into the file "<<str_part_out_file);

	           	// should do a merge_and_reduce here instead of just reduce_and_write
				::mapreduce::util::merge_and_reduce_arr_file(arr_items, str_part_out_file);
			}

            new_reduce_info.part_id = partition_copy_result.reduce_info.part_id;
            new_reduce_info.old_red_used = 0;
            new_reduce_info.red_used = 0; // free the reduce slot

            reduce_result.partition_info = partition_copy_result.partition_info;
            reduce_result.partition_locked = 1 - partition_copy_result.succeeded;

        	timestamp_t time_end_reduce = ::mapreduce::util::get_timestamp();
			MLOG(INFO, "The reduce operation took "<<(time_end_reduce - time_start_reduce)/MS<<"ms");

		]]></code>
		</module>
      </defun>
        <condition>
            ${partition_copy_result.succeeded}:eq:0L
        </condition>
      <connect-in port="partition_copy_result" place="partition_copy_result"/>
      <connect-read port="config" place="config"/>
      <connect-out port="new_reduce_info" place="reduce_info"/>
      <connect-out port="reduce_result" place="reduce_result"/>
    </transition>

     <transition name="retry_copy_partition" inline="true">
     <defun>
        <in name="reduce_result" type="reduce_result"/>
        <out name="partition_result" type="partition_result"/>
        <expression>
        	${partition_result.partition_info}:=${reduce_result.partition_info};
        	${partition_result.succeeded}:=1L
        </expression>
      </defun>
      <connect-in port="reduce_result" place="reduce_result"/>
      <connect-out port="partition_result" place="partition_result"/>
    </transition>

    <place name="all_chunks_done" type="control"/>

     <transition name="triple_all_chunks_done" inline="true">
      <use name="triple_control"/>
      <connect-in port="in" place="all_chunks_done"/>
      <connect-out port="one" place="all_chunks_done_map"/>
      <connect-out port="two" place="all_chunks_done_read"/>
      <connect-out port="three" place="all_chunks_done_border"/>
    </transition>

    <place name="all_chunks_done_map" type="control"/>
    <place name="all_chunks_done_read" type="control"/>
     <place name="all_chunks_done_border" type="control"/>

    <transition name="check_all_chunks_done" inline="true">
      <include-function href="check_update_counter.xpnet"/>
      <place-map real="n_chunks_left" virtual="counter"/>
      <connect-in port="trigger" place="chunk_partitioned"/>
      <connect-out port="done" place="all_chunks_done"/>
    </transition>

   <place name="map_slots_released" type="control"/>
    <transition name="release_map_slots" inline="true">
      <include-function href="release_tokens.xpnet"/>
      <connect-in port="counter" place="n_map_slots_cnt"/>
      <connect-in port="trigger" place="all_chunks_done_map"/>
      <place-map virtual="deposit" real="map_slot_id"/>
      <connect-out port="done" place="map_slots_released"/>
    </transition>

    <place name="read_slots_released" type="control"/>
    <transition name="release_read_slots" inline="true">
      <include-function href="release_tokens.xpnet"/>
      <connect-in port="counter" place="n_read_slots_cnt"/>
      <connect-in port="trigger" place="all_chunks_done_read"/>
      <place-map virtual="deposit" real="read_slot_id"/>
      <connect-out port="done" place="read_slots_released"/>
    </transition>

    <place name="reduce_and_write_done" type="control"/>
    <place name="special_partition_info" type="partition_info"/>
    <place name="special_reduce_info" type="reduce_info"/>
    <transition name="recover_border_keys">
      <require key="GPI" />
      <require key="PAR" />
      <defun>
        <in name="partition_info" type="partition_info"/>
        <in name="reduce_info" type="reduce_info"/>
        <in name="config" type="config"/>
        <in name="all_chunks_done_border" type="control"/>
        <out name="special_partition_info" type="partition_info"/>
        <out name="special_reduce_info" type="reduce_info"/>
        <out name="reduce_and_write_done" type="control"/>
         <module name="recover_border_keys" function="reduce_last_partition(	config,
         																		partition_info,
         																		reduce_info,
         																	 	special_partition_info,
         																	 	special_reduce_info,
         																	 	reduce_and_write_done)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="util/reduce.hpp"/>
          <cinclude href="util/map.hpp"/>
          <cinclude href="boost/utility.hpp"/>
          <cinclude href="boost/algorithm/string.hpp"/>
          <cinclude href="fstream"/>
          <cinclude href="sstream"/>
          <cinclude href="cstdio"/>
          <cinclude href="algorithm"/>

          <code><![CDATA[

            MLOG (INFO, "Recover the border keys, partition "<<partition_info.part_id<<", partition space used: "
                        <<partition_info.part_used<<", reduce space used: "<<reduce_info.red_used);
            // first find out what are the actual sizes of the partitions!
            char* ptr_shmem = static_cast<char *> (fvmGetShmemPtr());

            size_t total_size = partition_info.part_used + 1 + reduce_info.red_used+1;

            if (partition_info.part_used > fvmGetShmemSize ())
            {
                MLOG (ERROR, "reduce cannot continue: need " << partition_info.part_used
                             << " bytes (partition) but I only have " << fvmGetShmemSize() << ", increase shm size");
                throw std::runtime_error ("out of memory: shm too small");
            }

            if (reduce_info.red_used > fvmGetShmemSize ())
            {
                MLOG (ERROR, "reduce cannot continue: need " << reduce_info.red_used
                             << " bytes (reduce) but I only have " << fvmGetShmemSize() << ", increase shm size");
                throw std::runtime_error ("out of memory: shm too small");
            }

            size_t used_size = 0;
            if( partition_info.part_used )
            {
                //bzero( ptr_shmem, partition_info.part_used+1);
                long part_offset = partition_info.part_id*config.size.partition.slot;
                waitComm ( fvmGetGlobalData
                ( static_cast<fvmAllocHandle_t> (config.handle.partition)
                                                    , part_offset
                                                    , partition_info.part_used
                                                    , 0
                                                    , 0
                                                )
                );

                used_size = partition_info.part_used;
            }

            if(reduce_info.red_used)
            {
                // read into local_buff from vm the reduce slot reduce_slot.id ((size: reduce_info.red_used)
                long reduce_offset = partition_info.part_id*config.size.reduce.slot;

                if(partition_info.part_used)
                {
                    *(ptr_shmem + partition_info.part_used) = SPCH;

                    waitComm ( fvmGetGlobalData
	                ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
	                                                    , reduce_offset
	                                                    , reduce_info.red_used
	                                                    , partition_info.part_used + 1
	                                                    , 0
	                                                )
	                );

                    used_size += reduce_info.red_used+1;
                }
                else
                {
                    waitComm ( fvmGetGlobalData
	                ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
	                                                    , reduce_offset
	                                                    , reduce_info.red_used
	                                                    , 0
	                                                    , 0
	                                                )
	                );

                    used_size += reduce_info.red_used;
                }
            }

            ptr_shmem[used_size] = 0;

            if(used_size>0)
            {
	            std::vector<std::string> arr_items = ::mapreduce::util::get_list_items(ptr_shmem);
	            std::list<std::string> list_special_keys;

	            for(int k=0; k<arr_items.size(); k++ )
	            {
	                std::string keyval_pair = arr_items[k];
	                if(::mapreduce::util::is_special_item(keyval_pair))
	                    list_special_keys.push_back(keyval_pair);
	            }

	            while( !list_special_keys.empty() )
	            {
	                std::string keyval_pair = list_special_keys.front();
	                list_special_keys.pop_front();

	                // check if matches
	                std::string matching_pair;
	                int cid = -1;
	                int end = -1;

	                std:: string recovered_key = ::mapreduce::util::match_keys(keyval_pair, list_special_keys, matching_pair, cid, end );

	                if(!recovered_key.empty())
	                {
	                    std::vector<std::string>::iterator it_items = find (arr_items.begin(), arr_items.end(), keyval_pair);
	                    arr_items.erase(it_items);

	                    ::mapreduce::util::list_key_val_pairs_t list_key_val_pairs = ::mapreduce::util::map(recovered_key, "");

	                    BOOST_FOREACH(::mapreduce::util::key_val_pair_t& pair, list_key_val_pairs)
	                    {
	                        // put it into the right partition
	                        std::string key = pair.first;
	                        std::string val = pair.second;

	                        arr_items.push_back( mapreduce::util::kvpair2str(pair) );
	                    }

	                    if(!matching_pair.empty())
	                    {
	                        std::list<std::string>::iterator it_sp_matching_pair = find (list_special_keys.begin(), list_special_keys.end(), matching_pair);
	                        if(it_sp_matching_pair != list_special_keys.end() )
	                           list_special_keys.erase(it_sp_matching_pair);

	                        std::vector<std::string>::iterator it_items_matching_pair = find (arr_items.begin(), arr_items.end(), matching_pair);
	                        if( it_items_matching_pair != arr_items.end() )
	                           arr_items.erase(it_items_matching_pair);
	                    }
	                }
	            }

	            std::sort( arr_items.begin(), arr_items.end());
	            bzero(ptr_shmem, total_size);

	            // call reduce here
	            size_t last_pos = 0;
                ::mapreduce::util::reduce_arr_buff(partition_info.part_id, config.size.reduce.slot, arr_items, ptr_shmem, last_pos );

	            if(last_pos>config.size.reduce.slot)
                {
                    std::ostringstream osstr;
                    osstr<<"Cannot write into the reduce slot "<<partition_info.part_id<<"! (not enough space). Please, increase the reduce slot size!";
                    throw std::runtime_error(osstr.str());
                }

	            waitComm ( fvmPutGlobalData
	            ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
	                                                , partition_info.part_id*config.size.reduce.slot
	                                                , last_pos
	                                                , 0
	                                                , 0
	                                            )
	            );

	            special_partition_info.part_id = partition_info.part_id;
	            special_partition_info.part_used = 0;

	            special_reduce_info.part_id = reduce_info.part_id;
	            special_reduce_info.red_used = last_pos;
            }
            else
            {
                MLOG(INFO, "The last partition is empty, no border keys!");
                special_partition_info = partition_info;
            }

            reduce_and_write_done = we::type::literal::control();

          ]]></code>
        </module>
      </defun>
      <condition>
        ${partition_info.part_id}:eq:${config.num.part}-1
      </condition>
      <condition>
        ${reduce_info.part_id}:eq:${config.num.part}-1
      </condition>
      <connect-in port="partition_info" place="partition_info"/>
      <connect-in port="reduce_info" place="reduce_info"/>
      <connect-read port="config" place="config"/>
      <connect-in port="all_chunks_done_border" place="all_chunks_done_border"/>
      <connect-out port="special_partition_info" place="special_partition_info"/>
      <connect-out port="special_reduce_info" place="special_reduce_info"/>
      <connect-out port="reduce_and_write_done" place="reduce_and_write_done"/>
    </transition>

    <transition name="reduce_and_write">
      <require key="GPI" />
      <require key="WRITE" />
      <defun>

        <!-- <in name="map_slots_released" type="control"/>
        <in name="read_slots_released" type="control"/> -->

        <in name="special_partition_info" type="partition_info"/>
        <in name="special_reduce_info" type="reduce_info"/>
        <in name="partition_info" type="partition_info"/>
        <in name="reduce_info" type="reduce_info"/>
        <in name="config" type="config"/>
        <out name="reduce_and_write_done" type="control"/>
	     <module name="mapred" function="reduce_and_write(  config,
	     													special_partition_info, special_reduce_info,
	     													partition_info, reduce_info,
	     													reduce_and_write_done)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="util/partition.hpp"/>
          <cinclude href="util/reduce.hpp"/>
          <cinclude href="util/map.hpp"/>
          <cinclude href="boost/utility.hpp"/>
          <cinclude href="boost/thread.hpp"/>
          <cinclude href="boost/bind.hpp"/>
          <cinclude href="boost/algorithm/string.hpp"/>
          <cinclude href="fstream"/>
          <cinclude href="sstream"/>
          <cinclude href="cstdio"/>
          <cinclude href="algorithm"/>

          <code><![CDATA[

            LOG (INFO, "Reduce the partition "<<partition_info.part_id<<", partition space used: "<<partition_info.part_used<<", reduce space used: "<<reduce_info.red_used);
            // first find out what are the actual sizes of the partitions!
            char* ptr_shmem = static_cast<char *> (fvmGetShmemPtr());

            size_t total_size = partition_info.part_used + 1 + reduce_info.red_used + 1 + special_reduce_info.red_used + 1;

            if (partition_info.part_used > fvmGetShmemSize ())
            {
                 MLOG (ERROR, "reduce cannot continue: need " << partition_info.part_used
                            	<< " bytes (partition) but I only have " << fvmGetShmemSize() << ", increase shm size");
                 throw std::runtime_error ("out of memory: shm too small");
            }

            if (reduce_info.red_used > fvmGetShmemSize ())
            {
                 MLOG (ERROR, "reduce cannot continue: need " << reduce_info.red_used
                              << " bytes (reduce) but I only have " << fvmGetShmemSize() << ", increase shm size");
                 throw std::runtime_error ("out of memory: shm too small");
            }

            if (special_reduce_info.red_used > fvmGetShmemSize ())
            {
                 MLOG (ERROR, "reduce cannot continue: need " << reduce_info.red_used
                             << " bytes (reduce) but I only have " << fvmGetShmemSize() << ", increase shm size");
                 throw std::runtime_error ("out of memory: shm too small");
            }

            std::vector<std::string> arr_red_items, arr_items;
            if(partition_info.part_used) //there is something to reduce
            {
                long part_offset = partition_info.part_id*config.size.partition.slot;
                waitComm ( fvmGetGlobalData
                ( static_cast<fvmAllocHandle_t> (config.handle.partition)
                                                    , part_offset
                                                    , partition_info.part_used
                                                    , 0
                                                    , 0
                                                )
                );

                ptr_shmem[partition_info.part_used] = 0;
                std::vector<std::string> arr_part_items = ::mapreduce::util::get_list_items(ptr_shmem);

            	std::vector<std::string>::iterator iter_middle( arr_part_items.begin() );
                std::advance(iter_middle, arr_part_items.size()/2);
                boost::thread thread0( boost::bind( &::mapreduce::util::my_sort, arr_part_items.begin(), iter_middle) );
                boost::thread thread1( boost::bind( &::mapreduce::util::my_sort, iter_middle, arr_part_items.end()) );

                if(reduce_info.red_used)
                {
                    // read into local_buff from vm the reduce slot reduce_slot.id ((size: reduce_info.red_used)
                    long reduce_offset = partition_info.part_id*config.size.reduce.slot;

                    waitComm ( fvmGetGlobalData
                    ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
                                                        , reduce_offset
                                                        , reduce_info.red_used
                                                        , 0
                                                        , 0
                                                    )
                    );

                    ptr_shmem[reduce_info.red_used] = 0;
                    arr_red_items = ::mapreduce::util::get_list_items(ptr_shmem);
                }

                // one should assume:
                // the items are sorted in a reduce slot
                // the partition slot is formed from sorted sub-arrays
                // these sub-arrays are delimited by specific separators
                // when you do reduce, just get these sorted sub-arrays and
                // merge them with the reduce-slot

			 	thread0.join();
				thread1.join();
				std::inplace_merge( arr_part_items.begin(), iter_middle, arr_part_items.end());

                if(!arr_red_items.empty())
                {
                    arr_items.resize(arr_part_items.size() + arr_red_items.size());
                    std::merge( arr_part_items.begin(), arr_part_items.end(), arr_red_items.begin(), arr_red_items.end(), arr_items.begin() );
                }
                else
                   arr_items = arr_part_items;

                bzero(ptr_shmem, total_size);
            }

            if(!arr_items.empty())
            {
	            if(special_reduce_info.red_used)
	            {
	                bzero( ptr_shmem, special_reduce_info.red_used+1);
	                long last_red_slot_offset = (config.num.part-1)*config.size.reduce.slot;

	                waitComm ( fvmGetGlobalData
	                ( static_cast<fvmAllocHandle_t> (config.handle.reduce)
	                                                    , last_red_slot_offset
	                                                    , special_reduce_info.red_used
	                                                    , 0
	                                                    , 0
	                                                )
	                );

	                std::vector<std::string> arr_special_items = ::mapreduce::util::get_list_items(ptr_shmem);
	                BOOST_FOREACH(const std::string& spec_item, arr_special_items)
	                {
	                    if(::mapreduce::util::hash(spec_item, config.num.part) == partition_info.part_id )
	                        //arr_items.push_back(spec_item);
	                        ::mapreduce::util::insert_element(arr_items, spec_item);
	                }

	                arr_special_items.clear();
				}

	            std::string str_part_out_file = ::mapreduce::util::get_part_filename(config.file.output, partition_info.part_id);
	           	MLOG(INFO, "Write the partition "<<partition_info.part_id<<" into the file "<<str_part_out_file);

	            // either this
	           	// should do a merge_and_reduce here instead of just reduce_and_write
				//std::vector<std::string> arr_reduced_items;
	           	//::mapreduce::util::combine(arr_items, arr_reduced_items);

	           	// create new file
	           	//::mapreduce::util::reduce_arr_file(arr_reduced_items, str_part_out_file);

	           	// or this
	           	::mapreduce::util::merge_and_reduce_arr_file(arr_items, str_part_out_file);
            }

            reduce_and_write_done = we::type::literal::control();

          ]]></code>
        </module>
      </defun>
      <condition>
        ${partition_info.part_id}:lt:${config.num.part}-1
      </condition>
      <condition>
        ${reduce_info.part_id}:eq:${partition_info.part_id}
      </condition>

      <!-- <connect-read port="map_slots_released" place="map_slots_released"/>
      <connect-read port="read_slots_released" place="read_slots_released"/> -->

      <connect-read port="special_partition_info" place="special_partition_info"/>
      <connect-read port="special_reduce_info" place="special_reduce_info"/>
      <connect-in port="partition_info" place="partition_info"/>
      <connect-in port="reduce_info" place="reduce_info"/>
      <connect-read port="config" place="config"/>
      <connect-out port="reduce_and_write_done" place="reduce_and_write_done"/>
    </transition>

   	 <place name="write_done" type="control"/>
    <transition name="check_reduce_and_write_part_done" inline="true">
      <include-function href="check_update_counter.xpnet"/>
      <place-map real="n_part_slots_cnt" virtual="counter"/>
      <connect-in port="trigger" place="reduce_and_write_done"/>
      <connect-out port="done" place="write_done"/>
    </transition>



    <transition name="finalize">
      <require key="GPI" />
      <require key="FIN" />
      <defun>
        <in name="config" type="config"/>
        <in name="map_slots_released" type="control"/>
        <in name="read_slots_released" type="control"/>
        <in name="write_done" type="control"/>
        <in name="special_partition_info" type="partition_info"/>
        <in name="special_reduce_info" type="reduce_info"/>
        <out name="done" type="control"/>
        <module name="mapreduce_done" function="done finalize_mapreduce(config)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="util/memory.hpp"/>
          <code><![CDATA[
	          LOG (INFO, "finalize: " << config);

	          namespace vm = ::mapreduce::util::memory::global;

	          vm::free(config.handle.read);
	          vm::free(config.handle.map);
	          vm::free(config.handle.partition);
	          vm::free(config.handle.reduce);

	          return we::type::literal::control();
          ]]></code>
        </module>
      </defun>
      	<connect-in port="config" place="config"/>
    	<connect-in port="map_slots_released" place="map_slots_released"/>
    	<connect-in port="read_slots_released" place="read_slots_released"/>
    	<connect-in port="special_partition_info" place="special_partition_info"/>
    	<connect-in port="special_reduce_info" place="special_reduce_info"/>
    	<connect-in port="write_done" place="write_done"/>
    	<connect-out port="done" place="done"/>
    </transition>

   </net>
</defun>
