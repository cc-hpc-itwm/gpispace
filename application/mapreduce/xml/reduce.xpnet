<!-- tiberiu.rotaru@itwm.fraunhofer.de -->
<defun name="reduce">
	<include-structs href="types.xpnet"/>
	<!-- <in name="config" type="config" place="config"/> --> 
  <in name="reduce_info_in" type="iterator_red_info" place="reduce_info_in"/>
  <out name="reduce_info_out" type="iterator_red_info" place="reduce_info_out"/>

  <net>
	<place name="reduce_info_in" type="iterator_red_info"/>
	<place name="agg_iter_red_info" type="iterator_red_info"/>
  	<place name="gen_iterator_red_info" type="iterator_red_info"/>
  	<place name="n_reduce_tasks_left" type="long"/>
  	 <place name="reduce_info_out" type="iterator_red_info"/>
  	 <!-- <place name="config" type="config"/> -->
  	  	
  	<transition name="init" inline="true">
      <defun>
       	<in name="reduce_info_in" type="iterator_red_info"/>
		<out name="agg_iter_red_info" type="iterator_red_info"/>
  		<out name="gen_iterator_red_info" type="iterator_red_info"/>
  		<out name="n_reduce_tasks_left" type="long"/>
  		<module name="init" function="init(reduce_info_in, agg_iter_red_info, gen_iterator_red_info, n_reduce_tasks_left)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="util/memory.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="boost/tokenizer.hpp"/>
          <code><![CDATA[
	        MLOG (INFO, "Call Init " );
			  
		    std::cout<<"reduce_info_in.avail_slots = "<<reduce_info_in.avail_slots<<std::endl;
            std::cout<<"reduce_info_in.slots_to_reduce = "<<reduce_info_in.slots_to_reduce<<std::endl;
            std::cout<<"reduce_info_in.part_used = "<<reduce_info_in.part_used<<std::endl;
            std::cout<<"reduce_info_in.red_used = "<<reduce_info_in.red_used<<std::endl; 
	            
			// first find out what are the actual sizes of the partitions!
		  	//us this as a counter
			agg_iter_red_info.slots_to_reduce="";
			agg_iter_red_info.part_used="";
			agg_iter_red_info.red_used="";
			
			gen_iterator_red_info = reduce_info_in;
			
		  	MLOG(INFO, "list of partitions to reduce: "<<gen_iterator_red_info.slots_to_reduce);
		  	
		  	boost::char_separator<char> sep(" ");
        	boost::tokenizer<boost::char_separator<char> > tok(gen_iterator_red_info.slots_to_reduce, sep);
        	std::vector<std::string> arr_slots_to_reduce;
        	arr_slots_to_reduce.assign(tok.begin(),tok.end());
        
         	n_reduce_tasks_left = arr_slots_to_reduce.size();
         	agg_iter_red_info.avail_slots = n_reduce_tasks_left;
         	
         	MLOG(INFO, "number of partitions to reduce: "<<n_reduce_tasks_left);
          ]]></code>
        </module>
      </defun>
      <connect-in place="reduce_info_in" port="reduce_info_in"/>
      <connect-out place="agg_iter_red_info" port="agg_iter_red_info"/>
  	  <connect-out place="gen_iterator_red_info" port="gen_iterator_red_info"/>
  	  <connect-out place="n_reduce_tasks_left" port="n_reduce_tasks_left"/>
    </transition>
  	
  	<place name="reduce_slot" type="reduce_slot"/>
  	<place name="new_gen_iterator_red_info" type="iterator_red_info"/>
    <transition name="split">
      <defun>
       	<in name="gen_iterator_red_info" type="iterator_red_info"/>
        <out name="reduce_slot" type="reduce_slot"/>
        <out name="new_gen_iterator_red_info" type="iterator_red_info"/>
         <module name="split" function="get_next_part_id(gen_iterator_red_info, reduce_slot, new_gen_iterator_red_info)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="cstdio"/>
          <cinclude href="boost/tokenizer.hpp"/>
          <cinclude href="boost/foreach.hpp"/>
          <cinclude href="boost/lexical_cast.hpp"/>
          <cinclude href="vector"/>
          <code><![CDATA[
	        LOG (INFO, "Get next partition id to reduce ...");
			std::stringstream sstr(gen_iterator_red_info.slots_to_reduce);
			std::string str_id;
			sstr>>str_id;
			  			    
			std::ostringstream sstrrest;
			sstrrest<<sstr.rdbuf();
			  
			reduce_slot.id = boost::lexical_cast<long>(str_id);
			
			boost::char_separator<char> sep(" ");
            boost::tokenizer<boost::char_separator<char> > tok_part(gen_iterator_red_info.part_used, sep);
            std::vector<std::string> arr_part_used;
            arr_part_used.assign(tok_part.begin(),tok_part.end());
            
            reduce_slot.part_used = boost::lexical_cast<int>(arr_part_used[reduce_slot.id]);
            
            boost::tokenizer<boost::char_separator<char> > tok_red(gen_iterator_red_info.red_used, sep);
            std::vector<std::string> arr_red_used;
            arr_red_used.assign(tok_red.begin(),tok_red.end());
            
            reduce_slot.red_used = boost::lexical_cast<int>(arr_red_used[reduce_slot.id]);
              
            MLOG(INFO, "Next partition to reduce: "<<reduce_slot.id
            			<<", part_used: "<<reduce_slot.part_used
            			<<", red_used: "<<reduce_slot.red_used);
			  
			std::string str_left_ids(sstrrest.str());
			MLOG(INFO, "The list of ids left to reduce: "<<str_left_ids);
			  
			new_gen_iterator_red_info = gen_iterator_red_info;
			new_gen_iterator_red_info.slots_to_reduce = str_left_ids;
				          
          ]]></code>
        </module>
       <condition>
          ${gen_iterator_red_info.slots_to_reduce}:ne:""
        </condition>
      </defun>
      <connect-in place="gen_iterator_red_info" port="gen_iterator_red_info"/>
      <connect-out place="reduce_slot" port="reduce_slot"/>
      <connect-out place="new_gen_iterator_red_info" port="new_gen_iterator_red_info"/>
    </transition>
    
    <transition name="repeat">
      <defun>
       	<in name="new_gen_iterator_red_info" type="iterator_red_info"/>
        <out name="gen_iterator_red_info" type="iterator_red_info"/>
        <expression>
        	${gen_iterator_red_info}:=${new_gen_iterator_red_info};
        </expression> 
      </defun>
      <connect-in place="new_gen_iterator_red_info" port="new_gen_iterator_red_info"/>
      <connect-out place="gen_iterator_red_info" port="gen_iterator_red_info"/>
    </transition>

    <place name="end_gen_iter" type="iterator_red_info"/>
	<transition name="wait">
      <defun>
       	<in name="gen_iterator_red_info" type="iterator_red_info"/>
        <out name="end_gen_iter" type="iterator_red_info"/>
         <expression>
        	${end_gen_iter}:= ${gen_iterator_red_info};
         </expression>
        <condition>
          	${gen_iterator_red_info.slots_to_reduce}:eq:""
        </condition>
      </defun>
      <connect-in place="gen_iterator_red_info" port="gen_iterator_red_info"/>
      <connect-out place="end_gen_iter" port="end_gen_iter"/>
    </transition>
    
    <place name="reduce_done" type="control"/>
    <place name="reduce_slot_updated" type="reduce_slot"/>
	<transition name="reduce_partition">
      <defun>
       	<in name="reduce_slot" type="reduce_slot"/>
       	<!-- <in name="config" type="config"/> --> 
        <out name="reduce_done" type="control"/>
        <out name="reduce_slot_updated" type="reduce_slot"/>
        
         <module name="reduce_partition" function="reduce_done reduce(reduce_slot, reduce_slot_updated)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="sstream"/>
          
          <code><![CDATA[
	          LOG (INFO, "CALL HERE the reduce method reduce(part_k, reduce_k) -> reduce_k ...");
			 
			  LOG (INFO, "Reduce the partition "<<reduce_slot.id<<" partition size "<<reduce_slot.part_used<<", reduce slot size:"<<reduce_slot.red_used);
			  // first find out what are the actual sizes of the partitions!
			  
			  reduce_slot_updated.id = reduce_slot.id;
			  reduce_slot_updated.part_used = reduce_slot.part_used;
			  reduce_slot_updated.red_used = 125 + reduce_slot.red_used;
			   
			  return control();
			  
          ]]></code>
        </module>
       
      </defun>
      <connect-in place="reduce_slot" port="reduce_slot"/>
	  <!-- <connect-read place="config" port="config"/> --> 
      <connect-out place="reduce_done" port="reduce_done"/>
      <connect-out place="reduce_slot_updated" port="reduce_slot_updated"/>
    </transition>
    
     <place name="new_agg_iter_red_info" type="iterator_red_info"/>
	<transition name="accumulate">
      <defun>
       	<in name="reduce_slot_updated" type="reduce_slot"/>
       	<in name="agg_iter_red_info" type="iterator_red_info"/>
        <out name="new_agg_iter_red_info" type="iterator_red_info"/>
        
         <module name="accumulate" function="acc(agg_iter_red_info, reduce_slot_updated, new_agg_iter_red_info)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="boost/lexical_cast.hpp"/>
          
          <code><![CDATA[
          	LOG (INFO, "Accumulate reduction info ...");
          	LOG (INFO, "Before update: "<<agg_iter_red_info.slots_to_reduce<<std::endl<<agg_iter_red_info.part_used<<std::endl<<agg_iter_red_info.red_used);
          
		  	new_agg_iter_red_info.avail_slots = agg_iter_red_info.avail_slots-1;
		 	new_agg_iter_red_info.slots_to_reduce =  agg_iter_red_info.slots_to_reduce + std::string(" ") + boost::lexical_cast<std::string>(reduce_slot_updated.id);
			new_agg_iter_red_info.part_used = agg_iter_red_info.part_used + std::string(" ") +  boost::lexical_cast<std::string>(reduce_slot_updated.part_used);
		 	new_agg_iter_red_info.red_used = agg_iter_red_info.red_used + std::string(" ") +  boost::lexical_cast<std::string>(reduce_slot_updated.red_used);
		 
		 	LOG (INFO, "After update: "<<new_agg_iter_red_info.slots_to_reduce<<std::endl<<new_agg_iter_red_info.part_used<<std::endl<<new_agg_iter_red_info.red_used);
          ]]></code>
        </module>
        <condition>
        	${agg_iter_red_info.avail_slots}:gt:0L
        </condition>
       
      </defun>
      <connect-in place="agg_iter_red_info" port="agg_iter_red_info"/>
      <connect-in place="reduce_slot_updated" port="reduce_slot_updated"/>
      <connect-out place="new_agg_iter_red_info" port="new_agg_iter_red_info"/>
    </transition>
    
	<transition name="repeat_acc">
      <defun>
       	<in name="new_agg_iter_red_info" type="iterator_red_info"/>
        <out name="agg_iter_red_info" type="iterator_red_info"/>
        <expression>
        	${agg_iter_red_info}:=${new_agg_iter_red_info};
        </expression>
       
      </defun>
      <connect-in place="new_agg_iter_red_info" port="new_agg_iter_red_info"/>
      <connect-out place="agg_iter_red_info" port="agg_iter_red_info"/>
    </transition>
    
    <place name="all_reduce_tasks_done" type="control"/>
    <transition name="check_all_reduce_tasks_done" inline="true">
      <include-function href="check_update_counter.xpnet"/>
      <place-map real="n_reduce_tasks_left" virtual="counter"/>
      <connect-in port="trigger" place="reduce_done"/>
      <connect-out port="done" place="all_reduce_tasks_done"/>
    </transition>
   
	<transition name="stop">
      <defun>
       	<in name="agg_iter_red_info" type="iterator_red_info"/>
       	<in name="end_gen_iter" type="iterator_red_info"/>
       	<in name="all_reduce_tasks_done" type="control"/>
        <out name="reduce_info_out" type="iterator_red_info"/>
        <module name="update_reduce_info_out" function="update_reduce_info_out(agg_iter_red_info, end_gen_iter, reduce_info_out)">
          <cinclude href="fhglog/fhglog.hpp"/>
          <cinclude href="fvm-pc/pc.hpp"/>
          <cinclude href="sstream"/>
          <cinclude href="boost/tokenizer.hpp"/>
          <cinclude href="boost/foreach.hpp"/>
          <cinclude href="util/helper.hpp"/>
          <cinclude href="vector"/>
          
          <code><![CDATA[
	          LOG (INFO, "Update the partition and reduction info after reduction. Free the reduced partitions.");
	          pnetc::type::iterator_red_info::iterator_red_info part_info;
	            
	              MLOG(INFO, "End_gen_iter: avail_slots: "<<end_gen_iter.avail_slots
	              		<<", slots_to_reduce: "<<end_gen_iter.slots_to_reduce
            			<<", part_used: "<<end_gen_iter.part_used
            			<<", red_used: "<<end_gen_iter.red_used);
            			
            	::mapreduce::util::dump_iter_red_info("agg_iter_red_info", agg_iter_red_info);
            	
            	::mapreduce::util::dump_iter_red_info("end_gen_iter", end_gen_iter);
            	
	        	reduce_info_out.avail_slots = end_gen_iter.avail_slots;
	        	reduce_info_out.slots_to_reduce = "";
	        	
	        	std::vector<int> arr_red_ids = ::mapreduce::util::get_array(agg_iter_red_info.slots_to_reduce);
	        	std::vector<int> arr_red_upd = ::mapreduce::util::get_array(agg_iter_red_info.red_used);
	        	
	        	std::vector<int> arr_part_used = ::mapreduce::util::get_array(end_gen_iter.part_used);
	        	std::vector<int> arr_red_used  = ::mapreduce::util::get_array(end_gen_iter.red_used);
	        	
	        	for(std::vector<int>::iterator it(arr_red_ids.begin()); it!=arr_red_ids.end(); it++)
	        	{
	        		arr_part_used[*it]=0;
	        		arr_red_used[*it]=arr_red_upd[it-arr_red_ids.begin()];
	        	}
	        	
	        	reduce_info_out.part_used = ::mapreduce::util::get_string(arr_part_used);
	        	reduce_info_out.red_used = ::mapreduce::util::get_string(arr_red_used);
	        	
	        	::mapreduce::util::dump_iter_red_info("reduce_info_out", reduce_info_out);
			  
          ]]></code>
        </module>
        <condition>
        	${agg_iter_red_info.avail_slots}:eq:0L
        </condition>
      </defun>
      <connect-in place="agg_iter_red_info" port="agg_iter_red_info"/>
      <connect-in place="end_gen_iter" port="end_gen_iter"/>
      <connect-in place="all_reduce_tasks_done" port="all_reduce_tasks_done"/>
	  <connect-out place="reduce_info_out" port="reduce_info_out"/>
    </transition>
       
  </net>
</defun> 
