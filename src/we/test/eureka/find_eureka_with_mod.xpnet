<defun name="find_eureka">

  <in name="eureka_gid" type="string" place="eureka_group"/>
  <in name="token" type="unsigned long" place="token"/>

  <net>

    <place name="token" type="unsigned long"/>
    <place name="value" type="long"/>
    <place name="eureka_group" type="string"/>

    <transition name="generate_events">
      <defun>
        <in name="in" type="unsigned long"/>
        <in name="eureka_group" type="string"/>
        <out name="out" type="long"/>
        <module name="gen_eureka_with_mod" function="out generate_events(in)" eureka-group="find_small_value">
          <cinclude href="iostream"/>
          <cinclude href="stdlib.h"/>
          <cinclude href="time.h"/>
          <cinclude href="unistd.h"/>
          <!-- init random number between 1 to 30 -->
          <!-- our event (e) is 1 <= e < 20 : fix -->
          <code><![CDATA[
            srand(long(time(NULL)) ^ in);
            long value = rand() % 30 + 1;
            std::cout << "Event [in = " << in << " event=" << value << "]\n";

            if (value >= 20)
            {
              sleep(5);
            }

            return value;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="token"/>
      <connect-out port="out" place="value"/>
      <connect-read port="eureka_group" place="eureka_group"/>
    </transition>

    <transition name="got_an_event_eureka">
      <defun>
        <in name="in" type="long"/>
        <in name="eureka_group" type="string"/>
        <out name="eureka_good" type="set"/> <!-- you eureka, then put it here" -->
        <out name="eureka_bad" type="list"/> <!-- you do not eureka, then put it here" -->
        <module name="got_an_event" function="check_for_eureka (in, eureka_group, eureka_good, eureka_bad)">
          <cinclude href="iostream"/>
          <cinclude href="we/type/value/wrap.hpp"/>
          <code><![CDATA[
            if (in < 20L)
            {
              std::cout << "Eureka! [in = " << in << "]\n";
              eureka_good.insert (eureka_group);
            }
            else
            {
              eureka_bad.emplace_back (eureka_group);
            }
          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="value"/>
      <connect-in port="eureka_group" place="eureka_group"/>
      <connect-out-many port="eureka_bad" place="eureka_group"/> <!-- non-eureka pipe it back -->
      <connect-eureka port="eureka_good"/>   <!-- eureka!! -->
    </transition>

  </net>

</defun>
