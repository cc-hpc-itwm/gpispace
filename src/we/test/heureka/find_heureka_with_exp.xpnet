<defun name="find_heureka">

  <in name="ntokens" type="list" place="ntokens"/>
  <in name="heureka_gid" type="string" place="heureka_group"/>

  <net>
    <place name="ntokens" type="list"/>
    <place name="token" type="unsigned long"/>
    <place name="value" type="long"/>

    <place name="heureka_group" type="string"/>
    <place name="heureka" type="set"/>

    <transition name="generate_tokens">
      <defun>
        <inout name="in" type="list"/>
        <expression>
        </expression>
      </defun>
      <connect-in port="in" place="ntokens"/>
      <connect-out-many port="in" place="token"/>
    </transition>

    <transition name="generate_events">
      <defun>
        <in name="in" type="unsigned long"/>
        <in name="heureka_group" type="string"/>
        <out name="out" type="long"/>
        <module name="generate_heureka_with_exp" function="out generate_event(in)">
          <cinclude href="iostream"/>
          <cinclude href="stdlib.h"/>
          <cinclude href="time.h"/>
          <cinclude href="unistd.h"/>
          <!-- init random number between 1 to 30 -->
          <!-- our event (e) is 1 <= e < 20 : fix -->
          <code><![CDATA[
            srand(long(time(NULL)) ^ in);
            long value = rand() % 30 + 1;
            std::cout << "Eureka-or-not! [in = " << in << " event=" << value << "]\n";

            if (value >= 20)
            {
              sleep(5);
            }

            return value;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="token"/>
      <connect-out port="out" place="value"/>
      <connect-read port="heureka_group" place="heureka_group"/>
    </transition>

    <transition name="got_an_event_heureka">
      <defun>
        <in name="in" type="long"/>
        <in name="heureka_group" type="string"/>
        <out name="heureka_good" type="set"/> <!-- you heureka, then you are here" -->
        <expression>
          ${heureka_good} := set_insert (Set{}, ${heureka_group})
        </expression>
        <condition>${in} :lt: 20L</condition>
      </defun>
      <connect-in port="in" place="value"/>
      <connect-in port="heureka_group" place="heureka_group"/>
      <connect-eureka port="heureka_good"/>   <!-- heureka!! -->
    </transition>

    <transition name="no_event_heureka">
      <defun>
        <in name="in" type="long"/>
        <in name="heureka_group" type="string"/>
        <out name="heureka_bad" type="list"/> <!-- you don't heureka, then you here" -->
        <expression>
          ${heureka_bad} := stack_push (List(), ${heureka_group})
        </expression>
        <condition>${in} :ge: 20L</condition>
      </defun>
      <connect-in port="in" place="value"/>
      <connect-in port="heureka_group" place="heureka_group"/>
      <connect-out-many port="heureka_bad" place="heureka_group"/> <!-- non-heureka pipe it back -->
    </transition>
  </net>

</defun>
