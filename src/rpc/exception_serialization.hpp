// bernd.loerwald@itwm.fraunhofer.de

#ifndef FHG_RPC_EXCEPTION_SERIALIZATION_HPP
#define FHG_RPC_EXCEPTION_SERIALIZATION_HPP

#include <rpc/common.hpp>

#include <fhg/util/boost/serialization/unordered_map.hpp>

#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/optional.hpp>

#include <exception>
#include <functional>
#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>

namespace fhg
{
  namespace rpc
  {
    namespace exception
    {
      struct serialization_functions_tuple
      {
        //! \note needs to either return boost::none; or return a
        //! string which can be used to reconstruct a user_exception.
        //! \note one function may handle multiple exception types.
        std::function<boost::optional<std::string> (std::exception_ptr)> from_ptr;
        //! \note needs to return std::make_exception_ptr (user_exception (…));
        std::function<std::exception_ptr (std::string)> to_ptr;
        //! \note needs to std::throw_with_nested (user_exception (…));
        std::function<void (std::string)> throw_with_nested;
      };
      //! \note the serialization function which does not return a
      //! boost::none will have the deserialization functions of same
      //! name called. if multiple serialization functions return a
      //! string, it is undefined which one is used, but guaranteed
      //! that deserialization functions of same name are called when
      //! deserializing
      using serialization_functions =
        std::unordered_map<std::string, serialization_functions_tuple>;

      //! \note aggregated_[de]serialization functions are not user
      //! defined but auto-generated by aggregated_remote_function<>
      struct aggregated_serialization_functions;
      struct aggregated_serialization_functions_tuple
      {
        std::function< boost::optional<std::string>
                         ( std::exception_ptr
                         , serialization_functions const&
                         , aggregated_serialization_functions const&
                         )
                     > serialize;
        std::function< std::exception_ptr
                         ( std::string
                         , serialization_functions const&
                         , aggregated_serialization_functions const&
                         )
                     > deserialize;
      };
      //! \note inheritance instead of typedef to allow forward-decl
      //! and so recursive typedef
      struct aggregated_serialization_functions
        : public std::unordered_map
            <std::string, aggregated_serialization_functions_tuple>
      {};

      std::string serialize
        ( std::exception_ptr
        , serialization_functions const&
        , aggregated_serialization_functions const&
        );
      std::exception_ptr deserialize
        ( std::string
        , serialization_functions const&
        , aggregated_serialization_functions const&
        );

      template<typename T>
        boost::optional<std::string> aggregated_serialize
          ( std::exception_ptr exception
          , serialization_functions const& functions
          , aggregated_serialization_functions const& aggregated_functions
          )
      {
        try
        {
          std::rethrow_exception (exception);
        }
        catch (aggregated_exception<T> const& ex)
        {
          std::ostringstream oss;
          boost::archive::text_oarchive ar (oss);
          ar & ex.succeeded;

          std::unordered_map<endpoint_type, std::string> strings;
          for (std::pair<endpoint_type, std::exception_ptr> ee : ex.failed)
          {
            strings.emplace
              ( ee.first
              , serialize (ee.second, functions, aggregated_functions)
              );
          }
          ar & strings;

          return oss.str();
        }
        catch (...)
        {
          return boost::none;
        }
      }
      template<typename T>
        std::exception_ptr aggregated_deserialize
        ( std::string serialized
        , serialization_functions const& functions
        , aggregated_serialization_functions const& aggregated_functions
        )
      {
        std::istringstream iss (serialized);
        boost::archive::text_iarchive ar (iss);
        aggregated_exception<T> ex;
        ar & ex.succeeded;
        std::unordered_map<endpoint_type, std::string> strings;
        ar & strings;
        for (std::pair<endpoint_type, std::string> es : strings)
        {
          ex.failed.emplace
            ( es.first
            , deserialize (es.second, functions, aggregated_functions)
            );
        }

        return std::make_exception_ptr (ex);
      }
    }
  }
}

#endif
