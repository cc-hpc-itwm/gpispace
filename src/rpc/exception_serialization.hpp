// bernd.loerwald@itwm.fraunhofer.de

#ifndef FHG_RPC_EXCEPTION_SERIALIZATION_HPP
#define FHG_RPC_EXCEPTION_SERIALIZATION_HPP

#include <rpc/common.hpp>

#include <fhg/util/boost/serialization/unordered_map.hpp>

#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/optional.hpp>

#include <exception>
#include <functional>
#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>

namespace fhg
{
  namespace rpc
  {
    namespace exception
    {
      //! \note needs to either return boost::none; or return a string
      //! which can be used to reconstruct a user_exception.
      //! \note one function may handle multiple exception types.
      using from_exception_ptr_type =
        std::function<boost::optional<std::string> (std::exception_ptr)>;

      //! \note needs to std::throw_with_nested (user_exception (…));
      using throw_with_nested_type = std::function<void (std::string)>;

      //! \note needs to return std::make_exception_ptr (user_exception (…));
      using to_exception_ptr_type =
        std::function<std::exception_ptr (std::string)>;

      //! \note the serialization function which does not return a
      //! boost::none will have the deserialization functions of same
      //! name called. if multiple serialization functions return a
      //! string, it is undefined which one is used, but guaranteed
      //! that deserialization functions of same name are called when
      //! deserializing
      using serialization_functions =
        std::unordered_map<std::string, from_exception_ptr_type>;
      using deserialization_functions =
        std::unordered_map
          <std::string, std::pair<to_exception_ptr_type, throw_with_nested_type>>;

      //! \note aggregated_[de]serialization functions are not user
      //! defined but auto-generated by aggregated_remote_function<>
      struct aggregated_serialization_functions;
      struct aggregated_deserialization_functions;
      using aggregated_serialization_function =
        std::function< boost::optional<std::string>
                         ( std::exception_ptr
                         , serialization_functions const&
                         , aggregated_serialization_functions const&
                         )
                     >;
      using aggregated_deserialization_function =
        std::function< std::exception_ptr
                       ( std::string
                       , deserialization_functions const&
                       , aggregated_deserialization_functions const&
                       )
                     >;

      //! \note inheritance instead of typedef to allow forward-decl
      //! and so recursive typedef
      struct aggregated_serialization_functions
        : public std::unordered_map<std::string, aggregated_serialization_function> {};
      struct aggregated_deserialization_functions
        : public std::unordered_map<std::string, aggregated_deserialization_function> {};

      std::string serialize
        ( std::exception_ptr
        , serialization_functions const&
        , aggregated_serialization_functions const&
        );
      std::exception_ptr deserialize
        ( std::string
        , deserialization_functions const&
        , aggregated_deserialization_functions const&
        );

      template<typename T>
        boost::optional<std::string> aggregated_serialize
          ( std::exception_ptr exception
          , serialization_functions const& functions
          , aggregated_serialization_functions const& aggregated_functions
          )
      {
        try
        {
          std::rethrow_exception (exception);
        }
        catch (aggregated_exception<T> const& ex)
        {
          std::ostringstream oss;
          boost::archive::text_oarchive ar (oss);
          ar & ex.succeeded;

          std::unordered_map<endpoint_type, std::string> strings;
          for (std::pair<endpoint_type, std::exception_ptr> ee : ex.failed)
          {
            strings.emplace
              ( ee.first
              , serialize (ee.second, functions, aggregated_functions)
              );
          }
          ar & strings;

          return oss.str();
        }
        catch (...)
        {
          return boost::none;
        }
      }
      template<typename T>
        std::exception_ptr aggregated_deserialize
        ( std::string serialized
        , deserialization_functions const& functions
        , aggregated_deserialization_functions const& aggregated_functions
        )
      {
        std::istringstream iss (serialized);
        boost::archive::text_iarchive ar (iss);
        aggregated_exception<T> ex;
        ar & ex.succeeded;
        std::unordered_map<endpoint_type, std::string> strings;
        ar & strings;
        for (std::pair<endpoint_type, std::string> es : strings)
        {
          ex.failed.emplace
            ( es.first
            , deserialize (es.second, functions, aggregated_functions)
            );
        }

        return std::make_exception_ptr (ex);
      }
    }
  }
}

#endif
